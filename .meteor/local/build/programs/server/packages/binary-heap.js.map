{"version":3,"sources":["meteor://ðŸ’»app/packages/binary-heap/packages/binary-heap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mG","file":"/packages/binary-heap.js","sourcesContent":["(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/max-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// Constructor of Heap                                                                // 1\n// - comparator - Function - given two items returns a number                         // 2\n// - options:                                                                         // 3\n//   - initData - Array - Optional - the initial data in a format:                    // 4\n//        Object:                                                                     // 5\n//          - id - String - unique id of the item                                     // 6\n//          - value - Any - the data value                                            // 7\n//      each value is retained                                                        // 8\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index         // 9\n//       mappings internally. Standard IdMap is used by default.                      // 10\nMaxHeap = function (comparator, options) {                                            // 11\n  if (! _.isFunction(comparator))                                                     // 12\n    throw new Error('Passed comparator is invalid, should be a comparison function');\n  var self = this;                                                                    // 14\n                                                                                      // 15\n  // a C-style comparator that is given two values and returns a number,              // 16\n  // negative if the first value is less than the second, positive if the second      // 17\n  // value is greater than the first and zero if they are equal.                      // 18\n  self._comparator = comparator;                                                      // 19\n                                                                                      // 20\n  options = _.defaults(options || {}, { IdMap: IdMap });                              // 21\n                                                                                      // 22\n  // _heapIdx maps an id to an index in the Heap array the corresponding value        // 23\n  // is located on.                                                                   // 24\n  self._heapIdx = new options.IdMap;                                                  // 25\n                                                                                      // 26\n  // The Heap data-structure implemented as a 0-based contiguous array where          // 27\n  // every item on index idx is a node in a complete binary tree. Every node can      // 28\n  // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every       // 29\n  // node has a parent on index (idx-1)/2;                                            // 30\n  self._heap = [];                                                                    // 31\n                                                                                      // 32\n  // If the initial array is passed, we can build the heap in linear time             // 33\n  // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if         // 34\n  // we push elements one by one.                                                     // 35\n  if (_.isArray(options.initData))                                                    // 36\n    self._initFromData(options.initData);                                             // 37\n};                                                                                    // 38\n                                                                                      // 39\n_.extend(MaxHeap.prototype, {                                                         // 40\n  // Builds a new heap in-place in linear time based on passed data                   // 41\n  _initFromData: function (data) {                                                    // 42\n    var self = this;                                                                  // 43\n                                                                                      // 44\n    self._heap = _.map(data, function (o) {                                           // 45\n      return { id: o.id, value: o.value };                                            // 46\n    });                                                                               // 47\n                                                                                      // 48\n    _.each(data, function (o, i) {                                                    // 49\n      self._heapIdx.set(o.id, i);                                                     // 50\n    });                                                                               // 51\n                                                                                      // 52\n    if (! data.length)                                                                // 53\n      return;                                                                         // 54\n                                                                                      // 55\n    // start from the first non-leaf - the parent of the last leaf                    // 56\n    for (var i = parentIdx(data.length - 1); i >= 0; i--)                             // 57\n      self._downHeap(i);                                                              // 58\n  },                                                                                  // 59\n                                                                                      // 60\n  _downHeap: function (idx) {                                                         // 61\n    var self = this;                                                                  // 62\n                                                                                      // 63\n    while (leftChildIdx(idx) < self.size()) {                                         // 64\n      var left = leftChildIdx(idx);                                                   // 65\n      var right = rightChildIdx(idx);                                                 // 66\n      var largest = idx;                                                              // 67\n                                                                                      // 68\n      if (left < self.size()) {                                                       // 69\n        largest = self._maxIndex(largest, left);                                      // 70\n      }                                                                               // 71\n      if (right < self.size()) {                                                      // 72\n        largest = self._maxIndex(largest, right);                                     // 73\n      }                                                                               // 74\n                                                                                      // 75\n      if (largest === idx)                                                            // 76\n        break;                                                                        // 77\n                                                                                      // 78\n      self._swap(largest, idx);                                                       // 79\n      idx = largest;                                                                  // 80\n    }                                                                                 // 81\n  },                                                                                  // 82\n                                                                                      // 83\n  _upHeap: function (idx) {                                                           // 84\n    var self = this;                                                                  // 85\n                                                                                      // 86\n    while (idx > 0) {                                                                 // 87\n      var parent = parentIdx(idx);                                                    // 88\n      if (self._maxIndex(parent, idx) === idx) {                                      // 89\n        self._swap(parent, idx)                                                       // 90\n        idx = parent;                                                                 // 91\n      } else {                                                                        // 92\n        break;                                                                        // 93\n      }                                                                               // 94\n    }                                                                                 // 95\n  },                                                                                  // 96\n                                                                                      // 97\n  _maxIndex: function (idxA, idxB) {                                                  // 98\n    var self = this;                                                                  // 99\n    var valueA = self._get(idxA);                                                     // 100\n    var valueB = self._get(idxB);                                                     // 101\n    return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;                       // 102\n  },                                                                                  // 103\n                                                                                      // 104\n  // Internal: gets raw data object placed on idxth place in heap                     // 105\n  _get: function (idx) {                                                              // 106\n    var self = this;                                                                  // 107\n    return self._heap[idx].value;                                                     // 108\n  },                                                                                  // 109\n                                                                                      // 110\n  _swap: function (idxA, idxB) {                                                      // 111\n    var self = this;                                                                  // 112\n    var recA = self._heap[idxA];                                                      // 113\n    var recB = self._heap[idxB];                                                      // 114\n                                                                                      // 115\n    self._heapIdx.set(recA.id, idxB);                                                 // 116\n    self._heapIdx.set(recB.id, idxA);                                                 // 117\n                                                                                      // 118\n    self._heap[idxA] = recB;                                                          // 119\n    self._heap[idxB] = recA;                                                          // 120\n  },                                                                                  // 121\n                                                                                      // 122\n  get: function (id) {                                                                // 123\n    var self = this;                                                                  // 124\n    if (! self.has(id))                                                               // 125\n      return null;                                                                    // 126\n    return self._get(self._heapIdx.get(id));                                          // 127\n  },                                                                                  // 128\n  set: function (id, value) {                                                         // 129\n    var self = this;                                                                  // 130\n                                                                                      // 131\n    if (self.has(id)) {                                                               // 132\n      if (self.get(id) === value)                                                     // 133\n        return;                                                                       // 134\n                                                                                      // 135\n      var idx = self._heapIdx.get(id);                                                // 136\n      self._heap[idx].value = value;                                                  // 137\n                                                                                      // 138\n      // Fix the new value's position                                                 // 139\n      // Either bubble new value up if it is greater than its parent                  // 140\n      self._upHeap(idx);                                                              // 141\n      // or bubble it down if it is smaller than one of its children                  // 142\n      self._downHeap(idx);                                                            // 143\n    } else {                                                                          // 144\n      self._heapIdx.set(id, self._heap.length);                                       // 145\n      self._heap.push({ id: id, value: value });                                      // 146\n      self._upHeap(self._heap.length - 1);                                            // 147\n    }                                                                                 // 148\n  },                                                                                  // 149\n  remove: function (id) {                                                             // 150\n    var self = this;                                                                  // 151\n                                                                                      // 152\n    if (self.has(id)) {                                                               // 153\n      var last = self._heap.length - 1;                                               // 154\n      var idx = self._heapIdx.get(id);                                                // 155\n                                                                                      // 156\n      if (idx !== last) {                                                             // 157\n        self._swap(idx, last);                                                        // 158\n        self._heap.pop();                                                             // 159\n        self._heapIdx.remove(id);                                                     // 160\n                                                                                      // 161\n        // Fix the swapped value's position                                           // 162\n        self._upHeap(idx);                                                            // 163\n        self._downHeap(idx);                                                          // 164\n      } else {                                                                        // 165\n        self._heap.pop();                                                             // 166\n        self._heapIdx.remove(id);                                                     // 167\n      }                                                                               // 168\n    }                                                                                 // 169\n  },                                                                                  // 170\n  has: function (id) {                                                                // 171\n    var self = this;                                                                  // 172\n    return self._heapIdx.has(id);                                                     // 173\n  },                                                                                  // 174\n  empty: function () {                                                                // 175\n    var self = this;                                                                  // 176\n    return !self.size();                                                              // 177\n  },                                                                                  // 178\n  clear: function () {                                                                // 179\n    var self = this;                                                                  // 180\n    self._heap = [];                                                                  // 181\n    self._heapIdx.clear();                                                            // 182\n  },                                                                                  // 183\n  // iterate over values in no particular order                                       // 184\n  forEach: function (iterator) {                                                      // 185\n    var self = this;                                                                  // 186\n    _.each(self._heap, function (obj) {                                               // 187\n      return iterator(obj.value, obj.id);                                             // 188\n    });                                                                               // 189\n  },                                                                                  // 190\n  size: function () {                                                                 // 191\n    var self = this;                                                                  // 192\n    return self._heap.length;                                                         // 193\n  },                                                                                  // 194\n  setDefault: function (id, def) {                                                    // 195\n    var self = this;                                                                  // 196\n    if (self.has(id))                                                                 // 197\n      return self.get(id);                                                            // 198\n    self.set(id, def);                                                                // 199\n    return def;                                                                       // 200\n  },                                                                                  // 201\n  clone: function () {                                                                // 202\n    var self = this;                                                                  // 203\n    var clone = new MaxHeap(self._comparator, self._heap);                            // 204\n    return clone;                                                                     // 205\n  },                                                                                  // 206\n                                                                                      // 207\n  maxElementId: function () {                                                         // 208\n    var self = this;                                                                  // 209\n    return self.size() ? self._heap[0].id : null;                                     // 210\n  },                                                                                  // 211\n                                                                                      // 212\n  _selfCheck: function () {                                                           // 213\n    var self = this;                                                                  // 214\n    for (var i = 1; i < self._heap.length; i++)                                       // 215\n      if (self._maxIndex(parentIdx(i), i) !== parentIdx(i))                           // 216\n          throw new Error(\"An item with id \" + self._heap[i].id +                     // 217\n                          \" has a parent younger than it: \" +                         // 218\n                          self._heap[parentIdx(i)].id);                               // 219\n  }                                                                                   // 220\n});                                                                                   // 221\n                                                                                      // 222\nfunction leftChildIdx (i) { return i * 2 + 1; }                                       // 223\nfunction rightChildIdx (i) { return i * 2 + 2; }                                      // 224\nfunction parentIdx (i) { return (i - 1) >> 1; }                                       // 225\n                                                                                      // 226\n                                                                                      // 227\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\nMinHeap = function (comparator, options) {                                            // 1\n  var self = this;                                                                    // 2\n  MaxHeap.call(self, function (a, b) {                                                // 3\n    return -comparator(a, b);                                                         // 4\n  }, options);                                                                        // 5\n};                                                                                    // 6\n                                                                                      // 7\nMeteor._inherits(MinHeap, MaxHeap);                                                   // 8\n                                                                                      // 9\n_.extend(MinHeap.prototype, {                                                         // 10\n  maxElementId: function () {                                                         // 11\n    throw new Error(\"Cannot call maxElementId on MinHeap\");                           // 12\n  },                                                                                  // 13\n  minElementId: function () {                                                         // 14\n    var self = this;                                                                  // 15\n    return MaxHeap.prototype.maxElementId.call(self);                                 // 16\n  }                                                                                   // 17\n});                                                                                   // 18\n                                                                                      // 19\n                                                                                      // 20\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-max-heap.js                                               //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap                 // 1\n// with a Min-Heap as an encapsulated property.                                       // 2\n//                                                                                    // 3\n// Most of the operations are just proxy methods to call the same method on both      // 4\n// heaps.                                                                             // 5\n//                                                                                    // 6\n// This implementation takes 2*N memory but is fairly simple to write and             // 7\n// understand. And the constant factor of a simple Heap is usually smaller            // 8\n// compared to other two-way priority queues like Min/Max Heaps                       // 9\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)      // 10\n// and Interval Heaps                                                                 // 11\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)                       // 12\nMinMaxHeap = function (comparator, options) {                                         // 13\n  var self = this;                                                                    // 14\n                                                                                      // 15\n  MaxHeap.call(self, comparator, options);                                            // 16\n  self._minHeap = new MinHeap(comparator, options);                                   // 17\n};                                                                                    // 18\n                                                                                      // 19\nMeteor._inherits(MinMaxHeap, MaxHeap);                                                // 20\n                                                                                      // 21\n_.extend(MinMaxHeap.prototype, {                                                      // 22\n  set: function (id, value) {                                                         // 23\n    var self = this;                                                                  // 24\n    MaxHeap.prototype.set.apply(self, arguments);                                     // 25\n    self._minHeap.set(id, value);                                                     // 26\n  },                                                                                  // 27\n  remove: function (id) {                                                             // 28\n    var self = this;                                                                  // 29\n    MaxHeap.prototype.remove.apply(self, arguments);                                  // 30\n    self._minHeap.remove(id);                                                         // 31\n  },                                                                                  // 32\n  clear: function () {                                                                // 33\n    var self = this;                                                                  // 34\n    MaxHeap.prototype.clear.apply(self, arguments);                                   // 35\n    self._minHeap.clear();                                                            // 36\n  },                                                                                  // 37\n  setDefault: function (id, def) {                                                    // 38\n    var self = this;                                                                  // 39\n    MaxHeap.prototype.setDefault.apply(self, arguments);                              // 40\n    return self._minHeap.setDefault(id, def);                                         // 41\n  },                                                                                  // 42\n  clone: function () {                                                                // 43\n    var self = this;                                                                  // 44\n    var clone = new MinMaxHeap(self._comparator, self._heap);                         // 45\n    return clone;                                                                     // 46\n  },                                                                                  // 47\n  minElementId: function () {                                                         // 48\n    var self = this;                                                                  // 49\n    return self._minHeap.minElementId();                                              // 50\n  }                                                                                   // 51\n});                                                                                   // 52\n                                                                                      // 53\n                                                                                      // 54\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}