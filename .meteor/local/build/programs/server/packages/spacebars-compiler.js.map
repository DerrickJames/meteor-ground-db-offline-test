{"version":3,"sources":["meteor://ðŸ’»app/packages/spacebars-compiler/packages/spacebars-compiler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qH","file":"/packages/spacebars-compiler.js","sourcesContent":["(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/templatetag.js                                                          //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\nSpacebarsCompiler = {};                                                                                // 1\n                                                                                                       // 2\n// A TemplateTag is the result of parsing a single `{{...}}` tag.                                      // 3\n//                                                                                                     // 4\n// The `.type` of a TemplateTag is one of:                                                             // 5\n//                                                                                                     // 6\n// - `\"DOUBLE\"` - `{{foo}}`                                                                            // 7\n// - `\"TRIPLE\"` - `{{{foo}}}`                                                                          // 8\n// - `\"EXPR\"` - `(foo)`                                                                                // 9\n// - `\"COMMENT\"` - `{{! foo}}`                                                                         // 10\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`                                                                 // 11\n// - `\"INCLUSION\"` - `{{> foo}}`                                                                       // 12\n// - `\"BLOCKOPEN\"` - `{{#foo}}`                                                                        // 13\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`                                                                       // 14\n// - `\"ELSE\"` - `{{else}}`                                                                             // 15\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on                                                     // 16\n//                                                                                                     // 17\n// Besides `type`, the mandatory properties of a TemplateTag are:                                      // 18\n//                                                                                                     // 19\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`                              // 20\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,                            // 21\n//   and BLOCKCLOSE.                                                                                   // 22\n//                                                                                                     // 23\n// - `args` - An array of zero or more argument specs.  An argument spec                               // 24\n//   is a two or three element array, consisting of a type, value, and                                 // 25\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`                            // 26\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,                                // 27\n//   TRIPLE, INCLUSION, and BLOCKOPEN.                                                                 // 28\n//                                                                                                     // 29\n// - `value` - A string of the comment's text. Applies to COMMENT and                                  // 30\n//   BLOCKCOMMENT.                                                                                     // 31\n//                                                                                                     // 32\n// These additional are typically set during parsing:                                                  // 33\n//                                                                                                     // 34\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort                          // 35\n//   of site the TemplateTag was encountered (e.g. at element level or as                              // 36\n//   part of an attribute value). Its absence implies                                                  // 37\n//   TEMPLATE_TAG_POSITION.ELEMENT.                                                                    // 38\n//                                                                                                     // 39\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are                                 // 40\n//   parsed, they are put here.  `elseContent` will only be present if                                 // 41\n//   an `{{else}}` was found.                                                                          // 42\n                                                                                                       // 43\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;                                           // 44\n                                                                                                       // 45\nTemplateTag = SpacebarsCompiler.TemplateTag = function () {                                            // 46\n  HTMLTools.TemplateTag.apply(this, arguments);                                                        // 47\n};                                                                                                     // 48\nTemplateTag.prototype = new HTMLTools.TemplateTag;                                                     // 49\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';                               // 50\n                                                                                                       // 51\nvar makeStacheTagStartRegex = function (r) {                                                           // 52\n  return new RegExp(r.source + /(?![{>!#/])/.source,                                                   // 53\n                    r.ignoreCase ? 'i' : '');                                                          // 54\n};                                                                                                     // 55\n                                                                                                       // 56\n// \"starts\" regexes are used to see what type of template                                              // 57\n// tag the parser is looking at.  They must match a non-empty                                          // 58\n// result, but not the interesting part of the tag.                                                    // 59\nvar starts = {                                                                                         // 60\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,                                                                            // 61\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),                                             // 62\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),                                                   // 63\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),                                                 // 64\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),                                                // 65\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),                                                       // 66\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),                                            // 67\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),                                            // 68\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)                                           // 69\n};                                                                                                     // 70\n                                                                                                       // 71\nvar ends = {                                                                                           // 72\n  DOUBLE: /^\\s*\\}\\}/,                                                                                  // 73\n  TRIPLE: /^\\s*\\}\\}\\}/,                                                                                // 74\n  EXPR: /^\\s*\\)/                                                                                       // 75\n};                                                                                                     // 76\n                                                                                                       // 77\nvar endsString = {                                                                                     // 78\n  DOUBLE: '}}',                                                                                        // 79\n  TRIPLE: '}}}',                                                                                       // 80\n  EXPR: ')'                                                                                            // 81\n};                                                                                                     // 82\n                                                                                                       // 83\n// Parse a tag from the provided scanner or string.  If the input                                      // 84\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds                                  // 85\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using                              // 86\n// `scanner.fatal` if a scanner is provided).                                                          // 87\nTemplateTag.parse = function (scannerOrString) {                                                       // 88\n  var scanner = scannerOrString;                                                                       // 89\n  if (typeof scanner === 'string')                                                                     // 90\n    scanner = new HTMLTools.Scanner(scannerOrString);                                                  // 91\n                                                                                                       // 92\n  if (! (scanner.peek() === '{' &&                                                                     // 93\n         (scanner.rest()).slice(0, 2) === '{{'))                                                       // 94\n    return null;                                                                                       // 95\n                                                                                                       // 96\n  var run = function (regex) {                                                                         // 97\n    // regex is assumed to start with `^`                                                              // 98\n    var result = regex.exec(scanner.rest());                                                           // 99\n    if (! result)                                                                                      // 100\n      return null;                                                                                     // 101\n    var ret = result[0];                                                                               // 102\n    scanner.pos += ret.length;                                                                         // 103\n    return ret;                                                                                        // 104\n  };                                                                                                   // 105\n                                                                                                       // 106\n  var advance = function (amount) {                                                                    // 107\n    scanner.pos += amount;                                                                             // 108\n  };                                                                                                   // 109\n                                                                                                       // 110\n  var scanIdentifier = function (isFirstInPath) {                                                      // 111\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);                                          // 112\n    if (! id) {                                                                                        // 113\n      expected('IDENTIFIER');                                                                          // 114\n    }                                                                                                  // 115\n    if (isFirstInPath &&                                                                               // 116\n        (id === 'null' || id === 'true' || id === 'false'))                                            // 117\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");              // 118\n                                                                                                       // 119\n    return id;                                                                                         // 120\n  };                                                                                                   // 121\n                                                                                                       // 122\n  var scanPath = function () {                                                                         // 123\n    var segments = [];                                                                                 // 124\n                                                                                                       // 125\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc                                   // 126\n    var dots;                                                                                          // 127\n    if ((dots = run(/^[\\.\\/]+/))) {                                                                    // 128\n      var ancestorStr = '.'; // eg `../../..` maps to `....`                                           // 129\n      var endsWithSlash = /\\/$/.test(dots);                                                            // 130\n                                                                                                       // 131\n      if (endsWithSlash)                                                                               // 132\n        dots = dots.slice(0, -1);                                                                      // 133\n                                                                                                       // 134\n      _.each(dots.split('/'), function(dotClause, index) {                                             // 135\n        if (index === 0) {                                                                             // 136\n          if (dotClause !== '.' && dotClause !== '..')                                                 // 137\n            expected(\"`.`, `..`, `./` or `../`\");                                                      // 138\n        } else {                                                                                       // 139\n          if (dotClause !== '..')                                                                      // 140\n            expected(\"`..` or `../`\");                                                                 // 141\n        }                                                                                              // 142\n                                                                                                       // 143\n        if (dotClause === '..')                                                                        // 144\n          ancestorStr += '.';                                                                          // 145\n      });                                                                                              // 146\n                                                                                                       // 147\n      segments.push(ancestorStr);                                                                      // 148\n                                                                                                       // 149\n      if (!endsWithSlash)                                                                              // 150\n        return segments;                                                                               // 151\n    }                                                                                                  // 152\n                                                                                                       // 153\n    while (true) {                                                                                     // 154\n      // scan a path segment                                                                           // 155\n                                                                                                       // 156\n      if (run(/^\\[/)) {                                                                                // 157\n        var seg = run(/^[\\s\\S]*?\\]/);                                                                  // 158\n        if (! seg)                                                                                     // 159\n          error(\"Unterminated path segment\");                                                          // 160\n        seg = seg.slice(0, -1);                                                                        // 161\n        if (! seg && ! segments.length)                                                                // 162\n          error(\"Path can't start with empty string\");                                                 // 163\n        segments.push(seg);                                                                            // 164\n      } else {                                                                                         // 165\n        var id = scanIdentifier(! segments.length);                                                    // 166\n        if (id === 'this') {                                                                           // 167\n          if (! segments.length) {                                                                     // 168\n            // initial `this`                                                                          // 169\n            segments.push('.');                                                                        // 170\n          } else {                                                                                     // 171\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }                                                                                            // 173\n        } else {                                                                                       // 174\n          segments.push(id);                                                                           // 175\n        }                                                                                              // 176\n      }                                                                                                // 177\n                                                                                                       // 178\n      var sep = run(/^[\\.\\/]/);                                                                        // 179\n      if (! sep)                                                                                       // 180\n        break;                                                                                         // 181\n    }                                                                                                  // 182\n                                                                                                       // 183\n    return segments;                                                                                   // 184\n  };                                                                                                   // 185\n                                                                                                       // 186\n  // scan the keyword portion of a keyword argument                                                    // 187\n  // (the \"foo\" portion in \"foo=bar\").                                                                 // 188\n  // Result is either the keyword matched, or null                                                     // 189\n  // if we're not at a keyword argument position.                                                      // 190\n  var scanArgKeyword = function () {                                                                   // 191\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());                             // 192\n    if (match) {                                                                                       // 193\n      scanner.pos += match[0].length;                                                                  // 194\n      return match[1];                                                                                 // 195\n    } else {                                                                                           // 196\n      return null;                                                                                     // 197\n    }                                                                                                  // 198\n  };                                                                                                   // 199\n                                                                                                       // 200\n  // scan an argument; succeeds or errors.                                                             // 201\n  // Result is an array of two or three items:                                                         // 202\n  // type , value, and (indicating a keyword argument)                                                 // 203\n  // keyword name.                                                                                     // 204\n  var scanArg = function () {                                                                          // 205\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg                                     // 206\n    var value = scanArgValue();                                                                        // 207\n    return keyword ? value.concat(keyword) : value;                                                    // 208\n  };                                                                                                   // 209\n                                                                                                       // 210\n  // scan an argument value (for keyword or positional arguments);                                     // 211\n  // succeeds or errors.  Result is an array of type, value.                                           // 212\n  var scanArgValue = function () {                                                                     // 213\n    var startPos = scanner.pos;                                                                        // 214\n    var result;                                                                                        // 215\n    if ((result = BlazeTools.parseNumber(scanner))) {                                                  // 216\n      return ['NUMBER', result.value];                                                                 // 217\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {                                    // 218\n      return ['STRING', result.value];                                                                 // 219\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {                                                       // 220\n      return ['PATH', scanPath()];                                                                     // 221\n    } else if (run(/^\\(/)) {                                                                           // 222\n      return ['EXPR', scanExpr('EXPR')];                                                               // 223\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {                           // 224\n      var id = result;                                                                                 // 225\n      if (id === 'null') {                                                                             // 226\n        return ['NULL', null];                                                                         // 227\n      } else if (id === 'true' || id === 'false') {                                                    // 228\n        return ['BOOLEAN', id === 'true'];                                                             // 229\n      } else {                                                                                         // 230\n        scanner.pos = startPos; // unconsume `id`                                                      // 231\n        return ['PATH', scanPath()];                                                                   // 232\n      }                                                                                                // 233\n    } else {                                                                                           // 234\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }                                                                                                  // 236\n  };                                                                                                   // 237\n                                                                                                       // 238\n  var scanExpr = function (type) {                                                                     // 239\n    var endType = type;                                                                                // 240\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN')                                                  // 241\n      endType = 'DOUBLE';                                                                              // 242\n                                                                                                       // 243\n    var tag = new TemplateTag;                                                                         // 244\n    tag.type = type;                                                                                   // 245\n    tag.path = scanPath();                                                                             // 246\n    tag.args = [];                                                                                     // 247\n    var foundKwArg = false;                                                                            // 248\n    while (true) {                                                                                     // 249\n      run(/^\\s*/);                                                                                     // 250\n      if (run(ends[endType]))                                                                          // 251\n        break;                                                                                         // 252\n      else if (/^[})]/.test(scanner.peek())) {                                                         // 253\n        expected('`' + endsString[endType] + '`');                                                     // 254\n      }                                                                                                // 255\n      var newArg = scanArg();                                                                          // 256\n      if (newArg.length === 3) {                                                                       // 257\n        foundKwArg = true;                                                                             // 258\n      } else {                                                                                         // 259\n        if (foundKwArg)                                                                                // 260\n          error(\"Can't have a non-keyword argument after a keyword argument\");                         // 261\n      }                                                                                                // 262\n      tag.args.push(newArg);                                                                           // 263\n                                                                                                       // 264\n      // expect a whitespace or a closing ')' or '}'                                                   // 265\n      if (run(/^(?=[\\s})])/) !== '')                                                                   // 266\n        expected('space');                                                                             // 267\n    }                                                                                                  // 268\n                                                                                                       // 269\n    return tag;                                                                                        // 270\n  };                                                                                                   // 271\n                                                                                                       // 272\n  var type;                                                                                            // 273\n                                                                                                       // 274\n  var error = function (msg) {                                                                         // 275\n    scanner.fatal(msg);                                                                                // 276\n  };                                                                                                   // 277\n                                                                                                       // 278\n  var expected = function (what) {                                                                     // 279\n    error('Expected ' + what);                                                                         // 280\n  };                                                                                                   // 281\n                                                                                                       // 282\n  // must do ESCAPE first, immediately followed by ELSE                                                // 283\n  // order of others doesn't matter                                                                    // 284\n  if (run(starts.ESCAPE)) type = 'ESCAPE';                                                             // 285\n  else if (run(starts.ELSE)) type = 'ELSE';                                                            // 286\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';                                                        // 287\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';                                                        // 288\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';                                            // 289\n  else if (run(starts.COMMENT)) type = 'COMMENT';                                                      // 290\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';                                                  // 291\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';                                                  // 292\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';                                                // 293\n  else                                                                                                 // 294\n    error('Unknown stache tag');                                                                       // 295\n                                                                                                       // 296\n  var tag = new TemplateTag;                                                                           // 297\n  tag.type = type;                                                                                     // 298\n                                                                                                       // 299\n  if (type === 'BLOCKCOMMENT') {                                                                       // 300\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);                                                           // 301\n    if (! result)                                                                                      // 302\n      error(\"Unclosed block comment\");                                                                 // 303\n    tag.value = result.slice(0, result.lastIndexOf('--'));                                             // 304\n  } else if (type === 'COMMENT') {                                                                     // 305\n    var result = run(/^[\\s\\S]*?\\}\\}/);                                                                 // 306\n    if (! result)                                                                                      // 307\n      error(\"Unclosed comment\");                                                                       // 308\n    tag.value = result.slice(0, -2);                                                                   // 309\n  } else if (type === 'BLOCKCLOSE') {                                                                  // 310\n    tag.path = scanPath();                                                                             // 311\n    if (! run(ends.DOUBLE))                                                                            // 312\n      expected('`}}`');                                                                                // 313\n  } else if (type === 'ELSE') {                                                                        // 314\n    if (! run(ends.DOUBLE))                                                                            // 315\n      expected('`}}`');                                                                                // 316\n  } else if (type === 'ESCAPE') {                                                                      // 317\n    var result = run(/^\\{*\\|/);                                                                        // 318\n    tag.value = '{{' + result.slice(0, -1);                                                            // 319\n  } else {                                                                                             // 320\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION                                                            // 321\n    tag = scanExpr(type);                                                                              // 322\n  }                                                                                                    // 323\n                                                                                                       // 324\n  return tag;                                                                                          // 325\n};                                                                                                     // 326\n                                                                                                       // 327\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner                      // 328\n// at its original position.                                                                           // 329\n//                                                                                                     // 330\n// An error will still be thrown if there is not a valid template tag at                               // 331\n// the current position.                                                                               // 332\nTemplateTag.peek = function (scanner) {                                                                // 333\n  var startPos = scanner.pos;                                                                          // 334\n  var result = TemplateTag.parse(scanner);                                                             // 335\n  scanner.pos = startPos;                                                                              // 336\n  return result;                                                                                       // 337\n};                                                                                                     // 338\n                                                                                                       // 339\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete                             // 340\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather                             // 341\n// than just the BLOCKOPEN tag.                                                                        // 342\n//                                                                                                     // 343\n// In addition:                                                                                        // 344\n//                                                                                                     // 345\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.                                   // 346\n//                                                                                                     // 347\n// - Returns `null` for a COMMENT.  (This case is distinguishable from                                 // 348\n//   parsing no tag by the fact that the scanner is advanced.)                                         // 349\n//                                                                                                     // 350\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the                            // 351\n//   TemplateTag's `.position` property.                                                               // 352\n//                                                                                                     // 353\n// - Validates the tag's well-formedness and legality at in its position.                              // 354\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {                                  // 355\n  var scanner = scannerOrString;                                                                       // 356\n  if (typeof scanner === 'string')                                                                     // 357\n    scanner = new HTMLTools.Scanner(scannerOrString);                                                  // 358\n                                                                                                       // 359\n  var startPos = scanner.pos; // for error messages                                                    // 360\n  var result = TemplateTag.parse(scannerOrString);                                                     // 361\n  if (! result)                                                                                        // 362\n    return result;                                                                                     // 363\n                                                                                                       // 364\n  if (result.type === 'BLOCKCOMMENT')                                                                  // 365\n    return null;                                                                                       // 366\n                                                                                                       // 367\n  if (result.type === 'COMMENT')                                                                       // 368\n    return null;                                                                                       // 369\n                                                                                                       // 370\n  if (result.type === 'ELSE')                                                                          // 371\n    scanner.fatal(\"Unexpected {{else}}\");                                                              // 372\n                                                                                                       // 373\n  if (result.type === 'BLOCKCLOSE')                                                                    // 374\n    scanner.fatal(\"Unexpected closing template tag\");                                                  // 375\n                                                                                                       // 376\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);                                              // 377\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)                                                      // 378\n    result.position = position;                                                                        // 379\n                                                                                                       // 380\n  if (result.type === 'BLOCKOPEN') {                                                                   // 381\n    // parse block contents                                                                            // 382\n                                                                                                       // 383\n    // Construct a string version of `.path` for comparing start and                                   // 384\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`                                // 385\n    // and now becomes `foo,0`.  This form may also show up in error                                   // 386\n    // messages.                                                                                       // 387\n    var blockName = result.path.join(',');                                                             // 388\n                                                                                                       // 389\n    var textMode = null;                                                                               // 390\n      if (blockName === 'markdown' ||                                                                  // 391\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {                                             // 392\n        textMode = HTML.TEXTMODE.STRING;                                                               // 393\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||                                       // 394\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                                    // 395\n        textMode = HTML.TEXTMODE.RCDATA;                                                               // 396\n      }                                                                                                // 397\n      var parserOptions = {                                                                            // 398\n        getTemplateTag: TemplateTag.parseCompleteTag,                                                  // 399\n        shouldStop: isAtBlockCloseOrElse,                                                              // 400\n        textMode: textMode                                                                             // 401\n      };                                                                                               // 402\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);                                  // 403\n                                                                                                       // 404\n    if (scanner.rest().slice(0, 2) !== '{{')                                                           // 405\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);                              // 406\n                                                                                                       // 407\n    var lastPos = scanner.pos; // save for error messages                                              // 408\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}                                  // 409\n                                                                                                       // 410\n    if (tmplTag.type === 'ELSE') {                                                                     // 411\n      // parse {{else}} and content up to close tag                                                    // 412\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);                            // 413\n                                                                                                       // 414\n      if (scanner.rest().slice(0, 2) !== '{{')                                                         // 415\n        scanner.fatal(\"Expected block close for \" + blockName);                                        // 416\n                                                                                                       // 417\n      lastPos = scanner.pos;                                                                           // 418\n      tmplTag = TemplateTag.parse(scanner);                                                            // 419\n    }                                                                                                  // 420\n                                                                                                       // 421\n    if (tmplTag.type === 'BLOCKCLOSE') {                                                               // 422\n      var blockName2 = tmplTag.path.join(',');                                                         // 423\n      if (blockName !== blockName2) {                                                                  // 424\n        scanner.pos = lastPos;                                                                         // 425\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +                              // 426\n                      blockName2);                                                                     // 427\n      }                                                                                                // 428\n    } else {                                                                                           // 429\n      scanner.pos = lastPos;                                                                           // 430\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +                                // 431\n                    tmplTag.type);                                                                     // 432\n    }                                                                                                  // 433\n  }                                                                                                    // 434\n                                                                                                       // 435\n  var finalPos = scanner.pos;                                                                          // 436\n  scanner.pos = startPos;                                                                              // 437\n  validateTag(result, scanner);                                                                        // 438\n  scanner.pos = finalPos;                                                                              // 439\n                                                                                                       // 440\n  return result;                                                                                       // 441\n};                                                                                                     // 442\n                                                                                                       // 443\nvar isAtBlockCloseOrElse = function (scanner) {                                                        // 444\n  // Detect `{{else}}` or `{{/foo}}`.                                                                  // 445\n  //                                                                                                   // 446\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,                              // 447\n  // for efficiency (we're called for every input token) and to be                                     // 448\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it                              // 449\n  // sees `{{` followed by a malformed tag.                                                            // 450\n  var rest, type;                                                                                      // 451\n  return (scanner.peek() === '{' &&                                                                    // 452\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&                                              // 453\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&                                                          // 454\n          (type = TemplateTag.peek(scanner).type) &&                                                   // 455\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));                                                 // 456\n};                                                                                                     // 457\n                                                                                                       // 458\n// Validate that `templateTag` is correctly formed and legal for its                                   // 459\n// HTML position.  Use `scanner` to report errors. On success, does                                    // 460\n// nothing.                                                                                            // 461\nvar validateTag = function (ttag, scanner) {                                                           // 462\n                                                                                                       // 463\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {                                        // 464\n    var args = ttag.args;                                                                              // 465\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&                                 // 466\n        args[1][1][0] === 'in') {                                                                      // 467\n      // For slightly better error messages, we detect the each-in case                                // 468\n      // here in order not to complain if the user writes `{{#each 3 in x}}`                           // 469\n      // that \"3 is not a function\"                                                                    // 470\n    } else {                                                                                           // 471\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {                          // 472\n        // we have a positional argument that is not a PATH followed by                                // 473\n        // other arguments                                                                             // 474\n        scanner.fatal(\"First argument must be a function, to be called on \" +                          // 475\n                      \"the rest of the arguments; found \" + args[0][0]);                               // 476\n      }                                                                                                // 477\n    }                                                                                                  // 478\n  }                                                                                                    // 479\n                                                                                                       // 480\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;                                       // 481\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                                               // 482\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {                                            // 483\n      return;                                                                                          // 484\n    } else if (ttag.type === 'BLOCKOPEN') {                                                            // 485\n      var path = ttag.path;                                                                            // 486\n      var path0 = path[0];                                                                             // 487\n      if (! (path.length === 1 && (path0 === 'if' ||                                                   // 488\n                                   path0 === 'unless' ||                                               // 489\n                                   path0 === 'with' ||                                                 // 490\n                                   path0 === 'each'))) {                                               // 491\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }                                                                                                // 493\n    } else {                                                                                           // 494\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");                  // 495\n    }                                                                                                  // 496\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {                                        // 497\n    if (! (ttag.type === 'DOUBLE')) {                                                                  // 498\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }                                                                                                  // 500\n    if (scanner.peek() === '=') {                                                                      // 501\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }                                                                                                  // 503\n  }                                                                                                    // 504\n                                                                                                       // 505\n};                                                                                                     // 506\n                                                                                                       // 507\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/optimizer.js                                                            //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't                              // 1\n// contain template tags.                                                                              // 2\n                                                                                                       // 3\nvar constant = function (value) {                                                                      // 4\n  return function () { return value; };                                                                // 5\n};                                                                                                     // 6\n                                                                                                       // 7\nvar OPTIMIZABLE = {                                                                                    // 8\n  NONE: 0,                                                                                             // 9\n  PARTS: 1,                                                                                            // 10\n  FULL: 2                                                                                              // 11\n};                                                                                                     // 12\n                                                                                                       // 13\n// We can only turn content into an HTML string if it contains no template                             // 14\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content                              // 15\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an                                  // 16\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree                             // 17\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.                         // 18\n//                                                                                                     // 19\n// For example, we always create SVG elements programmatically, since SVG                              // 20\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.                            // 21\n// However, if we are given a big tree that contains SVG somewhere, we                                 // 22\n// return PARTS so that the optimizer can descend into the tree and optimize                           // 23\n// other parts of it.                                                                                  // 24\nvar CanOptimizeVisitor = HTML.Visitor.extend();                                                        // 25\nCanOptimizeVisitor.def({                                                                               // 26\n  visitNull: constant(OPTIMIZABLE.FULL),                                                               // 27\n  visitPrimitive: constant(OPTIMIZABLE.FULL),                                                          // 28\n  visitComment: constant(OPTIMIZABLE.FULL),                                                            // 29\n  visitCharRef: constant(OPTIMIZABLE.FULL),                                                            // 30\n  visitRaw: constant(OPTIMIZABLE.FULL),                                                                // 31\n  visitObject: constant(OPTIMIZABLE.NONE),                                                             // 32\n  visitFunction: constant(OPTIMIZABLE.NONE),                                                           // 33\n  visitArray: function (x) {                                                                           // 34\n    for (var i = 0; i < x.length; i++)                                                                 // 35\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)                                                       // 36\n        return OPTIMIZABLE.PARTS;                                                                      // 37\n    return OPTIMIZABLE.FULL;                                                                           // 38\n  },                                                                                                   // 39\n  visitTag: function (tag) {                                                                           // 40\n    var tagName = tag.tagName;                                                                         // 41\n    if (tagName === 'textarea') {                                                                      // 42\n      // optimizing into a TEXTAREA's RCDATA would require being a little                              // 43\n      // more clever.                                                                                  // 44\n      return OPTIMIZABLE.NONE;                                                                         // 45\n    } else if (tagName === 'script') {                                                                 // 46\n      // script tags don't work when rendered from strings                                             // 47\n      return OPTIMIZABLE.NONE;                                                                         // 48\n    } else if (! (HTML.isKnownElement(tagName) &&                                                      // 49\n                  ! HTML.isKnownSVGElement(tagName))) {                                                // 50\n      // foreign elements like SVG can't be stringified for innerHTML.                                 // 51\n      return OPTIMIZABLE.NONE;                                                                         // 52\n    } else if (tagName === 'table') {                                                                  // 53\n      // Avoid ever producing HTML containing `<table><tr>...`, because the                            // 54\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and                         // 55\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary                               // 56\n      // (assuming IE 8+).                                                                             // 57\n      return OPTIMIZABLE.NONE;                                                                         // 58\n    }                                                                                                  // 59\n                                                                                                       // 60\n    var children = tag.children;                                                                       // 61\n    for (var i = 0; i < children.length; i++)                                                          // 62\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)                                                // 63\n        return OPTIMIZABLE.PARTS;                                                                      // 64\n                                                                                                       // 65\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)                                          // 66\n      return OPTIMIZABLE.PARTS;                                                                        // 67\n                                                                                                       // 68\n    return OPTIMIZABLE.FULL;                                                                           // 69\n  },                                                                                                   // 70\n  visitAttributes: function (attrs) {                                                                  // 71\n    if (attrs) {                                                                                       // 72\n      var isArray = HTML.isArray(attrs);                                                               // 73\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {                                         // 74\n        var a = (isArray ? attrs[i] : attrs);                                                          // 75\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))                           // 76\n          return OPTIMIZABLE.PARTS;                                                                    // 77\n        for (var k in a)                                                                               // 78\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)                                                   // 79\n            return OPTIMIZABLE.PARTS;                                                                  // 80\n      }                                                                                                // 81\n    }                                                                                                  // 82\n    return OPTIMIZABLE.FULL;                                                                           // 83\n  }                                                                                                    // 84\n});                                                                                                    // 85\n                                                                                                       // 86\nvar getOptimizability = function (content) {                                                           // 87\n  return (new CanOptimizeVisitor).visit(content);                                                      // 88\n};                                                                                                     // 89\n                                                                                                       // 90\nvar toRaw = function (x) {                                                                             // 91\n  return HTML.Raw(HTML.toHTML(x));                                                                     // 92\n};                                                                                                     // 93\n                                                                                                       // 94\nvar TreeTransformer = HTML.TransformingVisitor.extend();                                               // 95\nTreeTransformer.def({                                                                                  // 96\n  visitAttributes: function (attrs/*, ...*/) {                                                         // 97\n    // pass template tags through by default                                                           // 98\n    if (attrs instanceof HTMLTools.TemplateTag)                                                        // 99\n      return attrs;                                                                                    // 100\n                                                                                                       // 101\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(                                   // 102\n      this, arguments);                                                                                // 103\n  }                                                                                                    // 104\n});                                                                                                    // 105\n                                                                                                       // 106\n// Replace parts of the HTMLjs tree that have no template tags (or                                     // 107\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.                                        // 108\nvar OptimizingVisitor = TreeTransformer.extend();                                                      // 109\nOptimizingVisitor.def({                                                                                // 110\n  visitNull: toRaw,                                                                                    // 111\n  visitPrimitive: toRaw,                                                                               // 112\n  visitComment: toRaw,                                                                                 // 113\n  visitCharRef: toRaw,                                                                                 // 114\n  visitArray: function (array) {                                                                       // 115\n    var optimizability = getOptimizability(array);                                                     // 116\n    if (optimizability === OPTIMIZABLE.FULL) {                                                         // 117\n      return toRaw(array);                                                                             // 118\n    } else if (optimizability === OPTIMIZABLE.PARTS) {                                                 // 119\n      return TreeTransformer.prototype.visitArray.call(this, array);                                   // 120\n    } else {                                                                                           // 121\n      return array;                                                                                    // 122\n    }                                                                                                  // 123\n  },                                                                                                   // 124\n  visitTag: function (tag) {                                                                           // 125\n    var optimizability = getOptimizability(tag);                                                       // 126\n    if (optimizability === OPTIMIZABLE.FULL) {                                                         // 127\n      return toRaw(tag);                                                                               // 128\n    } else if (optimizability === OPTIMIZABLE.PARTS) {                                                 // 129\n      return TreeTransformer.prototype.visitTag.call(this, tag);                                       // 130\n    } else {                                                                                           // 131\n      return tag;                                                                                      // 132\n    }                                                                                                  // 133\n  },                                                                                                   // 134\n  visitChildren: function (children) {                                                                 // 135\n    // don't optimize the children array into a Raw object!                                            // 136\n    return TreeTransformer.prototype.visitArray.call(this, children);                                  // 137\n  },                                                                                                   // 138\n  visitAttributes: function (attrs) {                                                                  // 139\n    return attrs;                                                                                      // 140\n  }                                                                                                    // 141\n});                                                                                                    // 142\n                                                                                                       // 143\n// Combine consecutive HTML.Raws.  Remove empty ones.                                                  // 144\nvar RawCompactingVisitor = TreeTransformer.extend();                                                   // 145\nRawCompactingVisitor.def({                                                                             // 146\n  visitArray: function (array) {                                                                       // 147\n    var result = [];                                                                                   // 148\n    for (var i = 0; i < array.length; i++) {                                                           // 149\n      var item = array[i];                                                                             // 150\n      if ((item instanceof HTML.Raw) &&                                                                // 151\n          ((! item.value) ||                                                                           // 152\n           (result.length &&                                                                           // 153\n            (result[result.length - 1] instanceof HTML.Raw)))) {                                       // 154\n        // two cases: item is an empty Raw, or previous item is                                        // 155\n        // a Raw as well.  In the latter case, replace the previous                                    // 156\n        // Raw with a longer one that includes the new Raw.                                            // 157\n        if (item.value) {                                                                              // 158\n          result[result.length - 1] = HTML.Raw(                                                        // 159\n            result[result.length - 1].value + item.value);                                             // 160\n        }                                                                                              // 161\n      } else {                                                                                         // 162\n        result.push(item);                                                                             // 163\n      }                                                                                                // 164\n    }                                                                                                  // 165\n    return result;                                                                                     // 166\n  }                                                                                                    // 167\n});                                                                                                    // 168\n                                                                                                       // 169\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special                               // 170\n// characters with simple strings.                                                                     // 171\nvar RawReplacingVisitor = TreeTransformer.extend();                                                    // 172\nRawReplacingVisitor.def({                                                                              // 173\n  visitRaw: function (raw) {                                                                           // 174\n    var html = raw.value;                                                                              // 175\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {                                              // 176\n      return html;                                                                                     // 177\n    } else {                                                                                           // 178\n      return raw;                                                                                      // 179\n    }                                                                                                  // 180\n  }                                                                                                    // 181\n});                                                                                                    // 182\n                                                                                                       // 183\nSpacebarsCompiler.optimize = function (tree) {                                                         // 184\n  tree = (new OptimizingVisitor).visit(tree);                                                          // 185\n  tree = (new RawCompactingVisitor).visit(tree);                                                       // 186\n  tree = (new RawReplacingVisitor).visit(tree);                                                        // 187\n  return tree;                                                                                         // 188\n};                                                                                                     // 189\n                                                                                                       // 190\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/react.js                                                                //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// A visitor to ensure that React components included via the `{{>                                     // 1\n// React}}` template defined in the react-template-helper package are                                  // 2\n// the only child in their parent component. Otherwise `React.render`                                  // 3\n// would eliminate all of their sibling nodes.                                                         // 4\n//                                                                                                     // 5\n// It's a little strange that this logic is in spacebars-compiler if                                   // 6\n// it's only relevant to a specific package but there's no way to have                                 // 7\n// a package hook into a build plugin.                                                                 // 8\nReactComponentSiblingForbidder = HTML.Visitor.extend();                                                // 9\nReactComponentSiblingForbidder.def({                                                                   // 10\n  visitArray: function (array, parentTag) {                                                            // 11\n    for (var i = 0; i < array.length; i++) {                                                           // 12\n      this.visit(array[i], parentTag);                                                                 // 13\n    }                                                                                                  // 14\n  },                                                                                                   // 15\n  visitObject: function (obj, parentTag) {                                                             // 16\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {                // 17\n      if (!parentTag) {                                                                                // 18\n        throw new Error(                                                                               // 19\n          \"{{> React}} must be used in a container element\"                                            // 20\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")                                      // 21\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }                                                                                                // 23\n                                                                                                       // 24\n      var numSiblings = 0;                                                                             // 25\n      for (var i = 0; i < parentTag.children.length; i++) {                                            // 26\n        var child = parentTag.children[i];                                                             // 27\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {                   // 28\n          numSiblings++;                                                                               // 29\n        }                                                                                              // 30\n      }                                                                                                // 31\n                                                                                                       // 32\n      if (numSiblings > 0) {                                                                           // 33\n        throw new Error(                                                                               // 34\n          \"{{> React}} must be used as the only child in a container element\"                          // 35\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")                                      // 36\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }                                                                                                // 38\n    }                                                                                                  // 39\n  },                                                                                                   // 40\n  visitTag: function (tag) {                                                                           // 41\n    this.visitArray(tag.children, tag /*parentTag*/);                                                  // 42\n  }                                                                                                    // 43\n});                                                                                                    // 44\n                                                                                                       // 45\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/codegen.js                                                              //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// ============================================================                                        // 1\n// Code-generation of template tags                                                                    // 2\n                                                                                                       // 3\n// The `CodeGen` class currently has no instance state, but in theory                                  // 4\n// it could be useful to track per-function state, like whether we                                     // 5\n// need to emit `var self = this` or not.                                                              // 6\nvar CodeGen = SpacebarsCompiler.CodeGen = function () {};                                              // 7\n                                                                                                       // 8\nvar builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {                                   // 9\n  'if': 'Blaze.If',                                                                                    // 10\n  'unless': 'Blaze.Unless',                                                                            // 11\n  'with': 'Spacebars.With',                                                                            // 12\n  'each': 'Blaze.Each',                                                                                // 13\n  'let': 'Blaze.Let'                                                                                   // 14\n};                                                                                                     // 15\n                                                                                                       // 16\n                                                                                                       // 17\n// Mapping of \"macros\" which, when preceded by `Template.`, expand                                     // 18\n// to special code rather than following the lookup rules for dotted                                   // 19\n// symbols.                                                                                            // 20\nvar builtInTemplateMacros = {                                                                          // 21\n  // `view` is a local variable defined in the generated render                                        // 22\n  // function for the template in which `Template.contentBlock` or                                     // 23\n  // `Template.elseBlock` is invoked.                                                                  // 24\n  'contentBlock': 'view.templateContentBlock',                                                         // 25\n  'elseBlock': 'view.templateElseBlock',                                                               // 26\n                                                                                                       // 27\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias                                         // 28\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that                                     // 29\n  // implements the dynamic template feature.                                                          // 30\n  'dynamic': 'Template.__dynamic',                                                                     // 31\n                                                                                                       // 32\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'                                 // 33\n};                                                                                                     // 34\n                                                                                                       // 35\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",                         // 36\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",                          // 37\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",                                      // 38\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",                                      // 39\n  \"registerHelper\", \"currentData\", \"parentData\"];                                                      // 40\n                                                                                                       // 41\n// A \"reserved name\" can't be used as a <template> name.  This                                         // 42\n// function is used by the template file scanner.                                                      // 43\n//                                                                                                     // 44\n// Note that the runtime imposes additional restrictions, for example                                  // 45\n// banning the name \"body\" and names of built-in object properties                                     // 46\n// like \"toString\".                                                                                    // 47\nSpacebarsCompiler.isReservedName = function (name) {                                                   // 48\n  return builtInBlockHelpers.hasOwnProperty(name) ||                                                   // 49\n    builtInTemplateMacros.hasOwnProperty(name) ||                                                      // 50\n    _.indexOf(additionalReservedNames, name) > -1;                                                     // 51\n};                                                                                                     // 52\n                                                                                                       // 53\nvar makeObjectLiteral = function (obj) {                                                               // 54\n  var parts = [];                                                                                      // 55\n  for (var k in obj)                                                                                   // 56\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);                                      // 57\n  return '{' + parts.join(', ') + '}';                                                                 // 58\n};                                                                                                     // 59\n                                                                                                       // 60\n_.extend(CodeGen.prototype, {                                                                          // 61\n  codeGenTemplateTag: function (tag) {                                                                 // 62\n    var self = this;                                                                                   // 63\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {                               // 64\n      // Special dynamic attributes: `<div {{attrs}}>...`                                              // 65\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)                                  // 66\n      return BlazeTools.EmitCode('function () { return ' +                                             // 67\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')                                     // 68\n          + '; }');                                                                                    // 69\n    } else {                                                                                           // 70\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {                                            // 71\n        var code = self.codeGenMustache(tag.path, tag.args);                                           // 72\n        if (tag.type === 'TRIPLE') {                                                                   // 73\n          code = 'Spacebars.makeRaw(' + code + ')';                                                    // 74\n        }                                                                                              // 75\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {                           // 76\n          // Reactive attributes are already wrapped in a function,                                    // 77\n          // and there's no fine-grained reactivity.                                                   // 78\n          // Anywhere else, we need to create a View.                                                  // 79\n          code = 'Blaze.View(' +                                                                       // 80\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +                            // 81\n            'function () { return ' + code + '; })';                                                   // 82\n        }                                                                                              // 83\n        return BlazeTools.EmitCode(code);                                                              // 84\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {                               // 85\n        var path = tag.path;                                                                           // 86\n        var args = tag.args;                                                                           // 87\n                                                                                                       // 88\n        if (tag.type === 'BLOCKOPEN' &&                                                                // 89\n            builtInBlockHelpers.hasOwnProperty(path[0])) {                                             // 90\n          // if, unless, with, each.                                                                   // 91\n          //                                                                                           // 92\n          // If someone tries to do `{{> if}}`, we don't                                               // 93\n          // get here, but an error is thrown when we try to codegen the path.                         // 94\n                                                                                                       // 95\n          // Note: If we caught these errors earlier, while scanning, we'd be able to                  // 96\n          // provide nice line numbers.                                                                // 97\n          if (path.length > 1)                                                                         // 98\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);                       // 99\n          if (! args.length)                                                                           // 100\n            throw new Error(\"#\" + path[0] + \" requires an argument\");                                  // 101\n                                                                                                       // 102\n          var dataCode = null;                                                                         // 103\n          // #each has a special treatment as it features two different forms:                         // 104\n          // - {{#each people}}                                                                        // 105\n          // - {{#each person in people}}                                                              // 106\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&                       // 107\n              args[1][1].length && args[1][1][0] === 'in') {                                           // 108\n            // minimum conditions are met for each-in.  now validate this                              // 109\n            // isn't some weird case.                                                                  // 110\n            var eachUsage = \"Use either {{#each items}} or \" +                                         // 111\n                  \"{{#each item in items}} form of #each.\";                                            // 112\n            var inArg = args[1];                                                                       // 113\n            if (! (args.length >= 3 && inArg[1].length === 1)) {                                       // 114\n              // we don't have at least 3 space-separated parts after #each, or                        // 115\n              // inArg doesn't look like ['PATH',['in']]                                               // 116\n              throw new Error(\"Malformed #each. \" + eachUsage);                                        // 117\n            }                                                                                          // 118\n            // split out the variable name and sequence arguments                                      // 119\n            var variableArg = args[0];                                                                 // 120\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&                         // 121\n                   variableArg[1][0].replace(/\\./g, ''))) {                                            // 122\n              throw new Error(\"Bad variable name in #each\");                                           // 123\n            }                                                                                          // 124\n            var variable = variableArg[1][0];                                                          // 125\n            dataCode = 'function () { return { _sequence: ' +                                          // 126\n              self.codeGenInclusionData(args.slice(2)) +                                               // 127\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';                            // 128\n          } else if (path[0] === 'let') {                                                              // 129\n            var dataProps = {};                                                                        // 130\n            _.each(args, function (arg) {                                                              // 131\n              if (arg.length !== 3) {                                                                  // 132\n                // not a keyword arg (x=y)                                                             // 133\n                throw new Error(\"Incorrect form of #let\");                                             // 134\n              }                                                                                        // 135\n              var argKey = arg[2];                                                                     // 136\n              dataProps[argKey] =                                                                      // 137\n                'function () { return Spacebars.call(' +                                               // 138\n                self.codeGenArgValue(arg) + '); }';                                                    // 139\n            });                                                                                        // 140\n            dataCode = makeObjectLiteral(dataProps);                                                   // 141\n          }                                                                                            // 142\n                                                                                                       // 143\n          if (! dataCode) {                                                                            // 144\n            // `args` must exist (tag.args.length > 0)                                                 // 145\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';                                  // 146\n          }                                                                                            // 147\n                                                                                                       // 148\n          // `content` must exist                                                                      // 149\n          var contentBlock = (('content' in tag) ?                                                     // 150\n                              self.codeGenBlock(tag.content) : null);                                  // 151\n          // `elseContent` may not exist                                                               // 152\n          var elseContentBlock = (('elseContent' in tag) ?                                             // 153\n                                  self.codeGenBlock(tag.elseContent) : null);                          // 154\n                                                                                                       // 155\n          var callArgs = [dataCode, contentBlock];                                                     // 156\n          if (elseContentBlock)                                                                        // 157\n            callArgs.push(elseContentBlock);                                                           // 158\n                                                                                                       // 159\n          return BlazeTools.EmitCode(                                                                  // 160\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');                           // 161\n                                                                                                       // 162\n        } else {                                                                                       // 163\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});                               // 164\n          if (path.length > 1) {                                                                       // 165\n            // capture reactivity                                                                      // 166\n            compCode = 'function () { return Spacebars.call(' + compCode +                             // 167\n              '); }';                                                                                  // 168\n          }                                                                                            // 169\n                                                                                                       // 170\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);                                      // 171\n          var content = (('content' in tag) ?                                                          // 172\n                         self.codeGenBlock(tag.content) : null);                                       // 173\n          var elseContent = (('elseContent' in tag) ?                                                  // 174\n                             self.codeGenBlock(tag.elseContent) : null);                               // 175\n                                                                                                       // 176\n          var includeArgs = [compCode];                                                                // 177\n          if (content) {                                                                               // 178\n            includeArgs.push(content);                                                                 // 179\n            if (elseContent)                                                                           // 180\n              includeArgs.push(elseContent);                                                           // 181\n          }                                                                                            // 182\n                                                                                                       // 183\n          var includeCode =                                                                            // 184\n                'Spacebars.include(' + includeArgs.join(', ') + ')';                                   // 185\n                                                                                                       // 186\n          // calling convention compat -- set the data context around the                              // 187\n          // entire inclusion, so that if the name of the inclusion is                                 // 188\n          // a helper function, it gets the data context in `this`.                                    // 189\n          // This makes for a pretty confusing calling convention --                                   // 190\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`                             // 191\n          // -- but it's what we shipped for 0.8.0.  The rationale is that                             // 192\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.                                   // 193\n          if (dataCode) {                                                                              // 194\n            includeCode =                                                                              // 195\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +                          // 196\n              includeCode + '; })';                                                                    // 197\n          }                                                                                            // 198\n                                                                                                       // 199\n          // XXX BACK COMPAT - UI is the old name, Template is the new                                 // 200\n          if ((path[0] === 'UI' || path[0] === 'Template') &&                                          // 201\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {                               // 202\n            // Call contentBlock and elseBlock in the appropriate scope                                // 203\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '                    // 204\n              + includeCode + '; })';                                                                  // 205\n          }                                                                                            // 206\n                                                                                                       // 207\n          return BlazeTools.EmitCode(includeCode);                                                     // 208\n        }                                                                                              // 209\n      } else if (tag.type === 'ESCAPE') {                                                              // 210\n        return tag.value;                                                                              // 211\n      } else {                                                                                         // 212\n        // Can't get here; TemplateTag validation should catch any                                     // 213\n        // inappropriate tag types that might come out of the parser.                                  // 214\n        throw new Error(\"Unexpected template tag type: \" + tag.type);                                  // 215\n      }                                                                                                // 216\n    }                                                                                                  // 217\n  },                                                                                                   // 218\n                                                                                                       // 219\n  // `path` is an array of at least one string.                                                        // 220\n  //                                                                                                   // 221\n  // If `path.length > 1`, the generated code may be reactive                                          // 222\n  // (i.e. it may invalidate the current computation).                                                 // 223\n  //                                                                                                   // 224\n  // No code is generated to call the result if it's a function.                                       // 225\n  //                                                                                                   // 226\n  // Options:                                                                                          // 227\n  //                                                                                                   // 228\n  // - lookupTemplate {Boolean} If true, generated code also looks in                                  // 229\n  //   the list of templates. (After helpers, before data context).                                    // 230\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only                                   // 231\n  //   used for non-dotted paths.                                                                      // 232\n  codeGenPath: function (path, opts) {                                                                 // 233\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))                                                   // 234\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");                                // 235\n    // Let `{{#if Template.contentBlock}}` check whether this template was                             // 236\n    // invoked via inclusion or as a block helper, in addition to supporting                           // 237\n    // `{{> Template.contentBlock}}`.                                                                  // 238\n    // XXX BACK COMPAT - UI is the old name, Template is the new                                       // 239\n    if (path.length >= 2 &&                                                                            // 240\n        (path[0] === 'UI' || path[0] === 'Template')                                                   // 241\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {                                            // 242\n      if (path.length > 2)                                                                             // 243\n        throw new Error(\"Unexpected dotted path beginning with \" +                                     // 244\n                        path[0] + '.' + path[1]);                                                      // 245\n      return builtInTemplateMacros[path[1]];                                                           // 246\n    }                                                                                                  // 247\n                                                                                                       // 248\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);                                               // 249\n    var lookupMethod = 'lookup';                                                                       // 250\n    if (opts && opts.lookupTemplate && path.length === 1)                                              // 251\n      lookupMethod = 'lookupTemplate';                                                                 // 252\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';                                     // 253\n                                                                                                       // 254\n    if (path.length > 1) {                                                                             // 255\n      code = 'Spacebars.dot(' + code + ', ' +                                                          // 256\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';                                 // 257\n    }                                                                                                  // 258\n                                                                                                       // 259\n    return code;                                                                                       // 260\n  },                                                                                                   // 261\n                                                                                                       // 262\n  // Generates code for an `[argType, argValue]` argument spec,                                        // 263\n  // ignoring the third element (keyword argument name) if present.                                    // 264\n  //                                                                                                   // 265\n  // The resulting code may be reactive (in the case of a PATH of                                      // 266\n  // more than one element) and is not wrapped in a closure.                                           // 267\n  codeGenArgValue: function (arg) {                                                                    // 268\n    var self = this;                                                                                   // 269\n                                                                                                       // 270\n    var argType = arg[0];                                                                              // 271\n    var argValue = arg[1];                                                                             // 272\n                                                                                                       // 273\n    var argCode;                                                                                       // 274\n    switch (argType) {                                                                                 // 275\n    case 'STRING':                                                                                     // 276\n    case 'NUMBER':                                                                                     // 277\n    case 'BOOLEAN':                                                                                    // 278\n    case 'NULL':                                                                                       // 279\n      argCode = BlazeTools.toJSLiteral(argValue);                                                      // 280\n      break;                                                                                           // 281\n    case 'PATH':                                                                                       // 282\n      argCode = self.codeGenPath(argValue);                                                            // 283\n      break;                                                                                           // 284\n    case 'EXPR':                                                                                       // 285\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]                  // 286\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');                    // 287\n      break;                                                                                           // 288\n    default:                                                                                           // 289\n      // can't get here                                                                                // 290\n      throw new Error(\"Unexpected arg type: \" + argType);                                              // 291\n    }                                                                                                  // 292\n                                                                                                       // 293\n    return argCode;                                                                                    // 294\n  },                                                                                                   // 295\n                                                                                                       // 296\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.                               // 297\n  // The resulting code has no function literals and must be wrapped in                                // 298\n  // one for fine-grained reactivity.                                                                  // 299\n  codeGenMustache: function (path, args, mustacheType) {                                               // 300\n    var self = this;                                                                                   // 301\n                                                                                                       // 302\n    var nameCode = self.codeGenPath(path);                                                             // 303\n    var argCode = self.codeGenMustacheArgs(args);                                                      // 304\n    var mustache = (mustacheType || 'mustache');                                                       // 305\n                                                                                                       // 306\n    return 'Spacebars.' + mustache + '(' + nameCode +                                                  // 307\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';                                                // 308\n  },                                                                                                   // 309\n                                                                                                       // 310\n  // returns: array of source strings, or null if no                                                   // 311\n  // args at all.                                                                                      // 312\n  codeGenMustacheArgs: function (tagArgs) {                                                            // 313\n    var self = this;                                                                                   // 314\n                                                                                                       // 315\n    var kwArgs = null; // source -> source                                                             // 316\n    var args = null; // [source]                                                                       // 317\n                                                                                                       // 318\n    // tagArgs may be null                                                                             // 319\n    _.each(tagArgs, function (arg) {                                                                   // 320\n      var argCode = self.codeGenArgValue(arg);                                                         // 321\n                                                                                                       // 322\n      if (arg.length > 2) {                                                                            // 323\n        // keyword argument (represented as [type, value, name])                                       // 324\n        kwArgs = (kwArgs || {});                                                                       // 325\n        kwArgs[arg[2]] = argCode;                                                                      // 326\n      } else {                                                                                         // 327\n        // positional argument                                                                         // 328\n        args = (args || []);                                                                           // 329\n        args.push(argCode);                                                                            // 330\n      }                                                                                                // 331\n    });                                                                                                // 332\n                                                                                                       // 333\n    // put kwArgs in options dictionary at end of args                                                 // 334\n    if (kwArgs) {                                                                                      // 335\n      args = (args || []);                                                                             // 336\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');                                    // 337\n    }                                                                                                  // 338\n                                                                                                       // 339\n    return args;                                                                                       // 340\n  },                                                                                                   // 341\n                                                                                                       // 342\n  codeGenBlock: function (content) {                                                                   // 343\n    return SpacebarsCompiler.codeGen(content);                                                         // 344\n  },                                                                                                   // 345\n                                                                                                       // 346\n  codeGenInclusionData: function (args) {                                                              // 347\n    var self = this;                                                                                   // 348\n                                                                                                       // 349\n    if (! args.length) {                                                                               // 350\n      // e.g. `{{#foo}}`                                                                               // 351\n      return null;                                                                                     // 352\n    } else if (args[0].length === 3) {                                                                 // 353\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`                                            // 354\n      var dataProps = {};                                                                              // 355\n      _.each(args, function (arg) {                                                                    // 356\n        var argKey = arg[2];                                                                           // 357\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';                       // 358\n      });                                                                                              // 359\n      return makeObjectLiteral(dataProps);                                                             // 360\n    } else if (args[0][0] !== 'PATH') {                                                                // 361\n      // literal first argument, e.g. `{{> foo \"blah\"}}`                                               // 362\n      //                                                                                               // 363\n      // tag validation has confirmed, in this case, that there is only                                // 364\n      // one argument (`args.length === 1`)                                                            // 365\n      return self.codeGenArgValue(args[0]);                                                            // 366\n    } else if (args.length === 1) {                                                                    // 367\n      // one argument, must be a PATH                                                                  // 368\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';                                   // 369\n    } else {                                                                                           // 370\n      // Multiple positional arguments; treat them as a nested                                         // 371\n      // \"data mustache\"                                                                               // 372\n      return self.codeGenMustache(args[0][1], args.slice(1),                                           // 373\n                                  'dataMustache');                                                     // 374\n    }                                                                                                  // 375\n                                                                                                       // 376\n  },                                                                                                   // 377\n                                                                                                       // 378\n  codeGenInclusionDataFunc: function (args) {                                                          // 379\n    var self = this;                                                                                   // 380\n    var dataCode = self.codeGenInclusionData(args);                                                    // 381\n    if (dataCode) {                                                                                    // 382\n      return 'function () { return ' + dataCode + '; }';                                               // 383\n    } else {                                                                                           // 384\n      return null;                                                                                     // 385\n    }                                                                                                  // 386\n  }                                                                                                    // 387\n                                                                                                       // 388\n});                                                                                                    // 389\n                                                                                                       // 390\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/compiler.js                                                             //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n                                                                                                       // 1\nSpacebarsCompiler.parse = function (input) {                                                           // 2\n                                                                                                       // 3\n  var tree = HTMLTools.parseFragment(                                                                  // 4\n    input,                                                                                             // 5\n    { getTemplateTag: TemplateTag.parseCompleteTag });                                                 // 6\n                                                                                                       // 7\n  return tree;                                                                                         // 8\n};                                                                                                     // 9\n                                                                                                       // 10\nSpacebarsCompiler.compile = function (input, options) {                                                // 11\n  var tree = SpacebarsCompiler.parse(input);                                                           // 12\n  return SpacebarsCompiler.codeGen(tree, options);                                                     // 13\n};                                                                                                     // 14\n                                                                                                       // 15\nSpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();                            // 16\nSpacebarsCompiler._TemplateTagReplacer.def({                                                           // 17\n  visitObject: function (x) {                                                                          // 18\n    if (x instanceof HTMLTools.TemplateTag) {                                                          // 19\n                                                                                                       // 20\n      // Make sure all TemplateTags in attributes have the right                                       // 21\n      // `.position` set on them.  This is a bit of a hack                                             // 22\n      // (we shouldn't be mutating that here), but it allows                                           // 23\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's                                     // 24\n      // \"value\", where the template tags were originally not                                          // 25\n      // in an attribute.                                                                              // 26\n      if (this.inAttributeValue)                                                                       // 27\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;                                     // 28\n                                                                                                       // 29\n      return this.codegen.codeGenTemplateTag(x);                                                       // 30\n    }                                                                                                  // 31\n                                                                                                       // 32\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);                               // 33\n  },                                                                                                   // 34\n  visitAttributes: function (attrs) {                                                                  // 35\n    if (attrs instanceof HTMLTools.TemplateTag)                                                        // 36\n      return this.codegen.codeGenTemplateTag(attrs);                                                   // 37\n                                                                                                       // 38\n    // call super (e.g. for case where `attrs` is an array)                                            // 39\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);                       // 40\n  },                                                                                                   // 41\n  visitAttribute: function (name, value, tag) {                                                        // 42\n    this.inAttributeValue = true;                                                                      // 43\n    var result = this.visit(value);                                                                    // 44\n    this.inAttributeValue = false;                                                                     // 45\n                                                                                                       // 46\n    if (result !== value) {                                                                            // 47\n      // some template tags must have been replaced, because otherwise                                 // 48\n      // we try to keep things `===` when transforming.  Wrap the code                                 // 49\n      // in a function as per the rules.  You can't have                                               // 50\n      // `{id: Blaze.View(...)}` as an attributes dict because the View                                // 51\n      // would be rendered more than once; you need to wrap it in a function                           // 52\n      // so that it's a different View each time.                                                      // 53\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));                                   // 54\n    }                                                                                                  // 55\n    return result;                                                                                     // 56\n  }                                                                                                    // 57\n});                                                                                                    // 58\n                                                                                                       // 59\nSpacebarsCompiler.codeGen = function (parseTree, options) {                                            // 60\n  // is this a template, rather than a block passed to                                                 // 61\n  // a block helper, say                                                                               // 62\n  var isTemplate = (options && options.isTemplate);                                                    // 63\n  var isBody = (options && options.isBody);                                                            // 64\n  var sourceName = (options && options.sourceName);                                                    // 65\n                                                                                                       // 66\n  var tree = parseTree;                                                                                // 67\n                                                                                                       // 68\n  // The flags `isTemplate` and `isBody` are kind of a hack.                                           // 69\n  if (isTemplate || isBody) {                                                                          // 70\n    // optimizing fragments would require being smarter about whether we are                           // 71\n    // in a TEXTAREA, say.                                                                             // 72\n    tree = SpacebarsCompiler.optimize(tree);                                                           // 73\n  }                                                                                                    // 74\n                                                                                                       // 75\n  // throws an error if using `{{> React}}` with siblings                                              // 76\n  new ReactComponentSiblingForbidder({sourceName: sourceName})                                         // 77\n    .visit(tree);                                                                                      // 78\n                                                                                                       // 79\n  var codegen = new SpacebarsCompiler.CodeGen;                                                         // 80\n  tree = (new SpacebarsCompiler._TemplateTagReplacer(                                                  // 81\n    {codegen: codegen})).visit(tree);                                                                  // 82\n                                                                                                       // 83\n  var code = '(function () { ';                                                                        // 84\n  if (isTemplate || isBody) {                                                                          // 85\n    code += 'var view = this; ';                                                                       // 86\n  }                                                                                                    // 87\n  code += 'return ';                                                                                   // 88\n  code += BlazeTools.toJS(tree);                                                                       // 89\n  code += '; })';                                                                                      // 90\n                                                                                                       // 91\n  code = SpacebarsCompiler._beautify(code);                                                            // 92\n                                                                                                       // 93\n  return code;                                                                                         // 94\n};                                                                                                     // 95\n                                                                                                       // 96\nSpacebarsCompiler._beautify = function (code) {                                                        // 97\n  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {                                         // 98\n    var result = Package.minifiers.UglifyJSMinify(                                                     // 99\n      code,                                                                                            // 100\n      { fromString: true,                                                                              // 101\n        mangle: false,                                                                                 // 102\n        compress: false,                                                                               // 103\n        output: { beautify: true,                                                                      // 104\n                  indent_level: 2,                                                                     // 105\n                  width: 80 } });                                                                      // 106\n    var output = result.code;                                                                          // 107\n    // Uglify interprets our expression as a statement and may add a semicolon.                        // 108\n    // Strip trailing semicolon.                                                                       // 109\n    output = output.replace(/;$/, '');                                                                 // 110\n    return output;                                                                                     // 111\n  } else {                                                                                             // 112\n    // don't actually beautify; no UglifyJS                                                            // 113\n    return code;                                                                                       // 114\n  }                                                                                                    // 115\n};                                                                                                     // 116\n                                                                                                       // 117\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}