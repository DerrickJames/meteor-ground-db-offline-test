{"version":3,"sources":["meteor://ðŸ’»app/packages/dispatch_kernel/packages/dispatch_kernel.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+G","file":"/packages/dispatch_kernel.js","sourcesContent":["(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/dispatch:kernel/kernel.js                                                             //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\n////////////////////////////////////////////////////////////////////////////////                  // 1\n// Kernel RaiX 2014                                                                               // 2\n////////////////////////////////////////////////////////////////////////////////                  // 3\n                                                                                                  // 4\n// Timed functions                                                                                // 5\nvar timedFunctions = [];                                                                          // 6\n                                                                                                  // 7\n// General render engine                                                                          // 8\nvar renderFunctions = [];                                                                         // 9\n                                                                                                  // 10\n// Functions that will be run when theres time for it                                             // 11\nvar deferedFunctions = [];                                                                        // 12\n                                                                                                  // 13\n// Render loop global                                                                             // 14\nKernel = {};                                                                                      // 15\n                                                                                                  // 16\n// Max length of defered buffer                                                                   // 17\nKernel.maxDeferedLength = 100;                                                                    // 18\n                                                                                                  // 19\n// Debug flag                                                                                     // 20\nKernel.debug = false;                                                                             // 21\n                                                                                                  // 22\n// DOMHighResTimeStamp - High resolution timestamp polyfil                                        // 23\nvar Time = (window.performance && window.performance.now) ?                                       // 24\n        window.performance : Date;                                                                // 25\n                                                                                                  // 26\n/**                                                                                               // 27\n * Return the current timestamp in high resolution                                                // 28\n * @return {Number}                                                                               // 29\n */                                                                                               // 30\nKernel.now = function() {                                                                         // 31\n  return Time.now();                                                                              // 32\n};                                                                                                // 33\n                                                                                                  // 34\n/**                                                                                               // 35\n * Run render function                                                                            // 36\n * @param  {function}   Function to run in frame                                                  // 37\n * @return {Kernel}                                                                               // 38\n */                                                                                               // 39\nKernel.onRender = function onRender(f) {                                                          // 40\n  renderFunctions.push(f);                                                                        // 41\n  return Kernel;                                                                                  // 42\n};                                                                                                // 43\n                                                                                                  // 44\n/**                                                                                               // 45\n * Run function when theres time for it in the render loop                                        // 46\n * @param  {function}   Function to run in frame when time permits it                             // 47\n * @return {Kernel}                                                                               // 48\n */                                                                                               // 49\nKernel.defer = function defer(f) {                                                                // 50\n  deferedFunctions.push(f);                                                                       // 51\n  return Kernel;                                                                                  // 52\n};                                                                                                // 53\n                                                                                                  // 54\n/**                                                                                               // 55\n * Run a function at a fixed timestamp                                                            // 56\n * @param  {function}                                                                             // 57\n * @param  {Number}                                                                               // 58\n * @return {Kernel}                                                                               // 59\n */                                                                                               // 60\nKernel.timed = function timed(f, runAt) {                                                         // 61\n  timedFunctions.push({                                                                           // 62\n    f: f,                                                                                         // 63\n    runAt: runAt                                                                                  // 64\n  });                                                                                             // 65\n  return Kernel;                                                                                  // 66\n};                                                                                                // 67\n                                                                                                  // 68\nvar _nextTimerReferenceId = 0;                                                                    // 69\nvar _timerRunning = {};                                                                           // 70\n                                                                                                  // 71\nvar _initTimer = function() {                                                                     // 72\n  // Get id                                                                                       // 73\n  var id = _nextTimerReferenceId++;                                                               // 74\n  // Set the timer to run                                                                         // 75\n  _timerRunning[id] = true;                                                                       // 76\n  // Return id                                                                                    // 77\n  return id;                                                                                      // 78\n};                                                                                                // 79\n                                                                                                  // 80\n/**                                                                                               // 81\n * Kernel.setTimeout                                                                              // 82\n * @param {Function}                                                                              // 83\n * @param {delay}                                                                                 // 84\n */                                                                                               // 85\nKernel.setTimeout = function(f, delay) {                                                          // 86\n  // Initialize timer reference                                                                   // 87\n  var id = _initTimer();                                                                          // 88\n                                                                                                  // 89\n  Kernel.timed(function() {                                                                       // 90\n    if (_timerRunning[id]) {                                                                      // 91\n      // Run the function                                                                         // 92\n      f();                                                                                        // 93\n    }                                                                                             // 94\n  }, Kernel.now() + delay);                                                                       // 95\n                                                                                                  // 96\n  // Return clear id                                                                              // 97\n  return id;                                                                                      // 98\n};                                                                                                // 99\n                                                                                                  // 100\nKernel.setInterval = function(f, interval) {                                                      // 101\n  // Initialize timer reference                                                                   // 102\n  var id = _initTimer();                                                                          // 103\n                                                                                                  // 104\n  // Calc the next run                                                                            // 105\n  var nextRun = Kernel.now() + interval;                                                          // 106\n                                                                                                  // 107\n  // The interval function                                                                        // 108\n  var intervalFunction = function intervalFunction() {                                            // 109\n    if (_timerRunning[id]) {                                                                      // 110\n      // Calc the next run                                                                        // 111\n      nextRun += interval;                                                                        // 112\n      // Add the next run to the queue                                                            // 113\n      Kernel.timed(intervalFunction, nextRun);                                                    // 114\n      // Run the function                                                                         // 115\n      f();                                                                                        // 116\n    }                                                                                             // 117\n  };                                                                                              // 118\n                                                                                                  // 119\n  // Initial run                                                                                  // 120\n  Kernel.timed(intervalFunction, nextRun);                                                        // 121\n                                                                                                  // 122\n  // Return clear id                                                                              // 123\n  return id;                                                                                      // 124\n};                                                                                                // 125\n                                                                                                  // 126\nKernel.clearTimeout = function clearTimer(id) {                                                   // 127\n  // Remove the timeout                                                                           // 128\n  delete _timerRunning[id];                                                                       // 129\n};                                                                                                // 130\n                                                                                                  // 131\nKernel.clearInterval = Kernel.clearTimeout;                                                       // 132\n                                                                                                  // 133\nKernel.debounce = function(func, wait, immediate) {                                               // 134\n  var timeout, args, context, timestamp, result;                                                  // 135\n  return function() {                                                                             // 136\n    context = this;                                                                               // 137\n    args = arguments;                                                                             // 138\n    timestamp = new Date();                                                                       // 139\n    var later = function() {                                                                      // 140\n      var last = (new Date()) - timestamp;                                                        // 141\n      if (last < wait) {                                                                          // 142\n        timeout = Kernel.setTimeout(later, wait - last);                                          // 143\n      } else {                                                                                    // 144\n        timeout = null;                                                                           // 145\n        if (!immediate) result = func.apply(context, args);                                       // 146\n      }                                                                                           // 147\n    };                                                                                            // 148\n    var callNow = immediate && !timeout;                                                          // 149\n    if (!timeout) {                                                                               // 150\n      timeout = Kernel.setTimeout(later, wait);                                                   // 151\n    }                                                                                             // 152\n    if (callNow) result = func.apply(context, args);                                              // 153\n    return result;                                                                                // 154\n  };                                                                                              // 155\n};                                                                                                // 156\n                                                                                                  // 157\nKernel.throttle = function(func, wait, options) {                                                 // 158\n  var context, args, result;                                                                      // 159\n  var timeout = null;                                                                             // 160\n  var previous = 0;                                                                               // 161\n  options = options || {};                                                                        // 162\n  var later = function () {                                                                       // 163\n    previous = options.leading === false ? 0 : new Date();                                        // 164\n    timeout = null;                                                                               // 165\n    result = func.apply(context, args);                                                           // 166\n  };                                                                                              // 167\n  return function () {                                                                            // 168\n    var now = new Date();                                                                         // 169\n    if (!previous && options.leading === false) previous = now;                                   // 170\n    var remaining = wait - (now - previous);                                                      // 171\n    context = this;                                                                               // 172\n    args = arguments;                                                                             // 173\n    if (remaining <= 0) {                                                                         // 174\n      Kernel.clearTimeout(timeout);                                                               // 175\n      timeout = null;                                                                             // 176\n      previous = now;                                                                             // 177\n      result = func.apply(context, args);                                                         // 178\n    } else if (!timeout && options.trailing !== false) {                                          // 179\n      timeout = Kernel.setTimeout(later, remaining);                                              // 180\n    }                                                                                             // 181\n    return result;                                                                                // 182\n  };                                                                                              // 183\n};                                                                                                // 184\n                                                                                                  // 185\n/**                                                                                               // 186\n * Create alias function for defer                                                                // 187\n * @type {[type]}                                                                                 // 188\n */                                                                                               // 189\nKernel.then = Kernel.defer;                                                                       // 190\n                                                                                                  // 191\n/**                                                                                               // 192\n * Create alias for onRender as run                                                               // 193\n * @type {[type]}                                                                                 // 194\n */                                                                                               // 195\nKernel.run = Kernel.onRender;                                                                     // 196\n                                                                                                  // 197\nKernel.each = function KernelEach(items, f) {                                                     // 198\n  // XXX: for now depend on underscore                                                            // 199\n  _.each(items, function KernelEach_Item(item, key) {                                             // 200\n    // Let render loop run this when theres time                                                  // 201\n    Kernel.defer(function KernelEachItem() {                                                      // 202\n      // Run the function                                                                         // 203\n      f(item, key);                                                                               // 204\n    });                                                                                           // 205\n  });                                                                                             // 206\n                                                                                                  // 207\n  return Kernel;                                                                                  // 208\n};                                                                                                // 209\n                                                                                                  // 210\n/**                                                                                               // 211\n * Autorun when the                                                                               // 212\n * @param f The function to autorun.                                                              // 213\n * @param [options]                                                                               // 214\n * [options.debounce] Postpone the execution until after debounce                                 // 215\n * milliseconds have elapsed since the last time it was invoked.                                  // 216\n * [options.throttle] Only call the original function at most                                     // 217\n * once per every wait milliseconds.                                                              // 218\n * @returns {Tracker.Computation}                                                                 // 219\n */                                                                                               // 220\nKernel.autorun = function(f, options) {                                                           // 221\n  var later = function(c) {                                                                       // 222\n    // Make sure not to run if computation have been stopped                                      // 223\n    if (!c.stopped) {                                                                             // 224\n      // Store current computation                                                                // 225\n      var prev = Tracker.currentComputation;                                                      // 226\n                                                                                                  // 227\n      // Set the new computation                                                                  // 228\n      Tracker.currentComputation = c;//thisComputation;                                           // 229\n      Tracker.active = !! Tracker.currentComputation;                                             // 230\n                                                                                                  // 231\n      // Call function                                                                            // 232\n      f.call(this, c);                                                                            // 233\n                                                                                                  // 234\n      // Switch back                                                                              // 235\n      Tracker.currentComputation = prev;                                                          // 236\n      Tracker.active = !! Tracker.currentComputation;                                             // 237\n                                                                                                  // 238\n    }                                                                                             // 239\n  };                                                                                              // 240\n                                                                                                  // 241\n  if (options && options.debounce) {                                                              // 242\n    later = Kernel.debounce(later, options.debounce);                                             // 243\n  }                                                                                               // 244\n  else if (options && options.throttle) {                                                         // 245\n    later = Kernel.throttle(later, options.throttle);                                             // 246\n  }                                                                                               // 247\n                                                                                                  // 248\n  return Tracker.autorun(function KernelComputation(c) {                                          // 249\n    if (c.firstRun) {                                                                             // 250\n      // Let the first run be run normally                                                        // 251\n      f.call(this, c);                                                                            // 252\n    } else {                                                                                      // 253\n      // On reruns we defer via the kernel                                                        // 254\n      Kernel.defer(function () {                                                                  // 255\n        later(c);                                                                                 // 256\n      });                                                                                         // 257\n    }                                                                                             // 258\n  });                                                                                             // 259\n};                                                                                                // 260\n                                                                                                  // 261\nBlaze.View.prototype.autorun = function(f, _inViewScope) {                                        // 262\n  var self = this;                                                                                // 263\n                                                                                                  // 264\n  // Lets just have the Blaze autorun defered via the Kernel                                      // 265\n                                                                                                  // 266\n  // The restrictions on when View#autorun can be called are in order                             // 267\n  // to avoid bad patterns, like creating a Blaze.View and immediately                            // 268\n  // calling autorun on it.  A freshly created View is not ready to                               // 269\n  // have logic run on it; it doesn't have a parentView, for example.                             // 270\n  // It's when the View is materialized or expanded that the onViewCreated                        // 271\n  // handlers are fired and the View starts up.                                                   // 272\n  //                                                                                              // 273\n  // Letting the render() method call `this.autorun()` is problematic                             // 274\n  // because of re-render.  The best we can do is to stop the old                                 // 275\n  // autorun and start a new one for each render, but that's a pattern                            // 276\n  // we try to avoid internally because it leads to helpers being                                 // 277\n  // called extra times, in the case where the autorun causes the                                 // 278\n  // view to re-render (and thus the autorun to be torn down and a                                // 279\n  // new one established).                                                                        // 280\n  //                                                                                              // 281\n  // We could lift these restrictions in various ways.  One interesting                           // 282\n  // idea is to allow you to call `view.autorun` after instantiating                              // 283\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring                         // 284\n  // the autorun so that it starts at an appropriate time.  However,                              // 285\n  // then we can't return the Computation object to the caller, because                           // 286\n  // it doesn't exist yet.                                                                        // 287\n  if (! self.isCreated) {                                                                         // 288\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");     // 289\n  }                                                                                               // 290\n  if (this._isInRender) {                                                                         // 291\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }                                                                                               // 293\n  if (Tracker.active) {                                                                           // 294\n    throw new Error(\"Can't call View#autorun from a Tracker Computation; try calling it from the created or rendered callback\");\n  }                                                                                               // 296\n                                                                                                  // 297\n  var c = Kernel.autorun(function viewAutorun(c) {                                                // 298\n                                                                                                  // 299\n    Blaze._withCurrentView(_inViewScope || self, function () {                                    // 300\n      return f.call(self, c);                                                                     // 301\n    });                                                                                           // 302\n                                                                                                  // 303\n  });                                                                                             // 304\n                                                                                                  // 305\n  self.onViewDestroyed(function () { c.stop(); });                                                // 306\n                                                                                                  // 307\n  return c;                                                                                       // 308\n                                                                                                  // 309\n};                                                                                                // 310\n                                                                                                  // 311\n                                                                                                  // 312\n/**                                                                                               // 313\n * The frame rate limit is set matching 60 fps 1000/60                                            // 314\n * @type {Number}                                                                                 // 315\n */                                                                                               // 316\nKernel.frameRateLimit = 0; // 1000 / 60;                                                          // 317\n                                                                                                  // 318\nKernel.deferedTimeLimit = 10; // ms                                                               // 319\n                                                                                                  // 320\nKernel.currentFrame = 0;                                                                          // 321\n                                                                                                  // 322\nvar lastTimeStamp = null;                                                                         // 323\n                                                                                                  // 324\nKernel.loop = function renderLoop() {                                                             // 325\n  // Get timestamp                                                                                // 326\n  var timestamp = Kernel.now();                                                                   // 327\n                                                                                                  // 328\n  // Request animation frame at the beginning trying to maintain 60fps                            // 329\n  window.requestAnimationFrame(Kernel.loop);                                                      // 330\n                                                                                                  // 331\n  // Set initial value                                                                            // 332\n  if (!lastTimeStamp) lastTimeStamp = timestamp;                                                  // 333\n                                                                                                  // 334\n  // Limit the cpu/gpu load constraint ourself to the frameRateLimit                              // 335\n  if (Kernel.frameRateLimit && Kernel.frameRateLimit > timestamp - lastTimeStamp) return;         // 336\n                                                                                                  // 337\n  // Increase the frame counter                                                                   // 338\n  Kernel.currentFrame++;                                                                          // 339\n                                                                                                  // 340\n  // Set current timed functions                                                                  // 341\n  var currentTimedFunctions = timedFunctions;                                                     // 342\n                                                                                                  // 343\n  // Reset timedFunctions                                                                         // 344\n  timedFunctions = [];                                                                            // 345\n                                                                                                  // 346\n  for (var i = 0; i < currentTimedFunctions.length; i++) {                                        // 347\n    var timedFunction = currentTimedFunctions[i];                                                 // 348\n                                                                                                  // 349\n    if (timedFunction.runAt > timestamp) {                                                        // 350\n      // not ready yet, maybe next tick                                                           // 351\n      timedFunctions.push(timedFunction);                                                         // 352\n    } else {                                                                                      // 353\n      // Ready...                                                                                 // 354\n      timedFunction.f(timedFunction.runAt, timestamp, lastTimeStamp, Kernel.currentFrame);        // 355\n    }                                                                                             // 356\n  }                                                                                               // 357\n                                                                                                  // 358\n  // Run all render functions                                                                     // 359\n  var renderLength = renderFunctions.length;                                                      // 360\n                                                                                                  // 361\n  while (renderLength--) {                                                                        // 362\n    // Run normal function in frame                                                               // 363\n    (renderFunctions.shift())(timestamp, lastTimeStamp, Kernel.currentFrame);                     // 364\n  }                                                                                               // 365\n                                                                                                  // 366\n  // Flags for limiting verbosity                                                                 // 367\n  var displayForcedDeferedCount = true;                                                           // 368\n  var displayDeferedCount = true;                                                                 // 369\n                                                                                                  // 370\n  // Make sure we keep the Kernel.maxDeferedLength limit                                          // 371\n  while (Kernel.maxDeferedLength >= 0 && deferedFunctions.length - Kernel.maxDeferedLength > 0) { // 372\n    // Display debug info                                                                         // 373\n    if (Kernel.debug && displayForcedDeferedCount) {                                              // 374\n      console.log('Kernel: force run of ' + (deferedFunctions.length - Kernel.maxDeferedLength) + ' defered functions');\n      displayForcedDeferedCount=false;                                                            // 376\n    }                                                                                             // 377\n                                                                                                  // 378\n    // Force defered function to run                                                              // 379\n    (deferedFunctions.shift())(timestamp, lastTimeStamp, Kernel.currentFrame);                    // 380\n  }                                                                                               // 381\n                                                                                                  // 382\n  // Run defered functions - in the defered time frame                                            // 383\n  while (deferedFunctions.length && (Kernel.now() - timestamp) < Kernel.deferedTimeLimit) {       // 384\n                                                                                                  // 385\n    // Display debug info                                                                         // 386\n    if (Kernel.debug && displayDeferedCount) {                                                    // 387\n      console.log('Kernel: current defered queue size', deferedFunctions.length);                 // 388\n      displayDeferedCount=false;                                                                  // 389\n    }                                                                                             // 390\n                                                                                                  // 391\n    // Run the defered function                                                                   // 392\n    (deferedFunctions.shift())(timestamp, lastTimeStamp, Kernel.currentFrame);                    // 393\n  }                                                                                               // 394\n                                                                                                  // 395\n  // Set last time stamp                                                                          // 396\n  lastTimeStamp = timestamp;                                                                      // 397\n};                                                                                                // 398\n                                                                                                  // 399\n                                                                                                  // 400\n// Initialize render loop                                                                         // 401\nwindow.requestAnimationFrame(Kernel.loop);                                                        // 402\n                                                                                                  // 403\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                //\n// packages/dispatch:kernel/meteor.js                                                             //\n//                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                  //\nvar withoutInvocation = function (f) {                                                            // 1\n  if (Package.ddp) {                                                                              // 2\n    var _CurrentInvocation = Package.ddp.DDP._CurrentInvocation;                                  // 3\n    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)                        // 4\n      throw new Error(\"Can't set timers inside simulations\");                                     // 5\n    return function () { _CurrentInvocation.withValue(null, f); };                                // 6\n  }                                                                                               // 7\n  else                                                                                            // 8\n    return f;                                                                                     // 9\n};                                                                                                // 10\n                                                                                                  // 11\nvar bindAndCatch = function (context, f) {                                                        // 12\n  return Meteor.bindEnvironment(withoutInvocation(f), context);                                   // 13\n};                                                                                                // 14\n                                                                                                  // 15\n_.extend(Meteor, {                                                                                // 16\n  // Meteor.setTimeout and Meteor.setInterval callbacks scheduled                                 // 17\n  // inside a server method are not part of the method invocation and                             // 18\n  // should clear out the CurrentInvocation environment variable.                                 // 19\n                                                                                                  // 20\n  /**                                                                                             // 21\n   * @memberOf Meteor                                                                             // 22\n   * @summary Call a function in the future after waiting for a specified delay.                  // 23\n   * @locus Anywhere                                                                              // 24\n   * @param {Function} func The function to run                                                   // 25\n   * @param {Number} delay Number of milliseconds to wait before calling function                 // 26\n   */                                                                                             // 27\n  setTimeout: function (f, duration) {                                                            // 28\n    return Kernel.setTimeout(bindAndCatch(\"setTimeout callback\", f), duration);                   // 29\n  },                                                                                              // 30\n                                                                                                  // 31\n  /**                                                                                             // 32\n   * @memberOf Meteor                                                                             // 33\n   * @summary Call a function repeatedly, with a time delay between calls.                        // 34\n   * @locus Anywhere                                                                              // 35\n   * @param {Function} func The function to run                                                   // 36\n   * @param {Number} delay Number of milliseconds to wait between each function call.             // 37\n   */                                                                                             // 38\n  setInterval: function (f, duration) {                                                           // 39\n    return Kernel.setInterval(bindAndCatch(\"setInterval callback\", f), duration);                 // 40\n  },                                                                                              // 41\n                                                                                                  // 42\n  /**                                                                                             // 43\n   * @memberOf Meteor                                                                             // 44\n   * @summary Cancel a repeating function call scheduled by `Meteor.setInterval`.                 // 45\n   * @locus Anywhere                                                                              // 46\n   * @param {Number} id The handle returned by `Meteor.setInterval`                               // 47\n   */                                                                                             // 48\n  clearInterval: function(x) {                                                                    // 49\n    return Kernel.clearInterval(x);                                                               // 50\n  },                                                                                              // 51\n                                                                                                  // 52\n  /**                                                                                             // 53\n   * @memberOf Meteor                                                                             // 54\n   * @summary Cancel a function call scheduled by `Meteor.setTimeout`.                            // 55\n   * @locus Anywhere                                                                              // 56\n   * @param {Number} id The handle returned by `Meteor.setTimeout`                                // 57\n   */                                                                                             // 58\n  clearTimeout: function(x) {                                                                     // 59\n    return Kernel.clearTimeout(x);                                                                // 60\n  },                                                                                              // 61\n                                                                                                  // 62\n  // XXX consider making this guarantee ordering of defer'd callbacks, like                       // 63\n  // Tracker.afterFlush or Node's nextTick (in practice). Then tests can do:                      // 64\n  //    callSomethingThatDefersSomeWork();                                                        // 65\n  //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));                          // 66\n  defer: function (f) {                                                                           // 67\n    Kernel.defer(bindAndCatch(\"defer callback\", f));                                              // 68\n  }                                                                                               // 69\n});                                                                                               // 70\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}