[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\nvar IdMap = Package['id-map'].IdMap;\nvar OrderedDict = Package['ordered-dict'].OrderedDict;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar MongoID = Package['mongo-id'].MongoID;\nvar Random = Package.random.Random;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar GeoJSON = Package['geojson-utils'].GeoJSON;\n\n/* Package-scope variables */\nvar LocalCollection, Minimongo, MinimongoTest, MinimongoError, isArray, isPlainObject, isIndexable, isOperatorObject, isNumericKey, regexpElementMatcher, equalityElementMatcher, ELEMENT_OPERATORS, makeLookupFunction, expandArraysInBranches, projectionDetails, pathsToTree, combineImportantPathsIntoProjection;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/minimongo/packages/minimongo.js                                                                           //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n(function(){                                                                                                          // 1\n                                                                                                                      // 2\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3\n//                                                                                                            //      // 4\n// packages/minimongo/minimongo.js                                                                            //      // 5\n//                                                                                                            //      // 6\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 7\n                                                                                                              //      // 8\n// XXX type checking on selectors (graceful error if malformed)                                               // 1    // 9\n                                                                                                              // 2    // 10\n// LocalCollection: a set of documents that supports queries and modifiers.                                   // 3    // 11\n                                                                                                              // 4    // 12\n// Cursor: a specification for a particular subset of documents, w/                                           // 5    // 13\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),                        // 6    // 14\n                                                                                                              // 7    // 15\n// ObserveHandle: the return value of a live query.                                                           // 8    // 16\n                                                                                                              // 9    // 17\nLocalCollection = function (name) {                                                                           // 10   // 18\n  var self = this;                                                                                            // 11   // 19\n  self.name = name;                                                                                           // 12   // 20\n  // _id -> document (also containing id)                                                                     // 13   // 21\n  self._docs = new LocalCollection._IdMap;                                                                    // 14   // 22\n                                                                                                              // 15   // 23\n  self._observeQueue = new Meteor._SynchronousQueue();                                                        // 16   // 24\n                                                                                                              // 17   // 25\n  self.next_qid = 1; // live query id generator                                                               // 18   // 26\n                                                                                                              // 19   // 27\n  // qid -> live query object. keys:                                                                          // 20   // 28\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.                                  // 21   // 29\n  //  results: array (ordered) or object (unordered) of current results                                       // 22   // 30\n  //    (aliased with self._docs!)                                                                            // 23   // 31\n  //  resultsSnapshot: snapshot of results. null if not paused.                                               // 24   // 32\n  //  cursor: Cursor object for the query.                                                                    // 25   // 33\n  //  selector, sorter, (callbacks): functions                                                                // 26   // 34\n  self.queries = {};                                                                                          // 27   // 35\n                                                                                                              // 28   // 36\n  // null if not saving originals; an IdMap from id to original document value if                             // 29   // 37\n  // saving originals. See comments before saveOriginals().                                                   // 30   // 38\n  self._savedOriginals = null;                                                                                // 31   // 39\n                                                                                                              // 32   // 40\n  // True when observers are paused and we should not send callbacks.                                         // 33   // 41\n  self.paused = false;                                                                                        // 34   // 42\n};                                                                                                            // 35   // 43\n                                                                                                              // 36   // 44\nMinimongo = {};                                                                                               // 37   // 45\n                                                                                                              // 38   // 46\n// Object exported only for unit testing.                                                                     // 39   // 47\n// Use it to export private functions to test in Tinytest.                                                    // 40   // 48\nMinimongoTest = {};                                                                                           // 41   // 49\n                                                                                                              // 42   // 50\nMinimongoError = function (message) {                                                                         // 43   // 51\n  var e = new Error(message);                                                                                 // 44   // 52\n  e.name = \"MinimongoError\";                                                                                  // 45   // 53\n  return e;                                                                                                   // 46   // 54\n};                                                                                                            // 47   // 55\n                                                                                                              // 48   // 56\n                                                                                                              // 49   // 57\n// options may include sort, skip, limit, reactive                                                            // 50   // 58\n// sort may be any of these forms:                                                                            // 51   // 59\n//     {a: 1, b: -1}                                                                                          // 52   // 60\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]                                                                          // 53   // 61\n//     [\"a\", [\"b\", \"desc\"]]                                                                                   // 54   // 62\n//   (in the first form you're beholden to key enumeration order in                                           // 55   // 63\n//   your javascript VM)                                                                                      // 56   // 64\n//                                                                                                            // 57   // 65\n// reactive: if given, and false, don't register with Tracker (default                                        // 58   // 66\n// is true)                                                                                                   // 59   // 67\n//                                                                                                            // 60   // 68\n// XXX possibly should support retrieving a subset of fields? and                                             // 61   // 69\n// have it be a hint (ignored on the client, when not copying the                                             // 62   // 70\n// doc?)                                                                                                      // 63   // 71\n//                                                                                                            // 64   // 72\n// XXX sort does not yet support subkeys ('a.b') .. fix that!                                                 // 65   // 73\n// XXX add one more sort form: \"key\"                                                                          // 66   // 74\n// XXX tests                                                                                                  // 67   // 75\nLocalCollection.prototype.find = function (selector, options) {                                               // 68   // 76\n  // default syntax for everything is to omit the selector argument.                                          // 69   // 77\n  // but if selector is explicitly passed in as false or undefined, we                                        // 70   // 78\n  // want a selector that matches nothing.                                                                    // 71   // 79\n  if (arguments.length === 0)                                                                                 // 72   // 80\n    selector = {};                                                                                            // 73   // 81\n                                                                                                              // 74   // 82\n  return new LocalCollection.Cursor(this, selector, options);                                                 // 75   // 83\n};                                                                                                            // 76   // 84\n                                                                                                              // 77   // 85\n// don't call this ctor directly.  use LocalCollection.find().                                                // 78   // 86\n                                                                                                              // 79   // 87\nLocalCollection.Cursor = function (collection, selector, options) {                                           // 80   // 88\n  var self = this;                                                                                            // 81   // 89\n  if (!options) options = {};                                                                                 // 82   // 90\n                                                                                                              // 83   // 91\n  self.collection = collection;                                                                               // 84   // 92\n  self.sorter = null;                                                                                         // 85   // 93\n  self.matcher = new Minimongo.Matcher(selector);                                                             // 86   // 94\n                                                                                                              // 87   // 95\n  if (LocalCollection._selectorIsId(selector)) {                                                              // 88   // 96\n    // stash for fast path                                                                                    // 89   // 97\n    self._selectorId = selector;                                                                              // 90   // 98\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                        // 91   // 99\n    // also do the fast path for { _id: idString }                                                            // 92   // 100\n    self._selectorId = selector._id;                                                                          // 93   // 101\n  } else {                                                                                                    // 94   // 102\n    self._selectorId = undefined;                                                                             // 95   // 103\n    if (self.matcher.hasGeoQuery() || options.sort) {                                                         // 96   // 104\n      self.sorter = new Minimongo.Sorter(options.sort || [],                                                  // 97   // 105\n                                         { matcher: self.matcher });                                          // 98   // 106\n    }                                                                                                         // 99   // 107\n  }                                                                                                           // 100  // 108\n                                                                                                              // 101  // 109\n  self.skip = options.skip;                                                                                   // 102  // 110\n  self.limit = options.limit;                                                                                 // 103  // 111\n  self.fields = options.fields;                                                                               // 104  // 112\n                                                                                                              // 105  // 113\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});                                 // 106  // 114\n                                                                                                              // 107  // 115\n  self._transform = LocalCollection.wrapTransform(options.transform);                                         // 108  // 116\n                                                                                                              // 109  // 117\n  // by default, queries register w/ Tracker when it is available.                                            // 110  // 118\n  if (typeof Tracker !== \"undefined\")                                                                         // 111  // 119\n    self.reactive = (options.reactive === undefined) ? true : options.reactive;                               // 112  // 120\n};                                                                                                            // 113  // 121\n                                                                                                              // 114  // 122\n// Since we don't actually have a \"nextObject\" interface, there's really no                                   // 115  // 123\n// reason to have a \"rewind\" interface.  All it did was make multiple calls                                   // 116  // 124\n// to fetch/map/forEach return nothing the second time.                                                       // 117  // 125\n// XXX COMPAT WITH 0.8.1                                                                                      // 118  // 126\nLocalCollection.Cursor.prototype.rewind = function () {                                                       // 119  // 127\n};                                                                                                            // 120  // 128\n                                                                                                              // 121  // 129\nLocalCollection.prototype.findOne = function (selector, options) {                                            // 122  // 130\n  if (arguments.length === 0)                                                                                 // 123  // 131\n    selector = {};                                                                                            // 124  // 132\n                                                                                                              // 125  // 133\n  // NOTE: by setting limit 1 here, we end up using very inefficient                                          // 126  // 134\n  // code that recomputes the whole query on each update. The upside is                                       // 127  // 135\n  // that when you reactively depend on a findOne you only get                                                // 128  // 136\n  // invalidated when the found object changes, not any object in the                                         // 129  // 137\n  // collection. Most findOne will be by id, which has a fast path, so                                        // 130  // 138\n  // this might not be a big deal. In most cases, invalidation causes                                         // 131  // 139\n  // the called to re-query anyway, so this should be a net performance                                       // 132  // 140\n  // improvement.                                                                                             // 133  // 141\n  options = options || {};                                                                                    // 134  // 142\n  options.limit = 1;                                                                                          // 135  // 143\n                                                                                                              // 136  // 144\n  return this.find(selector, options).fetch()[0];                                                             // 137  // 145\n};                                                                                                            // 138  // 146\n                                                                                                              // 139  // 147\n/**                                                                                                           // 140  // 148\n * @callback IterationCallback                                                                                // 141  // 149\n * @param {Object} doc                                                                                        // 142  // 150\n * @param {Number} index                                                                                      // 143  // 151\n */                                                                                                           // 144  // 152\n/**                                                                                                           // 145  // 153\n * @summary Call `callback` once for each matching document, sequentially and synchronously.                  // 146  // 154\n * @locus Anywhere                                                                                            // 147  // 155\n * @method  forEach                                                                                           // 148  // 156\n * @instance                                                                                                  // 149  // 157\n * @memberOf Mongo.Cursor                                                                                     // 150  // 158\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                      // 152  // 160\n */                                                                                                           // 153  // 161\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {                                     // 154  // 162\n  var self = this;                                                                                            // 155  // 163\n                                                                                                              // 156  // 164\n  var objects = self._getRawObjects({ordered: true});                                                         // 157  // 165\n                                                                                                              // 158  // 166\n  if (self.reactive) {                                                                                        // 159  // 167\n    self._depend({                                                                                            // 160  // 168\n      addedBefore: true,                                                                                      // 161  // 169\n      removed: true,                                                                                          // 162  // 170\n      changed: true,                                                                                          // 163  // 171\n      movedBefore: true});                                                                                    // 164  // 172\n  }                                                                                                           // 165  // 173\n                                                                                                              // 166  // 174\n  _.each(objects, function (elt, i) {                                                                         // 167  // 175\n    // This doubles as a clone operation.                                                                     // 168  // 176\n    elt = self._projectionFn(elt);                                                                            // 169  // 177\n                                                                                                              // 170  // 178\n    if (self._transform)                                                                                      // 171  // 179\n      elt = self._transform(elt);                                                                             // 172  // 180\n    callback.call(thisArg, elt, i, self);                                                                     // 173  // 181\n  });                                                                                                         // 174  // 182\n};                                                                                                            // 175  // 183\n                                                                                                              // 176  // 184\nLocalCollection.Cursor.prototype.getTransform = function () {                                                 // 177  // 185\n  return this._transform;                                                                                     // 178  // 186\n};                                                                                                            // 179  // 187\n                                                                                                              // 180  // 188\n/**                                                                                                           // 181  // 189\n * @summary Map callback over all matching documents.  Returns an Array.                                      // 182  // 190\n * @locus Anywhere                                                                                            // 183  // 191\n * @method map                                                                                                // 184  // 192\n * @instance                                                                                                  // 185  // 193\n * @memberOf Mongo.Cursor                                                                                     // 186  // 194\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                      // 188  // 196\n */                                                                                                           // 189  // 197\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {                                         // 190  // 198\n  var self = this;                                                                                            // 191  // 199\n  var res = [];                                                                                               // 192  // 200\n  self.forEach(function (doc, index) {                                                                        // 193  // 201\n    res.push(callback.call(thisArg, doc, index, self));                                                       // 194  // 202\n  });                                                                                                         // 195  // 203\n  return res;                                                                                                 // 196  // 204\n};                                                                                                            // 197  // 205\n                                                                                                              // 198  // 206\n/**                                                                                                           // 199  // 207\n * @summary Return all matching documents as an Array.                                                        // 200  // 208\n * @memberOf Mongo.Cursor                                                                                     // 201  // 209\n * @method  fetch                                                                                             // 202  // 210\n * @instance                                                                                                  // 203  // 211\n * @locus Anywhere                                                                                            // 204  // 212\n * @returns {Object[]}                                                                                        // 205  // 213\n */                                                                                                           // 206  // 214\nLocalCollection.Cursor.prototype.fetch = function () {                                                        // 207  // 215\n  var self = this;                                                                                            // 208  // 216\n  var res = [];                                                                                               // 209  // 217\n  self.forEach(function (doc) {                                                                               // 210  // 218\n    res.push(doc);                                                                                            // 211  // 219\n  });                                                                                                         // 212  // 220\n  return res;                                                                                                 // 213  // 221\n};                                                                                                            // 214  // 222\n                                                                                                              // 215  // 223\n/**                                                                                                           // 216  // 224\n * @summary Returns the number of documents that match a query.                                               // 217  // 225\n * @memberOf Mongo.Cursor                                                                                     // 218  // 226\n * @method  count                                                                                             // 219  // 227\n * @instance                                                                                                  // 220  // 228\n * @locus Anywhere                                                                                            // 221  // 229\n * @returns {Number}                                                                                          // 222  // 230\n */                                                                                                           // 223  // 231\nLocalCollection.Cursor.prototype.count = function () {                                                        // 224  // 232\n  var self = this;                                                                                            // 225  // 233\n                                                                                                              // 226  // 234\n  if (self.reactive)                                                                                          // 227  // 235\n    self._depend({added: true, removed: true},                                                                // 228  // 236\n                 true /* allow the observe to be unordered */);                                               // 229  // 237\n                                                                                                              // 230  // 238\n  return self._getRawObjects({ordered: true}).length;                                                         // 231  // 239\n};                                                                                                            // 232  // 240\n                                                                                                              // 233  // 241\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {                                            // 234  // 242\n  var self = this;                                                                                            // 235  // 243\n  if (! self.collection.name)                                                                                 // 236  // 244\n    throw new Error(\"Can't publish a cursor from a collection without a name.\");                              // 237  // 245\n  var collection = self.collection.name;                                                                      // 238  // 246\n                                                                                                              // 239  // 247\n  // XXX minimongo should not depend on mongo-livedata!                                                       // 240  // 248\n  if (! Package.mongo) {                                                                                      // 241  // 249\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");                             // 242  // 250\n  }                                                                                                           // 243  // 251\n                                                                                                              // 244  // 252\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);                                // 245  // 253\n};                                                                                                            // 246  // 254\n                                                                                                              // 247  // 255\nLocalCollection.Cursor.prototype._getCollectionName = function () {                                           // 248  // 256\n  var self = this;                                                                                            // 249  // 257\n  return self.collection.name;                                                                                // 250  // 258\n};                                                                                                            // 251  // 259\n                                                                                                              // 252  // 260\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {                                   // 253  // 261\n  if (callbacks.added && callbacks.addedBefore)                                                               // 254  // 262\n    throw new Error(\"Please specify only one of added() and addedBefore()\");                                  // 255  // 263\n  return !!(callbacks.addedBefore || callbacks.movedBefore);                                                  // 256  // 264\n};                                                                                                            // 257  // 265\n                                                                                                              // 258  // 266\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {                                          // 259  // 267\n  if (callbacks.addedAt && callbacks.added)                                                                   // 260  // 268\n    throw new Error(\"Please specify only one of added() and addedAt()\");                                      // 261  // 269\n  if (callbacks.changedAt && callbacks.changed)                                                               // 262  // 270\n    throw new Error(\"Please specify only one of changed() and changedAt()\");                                  // 263  // 271\n  if (callbacks.removed && callbacks.removedAt)                                                               // 264  // 272\n    throw new Error(\"Please specify only one of removed() and removedAt()\");                                  // 265  // 273\n                                                                                                              // 266  // 274\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt                                     // 267  // 275\n            || callbacks.removedAt);                                                                          // 268  // 276\n};                                                                                                            // 269  // 277\n                                                                                                              // 270  // 278\n// the handle that comes back from observe.                                                                   // 271  // 279\nLocalCollection.ObserveHandle = function () {};                                                               // 272  // 280\n                                                                                                              // 273  // 281\n// options to contain:                                                                                        // 274  // 282\n//  * callbacks for observe():                                                                                // 275  // 283\n//    - addedAt (document, atIndex)                                                                           // 276  // 284\n//    - added (document)                                                                                      // 277  // 285\n//    - changedAt (newDocument, oldDocument, atIndex)                                                         // 278  // 286\n//    - changed (newDocument, oldDocument)                                                                    // 279  // 287\n//    - removedAt (document, atIndex)                                                                         // 280  // 288\n//    - removed (document)                                                                                    // 281  // 289\n//    - movedTo (document, oldIndex, newIndex)                                                                // 282  // 290\n//                                                                                                            // 283  // 291\n// attributes available on returned query handle:                                                             // 284  // 292\n//  * stop(): end updates                                                                                     // 285  // 293\n//  * collection: the collection this query is querying                                                       // 286  // 294\n//                                                                                                            // 287  // 295\n// iff x is a returned query handle, (x instanceof                                                            // 288  // 296\n// LocalCollection.ObserveHandle) is true                                                                     // 289  // 297\n//                                                                                                            // 290  // 298\n// initial results delivered through added callback                                                           // 291  // 299\n// XXX maybe callbacks should take a list of objects, to expose transactions?                                 // 292  // 300\n// XXX maybe support field limiting (to limit what you're notified on)                                        // 293  // 301\n                                                                                                              // 294  // 302\n_.extend(LocalCollection.Cursor.prototype, {                                                                  // 295  // 303\n  /**                                                                                                         // 296  // 304\n   * @summary Watch a query.  Receive callbacks as the result set changes.                                    // 297  // 305\n   * @locus Anywhere                                                                                          // 298  // 306\n   * @memberOf Mongo.Cursor                                                                                   // 299  // 307\n   * @instance                                                                                                // 300  // 308\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes                      // 301  // 309\n   */                                                                                                         // 302  // 310\n  observe: function (options) {                                                                               // 303  // 311\n    var self = this;                                                                                          // 304  // 312\n    return LocalCollection._observeFromObserveChanges(self, options);                                         // 305  // 313\n  },                                                                                                          // 306  // 314\n                                                                                                              // 307  // 315\n  /**                                                                                                         // 308  // 316\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere                                                                                          // 310  // 318\n   * @memberOf Mongo.Cursor                                                                                   // 311  // 319\n   * @instance                                                                                                // 312  // 320\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes                      // 313  // 321\n   */                                                                                                         // 314  // 322\n  observeChanges: function (options) {                                                                        // 315  // 323\n    var self = this;                                                                                          // 316  // 324\n                                                                                                              // 317  // 325\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);                                // 318  // 326\n                                                                                                              // 319  // 327\n    // there are several places that assume you aren't combining skip/limit with                              // 320  // 328\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"                              // 321  // 329\n    // comment in _modifyAndNotify                                                                            // 322  // 330\n    // XXX allow skip/limit with unordered observe                                                            // 323  // 331\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit))                                   // 324  // 332\n      throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");  // 325  // 333\n                                                                                                              // 326  // 334\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false))                                  // 327  // 335\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");                                    // 328  // 336\n                                                                                                              // 329  // 337\n    var query = {                                                                                             // 330  // 338\n      matcher: self.matcher, // not fast pathed                                                               // 331  // 339\n      sorter: ordered && self.sorter,                                                                         // 332  // 340\n      distances: (                                                                                            // 333  // 341\n        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),                                 // 334  // 342\n      resultsSnapshot: null,                                                                                  // 335  // 343\n      ordered: ordered,                                                                                       // 336  // 344\n      cursor: self,                                                                                           // 337  // 345\n      projectionFn: self._projectionFn                                                                        // 338  // 346\n    };                                                                                                        // 339  // 347\n    var qid;                                                                                                  // 340  // 348\n                                                                                                              // 341  // 349\n    // Non-reactive queries call added[Before] and then never call anything                                   // 342  // 350\n    // else.                                                                                                  // 343  // 351\n    if (self.reactive) {                                                                                      // 344  // 352\n      qid = self.collection.next_qid++;                                                                       // 345  // 353\n      self.collection.queries[qid] = query;                                                                   // 346  // 354\n    }                                                                                                         // 347  // 355\n    query.results = self._getRawObjects({                                                                     // 348  // 356\n      ordered: ordered, distances: query.distances});                                                         // 349  // 357\n    if (self.collection.paused)                                                                               // 350  // 358\n      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);                                    // 351  // 359\n                                                                                                              // 352  // 360\n    // wrap callbacks we were passed. callbacks only fire when not paused and                                 // 353  // 361\n    // are never undefined                                                                                    // 354  // 362\n    // Filters out blacklisted fields according to cursor's projection.                                       // 355  // 363\n    // XXX wrong place for this?                                                                              // 356  // 364\n                                                                                                              // 357  // 365\n    // furthermore, callbacks enqueue until the operation we're working on is                                 // 358  // 366\n    // done.                                                                                                  // 359  // 367\n    var wrapCallback = function (f) {                                                                         // 360  // 368\n      if (!f)                                                                                                 // 361  // 369\n        return function () {};                                                                                // 362  // 370\n      return function (/*args*/) {                                                                            // 363  // 371\n        var context = this;                                                                                   // 364  // 372\n        var args = arguments;                                                                                 // 365  // 373\n                                                                                                              // 366  // 374\n        if (self.collection.paused)                                                                           // 367  // 375\n          return;                                                                                             // 368  // 376\n                                                                                                              // 369  // 377\n        self.collection._observeQueue.queueTask(function () {                                                 // 370  // 378\n          f.apply(context, args);                                                                             // 371  // 379\n        });                                                                                                   // 372  // 380\n      };                                                                                                      // 373  // 381\n    };                                                                                                        // 374  // 382\n    query.added = wrapCallback(options.added);                                                                // 375  // 383\n    query.changed = wrapCallback(options.changed);                                                            // 376  // 384\n    query.removed = wrapCallback(options.removed);                                                            // 377  // 385\n    if (ordered) {                                                                                            // 378  // 386\n      query.addedBefore = wrapCallback(options.addedBefore);                                                  // 379  // 387\n      query.movedBefore = wrapCallback(options.movedBefore);                                                  // 380  // 388\n    }                                                                                                         // 381  // 389\n                                                                                                              // 382  // 390\n    if (!options._suppress_initial && !self.collection.paused) {                                              // 383  // 391\n      // XXX unify ordered and unordered interface                                                            // 384  // 392\n      var each = ordered                                                                                      // 385  // 393\n            ? _.bind(_.each, null, query.results)                                                             // 386  // 394\n            : _.bind(query.results.forEach, query.results);                                                   // 387  // 395\n      each(function (doc) {                                                                                   // 388  // 396\n        var fields = EJSON.clone(doc);                                                                        // 389  // 397\n                                                                                                              // 390  // 398\n        delete fields._id;                                                                                    // 391  // 399\n        if (ordered)                                                                                          // 392  // 400\n          query.addedBefore(doc._id, self._projectionFn(fields), null);                                       // 393  // 401\n        query.added(doc._id, self._projectionFn(fields));                                                     // 394  // 402\n      });                                                                                                     // 395  // 403\n    }                                                                                                         // 396  // 404\n                                                                                                              // 397  // 405\n    var handle = new LocalCollection.ObserveHandle;                                                           // 398  // 406\n    _.extend(handle, {                                                                                        // 399  // 407\n      collection: self.collection,                                                                            // 400  // 408\n      stop: function () {                                                                                     // 401  // 409\n        if (self.reactive)                                                                                    // 402  // 410\n          delete self.collection.queries[qid];                                                                // 403  // 411\n      }                                                                                                       // 404  // 412\n    });                                                                                                       // 405  // 413\n                                                                                                              // 406  // 414\n    if (self.reactive && Tracker.active) {                                                                    // 407  // 415\n      // XXX in many cases, the same observe will be recreated when                                           // 408  // 416\n      // the current autorun is rerun.  we could save work by                                                 // 409  // 417\n      // letting it linger across rerun and potentially get                                                   // 410  // 418\n      // repurposed if the same observe is performed, using logic                                             // 411  // 419\n      // similar to that of Meteor.subscribe.                                                                 // 412  // 420\n      Tracker.onInvalidate(function () {                                                                      // 413  // 421\n        handle.stop();                                                                                        // 414  // 422\n      });                                                                                                     // 415  // 423\n    }                                                                                                         // 416  // 424\n    // run the observe callbacks resulting from the initial contents                                          // 417  // 425\n    // before we leave the observe.                                                                           // 418  // 426\n    self.collection._observeQueue.drain();                                                                    // 419  // 427\n                                                                                                              // 420  // 428\n    return handle;                                                                                            // 421  // 429\n  }                                                                                                           // 422  // 430\n});                                                                                                           // 423  // 431\n                                                                                                              // 424  // 432\n// Returns a collection of matching objects, but doesn't deep copy them.                                      // 425  // 433\n//                                                                                                            // 426  // 434\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit                              // 427  // 435\n// properties of the query.  if sorter is falsey, no sort -- you get the natural                              // 428  // 436\n// order.                                                                                                     // 429  // 437\n//                                                                                                            // 430  // 438\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip                              // 431  // 439\n// and limit should not be set).                                                                              // 432  // 440\n//                                                                                                            // 433  // 441\n// If ordered is set and this cursor is a $near geoquery, then this function                                  // 434  // 442\n// will use an _IdMap to track each distance from the $near argument point in                                 // 435  // 443\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'                                   // 436  // 444\n// argument, this function will clear it and use it for this purpose (otherwise                               // 437  // 445\n// it will just create its own _IdMap). The observeChanges implementation uses                                // 438  // 446\n// this to remember the distances after this function returns.                                                // 439  // 447\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {                                        // 440  // 448\n  var self = this;                                                                                            // 441  // 449\n  options = options || {};                                                                                    // 442  // 450\n                                                                                                              // 443  // 451\n  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict                                     // 444  // 452\n  // compatible                                                                                               // 445  // 453\n  var results = options.ordered ? [] : new LocalCollection._IdMap;                                            // 446  // 454\n                                                                                                              // 447  // 455\n  // fast path for single ID value                                                                            // 448  // 456\n  if (self._selectorId !== undefined) {                                                                       // 449  // 457\n    // If you have non-zero skip and ask for a single id, you get                                             // 450  // 458\n    // nothing. This is so it matches the behavior of the '{_id: foo}'                                        // 451  // 459\n    // path.                                                                                                  // 452  // 460\n    if (self.skip)                                                                                            // 453  // 461\n      return results;                                                                                         // 454  // 462\n                                                                                                              // 455  // 463\n    var selectedDoc = self.collection._docs.get(self._selectorId);                                            // 456  // 464\n    if (selectedDoc) {                                                                                        // 457  // 465\n      if (options.ordered)                                                                                    // 458  // 466\n        results.push(selectedDoc);                                                                            // 459  // 467\n      else                                                                                                    // 460  // 468\n        results.set(self._selectorId, selectedDoc);                                                           // 461  // 469\n    }                                                                                                         // 462  // 470\n    return results;                                                                                           // 463  // 471\n  }                                                                                                           // 464  // 472\n                                                                                                              // 465  // 473\n  // slow path for arbitrary selector, sort, skip, limit                                                      // 466  // 474\n                                                                                                              // 467  // 475\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,                               // 468  // 476\n  // live results set) object.  in other cases, distances is only used inside                                 // 469  // 477\n  // this function.                                                                                           // 470  // 478\n  var distances;                                                                                              // 471  // 479\n  if (self.matcher.hasGeoQuery() && options.ordered) {                                                        // 472  // 480\n    if (options.distances) {                                                                                  // 473  // 481\n      distances = options.distances;                                                                          // 474  // 482\n      distances.clear();                                                                                      // 475  // 483\n    } else {                                                                                                  // 476  // 484\n      distances = new LocalCollection._IdMap();                                                               // 477  // 485\n    }                                                                                                         // 478  // 486\n  }                                                                                                           // 479  // 487\n                                                                                                              // 480  // 488\n  self.collection._docs.forEach(function (doc, id) {                                                          // 481  // 489\n    var matchResult = self.matcher.documentMatches(doc);                                                      // 482  // 490\n    if (matchResult.result) {                                                                                 // 483  // 491\n      if (options.ordered) {                                                                                  // 484  // 492\n        results.push(doc);                                                                                    // 485  // 493\n        if (distances && matchResult.distance !== undefined)                                                  // 486  // 494\n          distances.set(id, matchResult.distance);                                                            // 487  // 495\n      } else {                                                                                                // 488  // 496\n        results.set(id, doc);                                                                                 // 489  // 497\n      }                                                                                                       // 490  // 498\n    }                                                                                                         // 491  // 499\n    // Fast path for limited unsorted queries.                                                                // 492  // 500\n    // XXX 'length' check here seems wrong for ordered                                                        // 493  // 501\n    if (self.limit && !self.skip && !self.sorter &&                                                           // 494  // 502\n        results.length === self.limit)                                                                        // 495  // 503\n      return false;  // break                                                                                 // 496  // 504\n    return true;  // continue                                                                                 // 497  // 505\n  });                                                                                                         // 498  // 506\n                                                                                                              // 499  // 507\n  if (!options.ordered)                                                                                       // 500  // 508\n    return results;                                                                                           // 501  // 509\n                                                                                                              // 502  // 510\n  if (self.sorter) {                                                                                          // 503  // 511\n    var comparator = self.sorter.getComparator({distances: distances});                                       // 504  // 512\n    results.sort(comparator);                                                                                 // 505  // 513\n  }                                                                                                           // 506  // 514\n                                                                                                              // 507  // 515\n  var idx_start = self.skip || 0;                                                                             // 508  // 516\n  var idx_end = self.limit ? (self.limit + idx_start) : results.length;                                       // 509  // 517\n  return results.slice(idx_start, idx_end);                                                                   // 510  // 518\n};                                                                                                            // 511  // 519\n                                                                                                              // 512  // 520\n// XXX Maybe we need a version of observe that just calls a callback if                                       // 513  // 521\n// anything changed.                                                                                          // 514  // 522\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {                            // 515  // 523\n  var self = this;                                                                                            // 516  // 524\n                                                                                                              // 517  // 525\n  if (Tracker.active) {                                                                                       // 518  // 526\n    var v = new Tracker.Dependency;                                                                           // 519  // 527\n    v.depend();                                                                                               // 520  // 528\n    var notifyChange = _.bind(v.changed, v);                                                                  // 521  // 529\n                                                                                                              // 522  // 530\n    var options = {                                                                                           // 523  // 531\n      _suppress_initial: true,                                                                                // 524  // 532\n      _allow_unordered: _allow_unordered                                                                      // 525  // 533\n    };                                                                                                        // 526  // 534\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],                                     // 527  // 535\n           function (fnName) {                                                                                // 528  // 536\n             if (changers[fnName])                                                                            // 529  // 537\n               options[fnName] = notifyChange;                                                                // 530  // 538\n           });                                                                                                // 531  // 539\n                                                                                                              // 532  // 540\n    // observeChanges will stop() when this computation is invalidated                                        // 533  // 541\n    self.observeChanges(options);                                                                             // 534  // 542\n  }                                                                                                           // 535  // 543\n};                                                                                                            // 536  // 544\n                                                                                                              // 537  // 545\n// XXX enforce rule that field names can't start with '$' or contain '.'                                      // 538  // 546\n// (real mongodb does in fact enforce this)                                                                   // 539  // 547\n// XXX possibly enforce that 'undefined' does not appear (we assume                                           // 540  // 548\n// this in our handling of null and $exists)                                                                  // 541  // 549\nLocalCollection.prototype.insert = function (doc, callback) {                                                 // 542  // 550\n  var self = this;                                                                                            // 543  // 551\n  doc = EJSON.clone(doc);                                                                                     // 544  // 552\n                                                                                                              // 545  // 553\n  if (!_.has(doc, '_id')) {                                                                                   // 546  // 554\n    // if you really want to use ObjectIDs, set this global.                                                  // 547  // 555\n    // Mongo.Collection specifies its own ids and does not use this code.                                     // 548  // 556\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID()                                                // 549  // 557\n                                      : Random.id();                                                          // 550  // 558\n  }                                                                                                           // 551  // 559\n  var id = doc._id;                                                                                           // 552  // 560\n                                                                                                              // 553  // 561\n  if (self._docs.has(id))                                                                                     // 554  // 562\n    throw MinimongoError(\"Duplicate _id '\" + id + \"'\");                                                       // 555  // 563\n                                                                                                              // 556  // 564\n  self._saveOriginal(id, undefined);                                                                          // 557  // 565\n  self._docs.set(id, doc);                                                                                    // 558  // 566\n                                                                                                              // 559  // 567\n  var queriesToRecompute = [];                                                                                // 560  // 568\n  // trigger live queries that match                                                                          // 561  // 569\n  for (var qid in self.queries) {                                                                             // 562  // 570\n    var query = self.queries[qid];                                                                            // 563  // 571\n    var matchResult = query.matcher.documentMatches(doc);                                                     // 564  // 572\n    if (matchResult.result) {                                                                                 // 565  // 573\n      if (query.distances && matchResult.distance !== undefined)                                              // 566  // 574\n        query.distances.set(id, matchResult.distance);                                                        // 567  // 575\n      if (query.cursor.skip || query.cursor.limit)                                                            // 568  // 576\n        queriesToRecompute.push(qid);                                                                         // 569  // 577\n      else                                                                                                    // 570  // 578\n        LocalCollection._insertInResults(query, doc);                                                         // 571  // 579\n    }                                                                                                         // 572  // 580\n  }                                                                                                           // 573  // 581\n                                                                                                              // 574  // 582\n  _.each(queriesToRecompute, function (qid) {                                                                 // 575  // 583\n    if (self.queries[qid])                                                                                    // 576  // 584\n      self._recomputeResults(self.queries[qid]);                                                              // 577  // 585\n  });                                                                                                         // 578  // 586\n  self._observeQueue.drain();                                                                                 // 579  // 587\n                                                                                                              // 580  // 588\n  // Defer because the caller likely doesn't expect the callback to be run                                    // 581  // 589\n  // immediately.                                                                                             // 582  // 590\n  if (callback)                                                                                               // 583  // 591\n    Meteor.defer(function () {                                                                                // 584  // 592\n      callback(null, id);                                                                                     // 585  // 593\n    });                                                                                                       // 586  // 594\n  return id;                                                                                                  // 587  // 595\n};                                                                                                            // 588  // 596\n                                                                                                              // 589  // 597\n// Iterates over a subset of documents that could match selector; calls                                       // 590  // 598\n// f(doc, id) on each of them.  Specifically, if selector specifies                                           // 591  // 599\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the                                    // 592  // 600\n// same object that is in _docs.                                                                              // 593  // 601\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {                                 // 594  // 602\n  var self = this;                                                                                            // 595  // 603\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                          // 596  // 604\n  if (specificIds) {                                                                                          // 597  // 605\n    for (var i = 0; i < specificIds.length; ++i) {                                                            // 598  // 606\n      var id = specificIds[i];                                                                                // 599  // 607\n      var doc = self._docs.get(id);                                                                           // 600  // 608\n      if (doc) {                                                                                              // 601  // 609\n        var breakIfFalse = f(doc, id);                                                                        // 602  // 610\n        if (breakIfFalse === false)                                                                           // 603  // 611\n          break;                                                                                              // 604  // 612\n      }                                                                                                       // 605  // 613\n    }                                                                                                         // 606  // 614\n  } else {                                                                                                    // 607  // 615\n    self._docs.forEach(f);                                                                                    // 608  // 616\n  }                                                                                                           // 609  // 617\n};                                                                                                            // 610  // 618\n                                                                                                              // 611  // 619\nLocalCollection.prototype.remove = function (selector, callback) {                                            // 612  // 620\n  var self = this;                                                                                            // 613  // 621\n                                                                                                              // 614  // 622\n  // Easy special case: if we're not calling observeChanges callbacks and we're                               // 615  // 623\n  // not saving originals and we got asked to remove everything, then just empty                              // 616  // 624\n  // everything directly.                                                                                     // 617  // 625\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {                                   // 618  // 626\n    var result = self._docs.size();                                                                           // 619  // 627\n    self._docs.clear();                                                                                       // 620  // 628\n    _.each(self.queries, function (query) {                                                                   // 621  // 629\n      if (query.ordered) {                                                                                    // 622  // 630\n        query.results = [];                                                                                   // 623  // 631\n      } else {                                                                                                // 624  // 632\n        query.results.clear();                                                                                // 625  // 633\n      }                                                                                                       // 626  // 634\n    });                                                                                                       // 627  // 635\n    if (callback) {                                                                                           // 628  // 636\n      Meteor.defer(function () {                                                                              // 629  // 637\n        callback(null, result);                                                                               // 630  // 638\n      });                                                                                                     // 631  // 639\n    }                                                                                                         // 632  // 640\n    return result;                                                                                            // 633  // 641\n  }                                                                                                           // 634  // 642\n                                                                                                              // 635  // 643\n  var matcher = new Minimongo.Matcher(selector);                                                              // 636  // 644\n  var remove = [];                                                                                            // 637  // 645\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                                // 638  // 646\n    if (matcher.documentMatches(doc).result)                                                                  // 639  // 647\n      remove.push(id);                                                                                        // 640  // 648\n  });                                                                                                         // 641  // 649\n                                                                                                              // 642  // 650\n  var queriesToRecompute = [];                                                                                // 643  // 651\n  var queryRemove = [];                                                                                       // 644  // 652\n  for (var i = 0; i < remove.length; i++) {                                                                   // 645  // 653\n    var removeId = remove[i];                                                                                 // 646  // 654\n    var removeDoc = self._docs.get(removeId);                                                                 // 647  // 655\n    _.each(self.queries, function (query, qid) {                                                              // 648  // 656\n      if (query.matcher.documentMatches(removeDoc).result) {                                                  // 649  // 657\n        if (query.cursor.skip || query.cursor.limit)                                                          // 650  // 658\n          queriesToRecompute.push(qid);                                                                       // 651  // 659\n        else                                                                                                  // 652  // 660\n          queryRemove.push({qid: qid, doc: removeDoc});                                                       // 653  // 661\n      }                                                                                                       // 654  // 662\n    });                                                                                                       // 655  // 663\n    self._saveOriginal(removeId, removeDoc);                                                                  // 656  // 664\n    self._docs.remove(removeId);                                                                              // 657  // 665\n  }                                                                                                           // 658  // 666\n                                                                                                              // 659  // 667\n  // run live query callbacks _after_ we've removed the documents.                                            // 660  // 668\n  _.each(queryRemove, function (remove) {                                                                     // 661  // 669\n    var query = self.queries[remove.qid];                                                                     // 662  // 670\n    if (query) {                                                                                              // 663  // 671\n      query.distances && query.distances.remove(remove.doc._id);                                              // 664  // 672\n      LocalCollection._removeFromResults(query, remove.doc);                                                  // 665  // 673\n    }                                                                                                         // 666  // 674\n  });                                                                                                         // 667  // 675\n  _.each(queriesToRecompute, function (qid) {                                                                 // 668  // 676\n    var query = self.queries[qid];                                                                            // 669  // 677\n    if (query)                                                                                                // 670  // 678\n      self._recomputeResults(query);                                                                          // 671  // 679\n  });                                                                                                         // 672  // 680\n  self._observeQueue.drain();                                                                                 // 673  // 681\n  result = remove.length;                                                                                     // 674  // 682\n  if (callback)                                                                                               // 675  // 683\n    Meteor.defer(function () {                                                                                // 676  // 684\n      callback(null, result);                                                                                 // 677  // 685\n    });                                                                                                       // 678  // 686\n  return result;                                                                                              // 679  // 687\n};                                                                                                            // 680  // 688\n                                                                                                              // 681  // 689\n// XXX atomicity: if multi is true, and one modification fails, do                                            // 682  // 690\n// we rollback the whole operation, or what?                                                                  // 683  // 691\nLocalCollection.prototype.update = function (selector, mod, options, callback) {                              // 684  // 692\n  var self = this;                                                                                            // 685  // 693\n  if (! callback && options instanceof Function) {                                                            // 686  // 694\n    callback = options;                                                                                       // 687  // 695\n    options = null;                                                                                           // 688  // 696\n  }                                                                                                           // 689  // 697\n  if (!options) options = {};                                                                                 // 690  // 698\n                                                                                                              // 691  // 699\n  var matcher = new Minimongo.Matcher(selector);                                                              // 692  // 700\n                                                                                                              // 693  // 701\n  // Save the original results of any query that we might need to                                             // 694  // 702\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in                                // 695  // 703\n  // it. (We don't need to save the original results of paused queries because                                // 696  // 704\n  // they already have a resultsSnapshot and we won't be diffing in                                           // 697  // 705\n  // _recomputeResults.)                                                                                      // 698  // 706\n  var qidToOriginalResults = {};                                                                              // 699  // 707\n  _.each(self.queries, function (query, qid) {                                                                // 700  // 708\n    // XXX for now, skip/limit implies ordered observe, so query.results is                                   // 701  // 709\n    // always an array                                                                                        // 702  // 710\n    if ((query.cursor.skip || query.cursor.limit) && ! self.paused)                                           // 703  // 711\n      qidToOriginalResults[qid] = EJSON.clone(query.results);                                                 // 704  // 712\n  });                                                                                                         // 705  // 713\n  var recomputeQids = {};                                                                                     // 706  // 714\n                                                                                                              // 707  // 715\n  var updateCount = 0;                                                                                        // 708  // 716\n                                                                                                              // 709  // 717\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                                // 710  // 718\n    var queryResult = matcher.documentMatches(doc);                                                           // 711  // 719\n    if (queryResult.result) {                                                                                 // 712  // 720\n      // XXX Should we save the original even if mod ends up being a no-op?                                   // 713  // 721\n      self._saveOriginal(id, doc);                                                                            // 714  // 722\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);                               // 715  // 723\n      ++updateCount;                                                                                          // 716  // 724\n      if (!options.multi)                                                                                     // 717  // 725\n        return false;  // break                                                                               // 718  // 726\n    }                                                                                                         // 719  // 727\n    return true;                                                                                              // 720  // 728\n  });                                                                                                         // 721  // 729\n                                                                                                              // 722  // 730\n  _.each(recomputeQids, function (dummy, qid) {                                                               // 723  // 731\n    var query = self.queries[qid];                                                                            // 724  // 732\n    if (query)                                                                                                // 725  // 733\n      self._recomputeResults(query, qidToOriginalResults[qid]);                                               // 726  // 734\n  });                                                                                                         // 727  // 735\n  self._observeQueue.drain();                                                                                 // 728  // 736\n                                                                                                              // 729  // 737\n  // If we are doing an upsert, and we didn't modify any documents yet, then                                  // 730  // 738\n  // it's time to do an insert. Figure out what document we are inserting, and                                // 731  // 739\n  // generate an id for it.                                                                                   // 732  // 740\n  var insertedId;                                                                                             // 733  // 741\n  if (updateCount === 0 && options.upsert) {                                                                  // 734  // 742\n    var newDoc = LocalCollection._removeDollarOperators(selector);                                            // 735  // 743\n    LocalCollection._modify(newDoc, mod, {isInsert: true});                                                   // 736  // 744\n    if (! newDoc._id && options.insertedId)                                                                   // 737  // 745\n      newDoc._id = options.insertedId;                                                                        // 738  // 746\n    insertedId = self.insert(newDoc);                                                                         // 739  // 747\n    updateCount = 1;                                                                                          // 740  // 748\n  }                                                                                                           // 741  // 749\n                                                                                                              // 742  // 750\n  // Return the number of affected documents, or in the upsert case, an object                                // 743  // 751\n  // containing the number of affected docs and the id of the doc that was                                    // 744  // 752\n  // inserted, if any.                                                                                        // 745  // 753\n  var result;                                                                                                 // 746  // 754\n  if (options._returnObject) {                                                                                // 747  // 755\n    result = {                                                                                                // 748  // 756\n      numberAffected: updateCount                                                                             // 749  // 757\n    };                                                                                                        // 750  // 758\n    if (insertedId !== undefined)                                                                             // 751  // 759\n      result.insertedId = insertedId;                                                                         // 752  // 760\n  } else {                                                                                                    // 753  // 761\n    result = updateCount;                                                                                     // 754  // 762\n  }                                                                                                           // 755  // 763\n                                                                                                              // 756  // 764\n  if (callback)                                                                                               // 757  // 765\n    Meteor.defer(function () {                                                                                // 758  // 766\n      callback(null, result);                                                                                 // 759  // 767\n    });                                                                                                       // 760  // 768\n  return result;                                                                                              // 761  // 769\n};                                                                                                            // 762  // 770\n                                                                                                              // 763  // 771\n// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is                                       // 764  // 772\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:                              // 765  // 773\n// true }).                                                                                                   // 766  // 774\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {                              // 767  // 775\n  var self = this;                                                                                            // 768  // 776\n  if (! callback && typeof options === \"function\") {                                                          // 769  // 777\n    callback = options;                                                                                       // 770  // 778\n    options = {};                                                                                             // 771  // 779\n  }                                                                                                           // 772  // 780\n  return self.update(selector, mod, _.extend({}, options, {                                                   // 773  // 781\n    upsert: true,                                                                                             // 774  // 782\n    _returnObject: true                                                                                       // 775  // 783\n  }), callback);                                                                                              // 776  // 784\n};                                                                                                            // 777  // 785\n                                                                                                              // 778  // 786\nLocalCollection.prototype._modifyAndNotify = function (                                                       // 779  // 787\n    doc, mod, recomputeQids, arrayIndices) {                                                                  // 780  // 788\n  var self = this;                                                                                            // 781  // 789\n                                                                                                              // 782  // 790\n  var matched_before = {};                                                                                    // 783  // 791\n  for (var qid in self.queries) {                                                                             // 784  // 792\n    var query = self.queries[qid];                                                                            // 785  // 793\n    if (query.ordered) {                                                                                      // 786  // 794\n      matched_before[qid] = query.matcher.documentMatches(doc).result;                                        // 787  // 795\n    } else {                                                                                                  // 788  // 796\n      // Because we don't support skip or limit (yet) in unordered queries, we                                // 789  // 797\n      // can just do a direct lookup.                                                                         // 790  // 798\n      matched_before[qid] = query.results.has(doc._id);                                                       // 791  // 799\n    }                                                                                                         // 792  // 800\n  }                                                                                                           // 793  // 801\n                                                                                                              // 794  // 802\n  var old_doc = EJSON.clone(doc);                                                                             // 795  // 803\n                                                                                                              // 796  // 804\n  LocalCollection._modify(doc, mod, {arrayIndices: arrayIndices});                                            // 797  // 805\n                                                                                                              // 798  // 806\n  for (qid in self.queries) {                                                                                 // 799  // 807\n    query = self.queries[qid];                                                                                // 800  // 808\n    var before = matched_before[qid];                                                                         // 801  // 809\n    var afterMatch = query.matcher.documentMatches(doc);                                                      // 802  // 810\n    var after = afterMatch.result;                                                                            // 803  // 811\n    if (after && query.distances && afterMatch.distance !== undefined)                                        // 804  // 812\n      query.distances.set(doc._id, afterMatch.distance);                                                      // 805  // 813\n                                                                                                              // 806  // 814\n    if (query.cursor.skip || query.cursor.limit) {                                                            // 807  // 815\n      // We need to recompute any query where the doc may have been in the                                    // 808  // 816\n      // cursor's window either before or after the update. (Note that if skip                                // 809  // 817\n      // or limit is set, \"before\" and \"after\" being true do not necessarily                                  // 810  // 818\n      // mean that the document is in the cursor's output after skip/limit is                                 // 811  // 819\n      // applied... but if they are false, then the document definitely is NOT                                // 812  // 820\n      // in the output. So it's safe to skip recompute if neither before or                                   // 813  // 821\n      // after are true.)                                                                                     // 814  // 822\n      if (before || after)                                                                                    // 815  // 823\n        recomputeQids[qid] = true;                                                                            // 816  // 824\n    } else if (before && !after) {                                                                            // 817  // 825\n      LocalCollection._removeFromResults(query, doc);                                                         // 818  // 826\n    } else if (!before && after) {                                                                            // 819  // 827\n      LocalCollection._insertInResults(query, doc);                                                           // 820  // 828\n    } else if (before && after) {                                                                             // 821  // 829\n      LocalCollection._updateInResults(query, doc, old_doc);                                                  // 822  // 830\n    }                                                                                                         // 823  // 831\n  }                                                                                                           // 824  // 832\n};                                                                                                            // 825  // 833\n                                                                                                              // 826  // 834\n// XXX the sorted-query logic below is laughably inefficient. we'll                                           // 827  // 835\n// need to come up with a better datastructure for this.                                                      // 828  // 836\n//                                                                                                            // 829  // 837\n// XXX the logic for observing with a skip or a limit is even more                                            // 830  // 838\n// laughably inefficient. we recompute the whole results every time!                                          // 831  // 839\n                                                                                                              // 832  // 840\nLocalCollection._insertInResults = function (query, doc) {                                                    // 833  // 841\n  var fields = EJSON.clone(doc);                                                                              // 834  // 842\n  delete fields._id;                                                                                          // 835  // 843\n  if (query.ordered) {                                                                                        // 836  // 844\n    if (!query.sorter) {                                                                                      // 837  // 845\n      query.addedBefore(doc._id, query.projectionFn(fields), null);                                           // 838  // 846\n      query.results.push(doc);                                                                                // 839  // 847\n    } else {                                                                                                  // 840  // 848\n      var i = LocalCollection._insertInSortedList(                                                            // 841  // 849\n        query.sorter.getComparator({distances: query.distances}),                                             // 842  // 850\n        query.results, doc);                                                                                  // 843  // 851\n      var next = query.results[i+1];                                                                          // 844  // 852\n      if (next)                                                                                               // 845  // 853\n        next = next._id;                                                                                      // 846  // 854\n      else                                                                                                    // 847  // 855\n        next = null;                                                                                          // 848  // 856\n      query.addedBefore(doc._id, query.projectionFn(fields), next);                                           // 849  // 857\n    }                                                                                                         // 850  // 858\n    query.added(doc._id, query.projectionFn(fields));                                                         // 851  // 859\n  } else {                                                                                                    // 852  // 860\n    query.added(doc._id, query.projectionFn(fields));                                                         // 853  // 861\n    query.results.set(doc._id, doc);                                                                          // 854  // 862\n  }                                                                                                           // 855  // 863\n};                                                                                                            // 856  // 864\n                                                                                                              // 857  // 865\nLocalCollection._removeFromResults = function (query, doc) {                                                  // 858  // 866\n  if (query.ordered) {                                                                                        // 859  // 867\n    var i = LocalCollection._findInOrderedResults(query, doc);                                                // 860  // 868\n    query.removed(doc._id);                                                                                   // 861  // 869\n    query.results.splice(i, 1);                                                                               // 862  // 870\n  } else {                                                                                                    // 863  // 871\n    var id = doc._id;  // in case callback mutates doc                                                        // 864  // 872\n    query.removed(doc._id);                                                                                   // 865  // 873\n    query.results.remove(id);                                                                                 // 866  // 874\n  }                                                                                                           // 867  // 875\n};                                                                                                            // 868  // 876\n                                                                                                              // 869  // 877\nLocalCollection._updateInResults = function (query, doc, old_doc) {                                           // 870  // 878\n  if (!EJSON.equals(doc._id, old_doc._id))                                                                    // 871  // 879\n    throw new Error(\"Can't change a doc's _id while updating\");                                               // 872  // 880\n  var projectionFn = query.projectionFn;                                                                      // 873  // 881\n  var changedFields = DiffSequence.makeChangedFields(                                                         // 874  // 882\n    projectionFn(doc), projectionFn(old_doc));                                                                // 875  // 883\n                                                                                                              // 876  // 884\n  if (!query.ordered) {                                                                                       // 877  // 885\n    if (!_.isEmpty(changedFields)) {                                                                          // 878  // 886\n      query.changed(doc._id, changedFields);                                                                  // 879  // 887\n      query.results.set(doc._id, doc);                                                                        // 880  // 888\n    }                                                                                                         // 881  // 889\n    return;                                                                                                   // 882  // 890\n  }                                                                                                           // 883  // 891\n                                                                                                              // 884  // 892\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);                                           // 885  // 893\n                                                                                                              // 886  // 894\n  if (!_.isEmpty(changedFields))                                                                              // 887  // 895\n    query.changed(doc._id, changedFields);                                                                    // 888  // 896\n  if (!query.sorter)                                                                                          // 889  // 897\n    return;                                                                                                   // 890  // 898\n                                                                                                              // 891  // 899\n  // just take it out and put it back in again, and see if the index                                          // 892  // 900\n  // changes                                                                                                  // 893  // 901\n  query.results.splice(orig_idx, 1);                                                                          // 894  // 902\n  var new_idx = LocalCollection._insertInSortedList(                                                          // 895  // 903\n    query.sorter.getComparator({distances: query.distances}),                                                 // 896  // 904\n    query.results, doc);                                                                                      // 897  // 905\n  if (orig_idx !== new_idx) {                                                                                 // 898  // 906\n    var next = query.results[new_idx+1];                                                                      // 899  // 907\n    if (next)                                                                                                 // 900  // 908\n      next = next._id;                                                                                        // 901  // 909\n    else                                                                                                      // 902  // 910\n      next = null;                                                                                            // 903  // 911\n    query.movedBefore && query.movedBefore(doc._id, next);                                                    // 904  // 912\n  }                                                                                                           // 905  // 913\n};                                                                                                            // 906  // 914\n                                                                                                              // 907  // 915\n// Recomputes the results of a query and runs observe callbacks for the                                       // 908  // 916\n// difference between the previous results and the current results (unless                                    // 909  // 917\n// paused). Used for skip/limit queries.                                                                      // 910  // 918\n//                                                                                                            // 911  // 919\n// When this is used by insert or remove, it can just use query.results for the                               // 912  // 920\n// old results (and there's no need to pass in oldResults), because these                                     // 913  // 921\n// operations don't mutate the documents in the collection. Update needs to pass                              // 914  // 922\n// in an oldResults which was deep-copied before the modifier was applied.                                    // 915  // 923\n//                                                                                                            // 916  // 924\n// oldResults is guaranteed to be ignored if the query is not paused.                                         // 917  // 925\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {                                  // 918  // 926\n  var self = this;                                                                                            // 919  // 927\n  if (! self.paused && ! oldResults)                                                                          // 920  // 928\n    oldResults = query.results;                                                                               // 921  // 929\n  if (query.distances)                                                                                        // 922  // 930\n    query.distances.clear();                                                                                  // 923  // 931\n  query.results = query.cursor._getRawObjects({                                                               // 924  // 932\n    ordered: query.ordered, distances: query.distances});                                                     // 925  // 933\n                                                                                                              // 926  // 934\n  if (! self.paused) {                                                                                        // 927  // 935\n    LocalCollection._diffQueryChanges(                                                                        // 928  // 936\n      query.ordered, oldResults, query.results, query,                                                        // 929  // 937\n      { projectionFn: query.projectionFn });                                                                  // 930  // 938\n  }                                                                                                           // 931  // 939\n};                                                                                                            // 932  // 940\n                                                                                                              // 933  // 941\n                                                                                                              // 934  // 942\nLocalCollection._findInOrderedResults = function (query, doc) {                                               // 935  // 943\n  if (!query.ordered)                                                                                         // 936  // 944\n    throw new Error(\"Can't call _findInOrderedResults on unordered query\");                                   // 937  // 945\n  for (var i = 0; i < query.results.length; i++)                                                              // 938  // 946\n    if (query.results[i] === doc)                                                                             // 939  // 947\n      return i;                                                                                               // 940  // 948\n  throw Error(\"object missing from query\");                                                                   // 941  // 949\n};                                                                                                            // 942  // 950\n                                                                                                              // 943  // 951\n// This binary search puts a value between any equal values, and the first                                    // 944  // 952\n// lesser value.                                                                                              // 945  // 953\nLocalCollection._binarySearch = function (cmp, array, value) {                                                // 946  // 954\n  var first = 0, rangeLength = array.length;                                                                  // 947  // 955\n                                                                                                              // 948  // 956\n  while (rangeLength > 0) {                                                                                   // 949  // 957\n    var halfRange = Math.floor(rangeLength/2);                                                                // 950  // 958\n    if (cmp(value, array[first + halfRange]) >= 0) {                                                          // 951  // 959\n      first += halfRange + 1;                                                                                 // 952  // 960\n      rangeLength -= halfRange + 1;                                                                           // 953  // 961\n    } else {                                                                                                  // 954  // 962\n      rangeLength = halfRange;                                                                                // 955  // 963\n    }                                                                                                         // 956  // 964\n  }                                                                                                           // 957  // 965\n  return first;                                                                                               // 958  // 966\n};                                                                                                            // 959  // 967\n                                                                                                              // 960  // 968\nLocalCollection._insertInSortedList = function (cmp, array, value) {                                          // 961  // 969\n  if (array.length === 0) {                                                                                   // 962  // 970\n    array.push(value);                                                                                        // 963  // 971\n    return 0;                                                                                                 // 964  // 972\n  }                                                                                                           // 965  // 973\n                                                                                                              // 966  // 974\n  var idx = LocalCollection._binarySearch(cmp, array, value);                                                 // 967  // 975\n  array.splice(idx, 0, value);                                                                                // 968  // 976\n  return idx;                                                                                                 // 969  // 977\n};                                                                                                            // 970  // 978\n                                                                                                              // 971  // 979\n// To track what documents are affected by a piece of code, call saveOriginals()                              // 972  // 980\n// before it and retrieveOriginals() after it. retrieveOriginals returns an                                   // 973  // 981\n// object whose keys are the ids of the documents that were affected since the                                // 974  // 982\n// call to saveOriginals(), and the values are equal to the document's contents                               // 975  // 983\n// at the time of saveOriginals. (In the case of an inserted document, undefined                              // 976  // 984\n// is the value.) You must alternate between calls to saveOriginals() and                                     // 977  // 985\n// retrieveOriginals().                                                                                       // 978  // 986\nLocalCollection.prototype.saveOriginals = function () {                                                       // 979  // 987\n  var self = this;                                                                                            // 980  // 988\n  if (self._savedOriginals)                                                                                   // 981  // 989\n    throw new Error(\"Called saveOriginals twice without retrieveOriginals\");                                  // 982  // 990\n  self._savedOriginals = new LocalCollection._IdMap;                                                          // 983  // 991\n};                                                                                                            // 984  // 992\nLocalCollection.prototype.retrieveOriginals = function () {                                                   // 985  // 993\n  var self = this;                                                                                            // 986  // 994\n  if (!self._savedOriginals)                                                                                  // 987  // 995\n    throw new Error(\"Called retrieveOriginals without saveOriginals\");                                        // 988  // 996\n                                                                                                              // 989  // 997\n  var originals = self._savedOriginals;                                                                       // 990  // 998\n  self._savedOriginals = null;                                                                                // 991  // 999\n  return originals;                                                                                           // 992  // 1000\n};                                                                                                            // 993  // 1001\n                                                                                                              // 994  // 1002\nLocalCollection.prototype._saveOriginal = function (id, doc) {                                                // 995  // 1003\n  var self = this;                                                                                            // 996  // 1004\n  // Are we even trying to save originals?                                                                    // 997  // 1005\n  if (!self._savedOriginals)                                                                                  // 998  // 1006\n    return;                                                                                                   // 999  // 1007\n  // Have we previously mutated the original (and so 'doc' is not actually                                    // 1000\n  // original)?  (Note the 'has' check rather than truth: we store undefined                                  // 1001\n  // here for inserted docs!)                                                                                 // 1002\n  if (self._savedOriginals.has(id))                                                                           // 1003\n    return;                                                                                                   // 1004\n  self._savedOriginals.set(id, EJSON.clone(doc));                                                             // 1005\n};                                                                                                            // 1006\n                                                                                                              // 1007\n// Pause the observers. No callbacks from observers will fire until                                           // 1008\n// 'resumeObservers' is called.                                                                               // 1009\nLocalCollection.prototype.pauseObservers = function () {                                                      // 1010\n  // No-op if already paused.                                                                                 // 1011\n  if (this.paused)                                                                                            // 1012\n    return;                                                                                                   // 1013\n                                                                                                              // 1014\n  // Set the 'paused' flag such that new observer messages don't fire.                                        // 1015\n  this.paused = true;                                                                                         // 1016\n                                                                                                              // 1017\n  // Take a snapshot of the query results for each query.                                                     // 1018\n  for (var qid in this.queries) {                                                                             // 1019\n    var query = this.queries[qid];                                                                            // 1020\n                                                                                                              // 1021\n    query.resultsSnapshot = EJSON.clone(query.results);                                                       // 1022\n  }                                                                                                           // 1023\n};                                                                                                            // 1024\n                                                                                                              // 1025\n// Resume the observers. Observers immediately receive change                                                 // 1026\n// notifications to bring them to the current state of the                                                    // 1027\n// database. Note that this is not just replaying all the changes that                                        // 1028\n// happened during the pause, it is a smarter 'coalesced' diff.                                               // 1029\nLocalCollection.prototype.resumeObservers = function () {                                                     // 1030\n  var self = this;                                                                                            // 1031\n  // No-op if not paused.                                                                                     // 1032\n  if (!this.paused)                                                                                           // 1033\n    return;                                                                                                   // 1034\n                                                                                                              // 1035\n  // Unset the 'paused' flag. Make sure to do this first, otherwise                                           // 1036\n  // observer methods won't actually fire when we trigger them.                                               // 1037\n  this.paused = false;                                                                                        // 1038\n                                                                                                              // 1039\n  for (var qid in this.queries) {                                                                             // 1040\n    var query = self.queries[qid];                                                                            // 1041\n    // Diff the current results against the snapshot and send to observers.                                   // 1042\n    // pass the query object for its observer callbacks.                                                      // 1043\n    LocalCollection._diffQueryChanges(                                                                        // 1044\n      query.ordered, query.resultsSnapshot, query.results, query,                                             // 1045\n      { projectionFn: query.projectionFn });                                                                  // 1046\n    query.resultsSnapshot = null;                                                                             // 1047\n  }                                                                                                           // 1048\n  self._observeQueue.drain();                                                                                 // 1049\n};                                                                                                            // 1050\n                                                                                                              // 1051\n                                                                                                              // 1052\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1061\n                                                                                                                      // 1062\n}).call(this);                                                                                                        // 1063\n                                                                                                                      // 1064\n                                                                                                                      // 1065\n                                                                                                                      // 1066\n                                                                                                                      // 1067\n                                                                                                                      // 1068\n                                                                                                                      // 1069\n(function(){                                                                                                          // 1070\n                                                                                                                      // 1071\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1072\n//                                                                                                            //      // 1073\n// packages/minimongo/wrap_transform.js                                                                       //      // 1074\n//                                                                                                            //      // 1075\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1076\n                                                                                                              //      // 1077\n// Wrap a transform function to return objects that have the _id field                                        // 1    // 1078\n// of the untransformed document. This ensures that subsystems such as                                        // 2    // 1079\n// the observe-sequence package that call `observe` can keep track of                                         // 3    // 1080\n// the documents identities.                                                                                  // 4    // 1081\n//                                                                                                            // 5    // 1082\n// - Require that it returns objects                                                                          // 6    // 1083\n// - If the return value has an _id field, verify that it matches the                                         // 7    // 1084\n//   original _id field                                                                                       // 8    // 1085\n// - If the return value doesn't have an _id field, add it back.                                              // 9    // 1086\nLocalCollection.wrapTransform = function (transform) {                                                        // 10   // 1087\n  if (! transform)                                                                                            // 11   // 1088\n    return null;                                                                                              // 12   // 1089\n                                                                                                              // 13   // 1090\n  // No need to doubly-wrap transforms.                                                                       // 14   // 1091\n  if (transform.__wrappedTransform__)                                                                         // 15   // 1092\n    return transform;                                                                                         // 16   // 1093\n                                                                                                              // 17   // 1094\n  var wrapped = function (doc) {                                                                              // 18   // 1095\n    if (!_.has(doc, '_id')) {                                                                                 // 19   // 1096\n      // XXX do we ever have a transform on the oplog's collection? because that                              // 20   // 1097\n      // collection has no _id.                                                                               // 21   // 1098\n      throw new Error(\"can only transform documents with _id\");                                               // 22   // 1099\n    }                                                                                                         // 23   // 1100\n                                                                                                              // 24   // 1101\n    var id = doc._id;                                                                                         // 25   // 1102\n    // XXX consider making tracker a weak dependency and checking Package.tracker here                        // 26   // 1103\n    var transformed = Tracker.nonreactive(function () {                                                       // 27   // 1104\n      return transform(doc);                                                                                  // 28   // 1105\n    });                                                                                                       // 29   // 1106\n                                                                                                              // 30   // 1107\n    if (!isPlainObject(transformed)) {                                                                        // 31   // 1108\n      throw new Error(\"transform must return object\");                                                        // 32   // 1109\n    }                                                                                                         // 33   // 1110\n                                                                                                              // 34   // 1111\n    if (_.has(transformed, '_id')) {                                                                          // 35   // 1112\n      if (!EJSON.equals(transformed._id, id)) {                                                               // 36   // 1113\n        throw new Error(\"transformed document can't have different _id\");                                     // 37   // 1114\n      }                                                                                                       // 38   // 1115\n    } else {                                                                                                  // 39   // 1116\n      transformed._id = id;                                                                                   // 40   // 1117\n    }                                                                                                         // 41   // 1118\n    return transformed;                                                                                       // 42   // 1119\n  };                                                                                                          // 43   // 1120\n  wrapped.__wrappedTransform__ = true;                                                                        // 44   // 1121\n  return wrapped;                                                                                             // 45   // 1122\n};                                                                                                            // 46   // 1123\n                                                                                                              // 47   // 1124\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1125\n                                                                                                                      // 1126\n}).call(this);                                                                                                        // 1127\n                                                                                                                      // 1128\n                                                                                                                      // 1129\n                                                                                                                      // 1130\n                                                                                                                      // 1131\n                                                                                                                      // 1132\n                                                                                                                      // 1133\n(function(){                                                                                                          // 1134\n                                                                                                                      // 1135\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1136\n//                                                                                                            //      // 1137\n// packages/minimongo/helpers.js                                                                              //      // 1138\n//                                                                                                            //      // 1139\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1140\n                                                                                                              //      // 1141\n// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as                               // 1    // 1142\n// arrays.                                                                                                    // 2    // 1143\n// XXX maybe this should be EJSON.isArray                                                                     // 3    // 1144\nisArray = function (x) {                                                                                      // 4    // 1145\n  return _.isArray(x) && !EJSON.isBinary(x);                                                                  // 5    // 1146\n};                                                                                                            // 6    // 1147\n                                                                                                              // 7    // 1148\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about                                   // 8    // 1149\n// RegExp                                                                                                     // 9    // 1150\n// XXX note that _type(undefined) === 3!!!!                                                                   // 10   // 1151\nisPlainObject = LocalCollection._isPlainObject = function (x) {                                               // 11   // 1152\n  return x && LocalCollection._f._type(x) === 3;                                                              // 12   // 1153\n};                                                                                                            // 13   // 1154\n                                                                                                              // 14   // 1155\nisIndexable = function (x) {                                                                                  // 15   // 1156\n  return isArray(x) || isPlainObject(x);                                                                      // 16   // 1157\n};                                                                                                            // 17   // 1158\n                                                                                                              // 18   // 1159\n// Returns true if this is an object with at least one key and all keys begin                                 // 19   // 1160\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and                                // 20   // 1161\n// others don't.                                                                                              // 21   // 1162\nisOperatorObject = function (valueSelector, inconsistentOK) {                                                 // 22   // 1163\n  if (!isPlainObject(valueSelector))                                                                          // 23   // 1164\n    return false;                                                                                             // 24   // 1165\n                                                                                                              // 25   // 1166\n  var theseAreOperators = undefined;                                                                          // 26   // 1167\n  _.each(valueSelector, function (value, selKey) {                                                            // 27   // 1168\n    var thisIsOperator = selKey.substr(0, 1) === '$';                                                         // 28   // 1169\n    if (theseAreOperators === undefined) {                                                                    // 29   // 1170\n      theseAreOperators = thisIsOperator;                                                                     // 30   // 1171\n    } else if (theseAreOperators !== thisIsOperator) {                                                        // 31   // 1172\n      if (!inconsistentOK)                                                                                    // 32   // 1173\n        throw new Error(\"Inconsistent operator: \" +                                                           // 33   // 1174\n                        JSON.stringify(valueSelector));                                                       // 34   // 1175\n      theseAreOperators = false;                                                                              // 35   // 1176\n    }                                                                                                         // 36   // 1177\n  });                                                                                                         // 37   // 1178\n  return !!theseAreOperators;  // {} has no operators                                                         // 38   // 1179\n};                                                                                                            // 39   // 1180\n                                                                                                              // 40   // 1181\n                                                                                                              // 41   // 1182\n// string can be converted to integer                                                                         // 42   // 1183\nisNumericKey = function (s) {                                                                                 // 43   // 1184\n  return /^[0-9]+$/.test(s);                                                                                  // 44   // 1185\n};                                                                                                            // 45   // 1186\n                                                                                                              // 46   // 1187\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1188\n                                                                                                                      // 1189\n}).call(this);                                                                                                        // 1190\n                                                                                                                      // 1191\n                                                                                                                      // 1192\n                                                                                                                      // 1193\n                                                                                                                      // 1194\n                                                                                                                      // 1195\n                                                                                                                      // 1196\n(function(){                                                                                                          // 1197\n                                                                                                                      // 1198\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1199\n//                                                                                                            //      // 1200\n// packages/minimongo/selector.js                                                                             //      // 1201\n//                                                                                                            //      // 1202\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 1203\n                                                                                                              //      // 1204\n// The minimongo selector compiler!                                                                           // 1    // 1205\n                                                                                                              // 2    // 1206\n// Terminology:                                                                                               // 3    // 1207\n//  - a \"selector\" is the EJSON object representing a selector                                                // 4    // 1208\n//  - a \"matcher\" is its compiled form (whether a full Minimongo.Matcher                                      // 5    // 1209\n//    object or one of the component lambdas that matches parts of it)                                        // 6    // 1210\n//  - a \"result object\" is an object with a \"result\" field and maybe                                          // 7    // 1211\n//    distance and arrayIndices.                                                                              // 8    // 1212\n//  - a \"branched value\" is an object with a \"value\" field and maybe                                          // 9    // 1213\n//    \"dontIterate\" and \"arrayIndices\".                                                                       // 10   // 1214\n//  - a \"document\" is a top-level object that can be stored in a collection.                                  // 11   // 1215\n//  - a \"lookup function\" is a function that takes in a document and returns                                  // 12   // 1216\n//    an array of \"branched values\".                                                                          // 13   // 1217\n//  - a \"branched matcher\" maps from an array of branched values to a result                                  // 14   // 1218\n//    object.                                                                                                 // 15   // 1219\n//  - an \"element matcher\" maps from a single value to a bool.                                                // 16   // 1220\n                                                                                                              // 17   // 1221\n// Main entry point.                                                                                          // 18   // 1222\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});                                                      // 19   // 1223\n//   if (matcher.documentMatches({a: 7})) ...                                                                 // 20   // 1224\nMinimongo.Matcher = function (selector) {                                                                     // 21   // 1225\n  var self = this;                                                                                            // 22   // 1226\n  // A set (object mapping string -> *) of all of the document paths looked                                   // 23   // 1227\n  // at by the selector. Also includes the empty string if it may look at any                                 // 24   // 1228\n  // path (eg, $where).                                                                                       // 25   // 1229\n  self._paths = {};                                                                                           // 26   // 1230\n  // Set to true if compilation finds a $near.                                                                // 27   // 1231\n  self._hasGeoQuery = false;                                                                                  // 28   // 1232\n  // Set to true if compilation finds a $where.                                                               // 29   // 1233\n  self._hasWhere = false;                                                                                     // 30   // 1234\n  // Set to false if compilation finds anything other than a simple equality or                               // 31   // 1235\n  // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with                              // 32   // 1236\n  // scalars as operands.                                                                                     // 33   // 1237\n  self._isSimple = true;                                                                                      // 34   // 1238\n  // Set to a dummy document which always matches this Matcher. Or set to null                                // 35   // 1239\n  // if such document is too hard to find.                                                                    // 36   // 1240\n  self._matchingDocument = undefined;                                                                         // 37   // 1241\n  // A clone of the original selector. It may just be a function if the user                                  // 38   // 1242\n  // passed in a function; otherwise is definitely an object (eg, IDs are                                     // 39   // 1243\n  // translated into {_id: ID} first. Used by canBecomeTrueByModifier and                                     // 40   // 1244\n  // Sorter._useWithMatcher.                                                                                  // 41   // 1245\n  self._selector = null;                                                                                      // 42   // 1246\n  self._docMatcher = self._compileSelector(selector);                                                         // 43   // 1247\n};                                                                                                            // 44   // 1248\n                                                                                                              // 45   // 1249\n_.extend(Minimongo.Matcher.prototype, {                                                                       // 46   // 1250\n  documentMatches: function (doc) {                                                                           // 47   // 1251\n    if (!doc || typeof doc !== \"object\") {                                                                    // 48   // 1252\n      throw Error(\"documentMatches needs a document\");                                                        // 49   // 1253\n    }                                                                                                         // 50   // 1254\n    return this._docMatcher(doc);                                                                             // 51   // 1255\n  },                                                                                                          // 52   // 1256\n  hasGeoQuery: function () {                                                                                  // 53   // 1257\n    return this._hasGeoQuery;                                                                                 // 54   // 1258\n  },                                                                                                          // 55   // 1259\n  hasWhere: function () {                                                                                     // 56   // 1260\n    return this._hasWhere;                                                                                    // 57   // 1261\n  },                                                                                                          // 58   // 1262\n  isSimple: function () {                                                                                     // 59   // 1263\n    return this._isSimple;                                                                                    // 60   // 1264\n  },                                                                                                          // 61   // 1265\n                                                                                                              // 62   // 1266\n  // Given a selector, return a function that takes one argument, a                                           // 63   // 1267\n  // document. It returns a result object.                                                                    // 64   // 1268\n  _compileSelector: function (selector) {                                                                     // 65   // 1269\n    var self = this;                                                                                          // 66   // 1270\n    // you can pass a literal function instead of a selector                                                  // 67   // 1271\n    if (selector instanceof Function) {                                                                       // 68   // 1272\n      self._isSimple = false;                                                                                 // 69   // 1273\n      self._selector = selector;                                                                              // 70   // 1274\n      self._recordPathUsed('');                                                                               // 71   // 1275\n      return function (doc) {                                                                                 // 72   // 1276\n        return {result: !!selector.call(doc)};                                                                // 73   // 1277\n      };                                                                                                      // 74   // 1278\n    }                                                                                                         // 75   // 1279\n                                                                                                              // 76   // 1280\n    // shorthand -- scalars match _id                                                                         // 77   // 1281\n    if (LocalCollection._selectorIsId(selector)) {                                                            // 78   // 1282\n      self._selector = {_id: selector};                                                                       // 79   // 1283\n      self._recordPathUsed('_id');                                                                            // 80   // 1284\n      return function (doc) {                                                                                 // 81   // 1285\n        return {result: EJSON.equals(doc._id, selector)};                                                     // 82   // 1286\n      };                                                                                                      // 83   // 1287\n    }                                                                                                         // 84   // 1288\n                                                                                                              // 85   // 1289\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both                                // 86   // 1290\n    // likely programmer error, and not what you want, particularly for                                       // 87   // 1291\n    // destructive operations.                                                                                // 88   // 1292\n    if (!selector || (('_id' in selector) && !selector._id)) {                                                // 89   // 1293\n      self._isSimple = false;                                                                                 // 90   // 1294\n      return nothingMatcher;                                                                                  // 91   // 1295\n    }                                                                                                         // 92   // 1296\n                                                                                                              // 93   // 1297\n    // Top level can't be an array or true or binary.                                                         // 94   // 1298\n    if (typeof(selector) === 'boolean' || isArray(selector) ||                                                // 95   // 1299\n        EJSON.isBinary(selector))                                                                             // 96   // 1300\n      throw new Error(\"Invalid selector: \" + selector);                                                       // 97   // 1301\n                                                                                                              // 98   // 1302\n    self._selector = EJSON.clone(selector);                                                                   // 99   // 1303\n    return compileDocumentSelector(selector, self, {isRoot: true});                                           // 100  // 1304\n  },                                                                                                          // 101  // 1305\n  _recordPathUsed: function (path) {                                                                          // 102  // 1306\n    this._paths[path] = true;                                                                                 // 103  // 1307\n  },                                                                                                          // 104  // 1308\n  // Returns a list of key paths the given selector is looking for. It includes                               // 105  // 1309\n  // the empty string if there is a $where.                                                                   // 106  // 1310\n  _getPaths: function () {                                                                                    // 107  // 1311\n    return _.keys(this._paths);                                                                               // 108  // 1312\n  }                                                                                                           // 109  // 1313\n});                                                                                                           // 110  // 1314\n                                                                                                              // 111  // 1315\n                                                                                                              // 112  // 1316\n// Takes in a selector that could match a full document (eg, the original                                     // 113  // 1317\n// selector). Returns a function mapping document->result object.                                             // 114  // 1318\n//                                                                                                            // 115  // 1319\n// matcher is the Matcher object we are compiling.                                                            // 116  // 1320\n//                                                                                                            // 117  // 1321\n// If this is the root document selector (ie, not wrapped in $and or the like),                               // 118  // 1322\n// then isRoot is true. (This is used by $near.)                                                              // 119  // 1323\nvar compileDocumentSelector = function (docSelector, matcher, options) {                                      // 120  // 1324\n  options = options || {};                                                                                    // 121  // 1325\n  var docMatchers = [];                                                                                       // 122  // 1326\n  _.each(docSelector, function (subSelector, key) {                                                           // 123  // 1327\n    if (key.substr(0, 1) === '$') {                                                                           // 124  // 1328\n      // Outer operators are either logical operators (they recurse back into                                 // 125  // 1329\n      // this function), or $where.                                                                           // 126  // 1330\n      if (!_.has(LOGICAL_OPERATORS, key))                                                                     // 127  // 1331\n        throw new Error(\"Unrecognized logical operator: \" + key);                                             // 128  // 1332\n      matcher._isSimple = false;                                                                              // 129  // 1333\n      docMatchers.push(LOGICAL_OPERATORS[key](subSelector, matcher,                                           // 130  // 1334\n                                              options.inElemMatch));                                          // 131  // 1335\n    } else {                                                                                                  // 132  // 1336\n      // Record this path, but only if we aren't in an elemMatcher, since in an                               // 133  // 1337\n      // elemMatch this is a path inside an object in an array, not in the doc                                // 134  // 1338\n      // root.                                                                                                // 135  // 1339\n      if (!options.inElemMatch)                                                                               // 136  // 1340\n        matcher._recordPathUsed(key);                                                                         // 137  // 1341\n      var lookUpByIndex = makeLookupFunction(key);                                                            // 138  // 1342\n      var valueMatcher =                                                                                      // 139  // 1343\n        compileValueSelector(subSelector, matcher, options.isRoot);                                           // 140  // 1344\n      docMatchers.push(function (doc) {                                                                       // 141  // 1345\n        var branchValues = lookUpByIndex(doc);                                                                // 142  // 1346\n        return valueMatcher(branchValues);                                                                    // 143  // 1347\n      });                                                                                                     // 144  // 1348\n    }                                                                                                         // 145  // 1349\n  });                                                                                                         // 146  // 1350\n                                                                                                              // 147  // 1351\n  return andDocumentMatchers(docMatchers);                                                                    // 148  // 1352\n};                                                                                                            // 149  // 1353\n                                                                                                              // 150  // 1354\n// Takes in a selector that could match a key-indexed value in a document; eg,                                // 151  // 1355\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to                                // 152  // 1356\n// indicate equality).  Returns a branched matcher: a function mapping                                        // 153  // 1357\n// [branched value]->result object.                                                                           // 154  // 1358\nvar compileValueSelector = function (valueSelector, matcher, isRoot) {                                        // 155  // 1359\n  if (valueSelector instanceof RegExp) {                                                                      // 156  // 1360\n    matcher._isSimple = false;                                                                                // 157  // 1361\n    return convertElementMatcherToBranchedMatcher(                                                            // 158  // 1362\n      regexpElementMatcher(valueSelector));                                                                   // 159  // 1363\n  } else if (isOperatorObject(valueSelector)) {                                                               // 160  // 1364\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);                                           // 161  // 1365\n  } else {                                                                                                    // 162  // 1366\n    return convertElementMatcherToBranchedMatcher(                                                            // 163  // 1367\n      equalityElementMatcher(valueSelector));                                                                 // 164  // 1368\n  }                                                                                                           // 165  // 1369\n};                                                                                                            // 166  // 1370\n                                                                                                              // 167  // 1371\n// Given an element matcher (which evaluates a single value), returns a branched                              // 168  // 1372\n// value (which evaluates the element matcher on all the branches and returns a                               // 169  // 1373\n// more structured return value possibly including arrayIndices).                                             // 170  // 1374\nvar convertElementMatcherToBranchedMatcher = function (                                                       // 171  // 1375\n    elementMatcher, options) {                                                                                // 172  // 1376\n  options = options || {};                                                                                    // 173  // 1377\n  return function (branches) {                                                                                // 174  // 1378\n    var expanded = branches;                                                                                  // 175  // 1379\n    if (!options.dontExpandLeafArrays) {                                                                      // 176  // 1380\n      expanded = expandArraysInBranches(                                                                      // 177  // 1381\n        branches, options.dontIncludeLeafArrays);                                                             // 178  // 1382\n    }                                                                                                         // 179  // 1383\n    var ret = {};                                                                                             // 180  // 1384\n    ret.result = _.any(expanded, function (element) {                                                         // 181  // 1385\n      var matched = elementMatcher(element.value);                                                            // 182  // 1386\n                                                                                                              // 183  // 1387\n      // Special case for $elemMatch: it means \"true, and use this as an array                                // 184  // 1388\n      // index if I didn't already have one\".                                                                 // 185  // 1389\n      if (typeof matched === 'number') {                                                                      // 186  // 1390\n        // XXX This code dates from when we only stored a single array index                                  // 187  // 1391\n        // (for the outermost array). Should we be also including deeper array                                // 188  // 1392\n        // indices from the $elemMatch match?                                                                 // 189  // 1393\n        if (!element.arrayIndices)                                                                            // 190  // 1394\n          element.arrayIndices = [matched];                                                                   // 191  // 1395\n        matched = true;                                                                                       // 192  // 1396\n      }                                                                                                       // 193  // 1397\n                                                                                                              // 194  // 1398\n      // If some element matched, and it's tagged with array indices, include                                 // 195  // 1399\n      // those indices in our result object.                                                                  // 196  // 1400\n      if (matched && element.arrayIndices)                                                                    // 197  // 1401\n        ret.arrayIndices = element.arrayIndices;                                                              // 198  // 1402\n                                                                                                              // 199  // 1403\n      return matched;                                                                                         // 200  // 1404\n    });                                                                                                       // 201  // 1405\n    return ret;                                                                                               // 202  // 1406\n  };                                                                                                          // 203  // 1407\n};                                                                                                            // 204  // 1408\n                                                                                                              // 205  // 1409\n// Takes a RegExp object and returns an element matcher.                                                      // 206  // 1410\nregexpElementMatcher = function (regexp) {                                                                    // 207  // 1411\n  return function (value) {                                                                                   // 208  // 1412\n    if (value instanceof RegExp) {                                                                            // 209  // 1413\n      // Comparing two regexps means seeing if the regexps are identical                                      // 210  // 1414\n      // (really!). Underscore knows how.                                                                     // 211  // 1415\n      return _.isEqual(value, regexp);                                                                        // 212  // 1416\n    }                                                                                                         // 213  // 1417\n    // Regexps only work against strings.                                                                     // 214  // 1418\n    if (typeof value !== 'string')                                                                            // 215  // 1419\n      return false;                                                                                           // 216  // 1420\n                                                                                                              // 217  // 1421\n    // Reset regexp's state to avoid inconsistent matching for objects with the                               // 218  // 1422\n    // same value on consecutive calls of regexp.test. This happens only if the                               // 219  // 1423\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for                              // 220  // 1424\n    // which we should *not* change the lastIndex but MongoDB doesn't support                                 // 221  // 1425\n    // either of these flags.                                                                                 // 222  // 1426\n    regexp.lastIndex = 0;                                                                                     // 223  // 1427\n                                                                                                              // 224  // 1428\n    return regexp.test(value);                                                                                // 225  // 1429\n  };                                                                                                          // 226  // 1430\n};                                                                                                            // 227  // 1431\n                                                                                                              // 228  // 1432\n// Takes something that is not an operator object and returns an element matcher                              // 229  // 1433\n// for equality with that thing.                                                                              // 230  // 1434\nequalityElementMatcher = function (elementSelector) {                                                         // 231  // 1435\n  if (isOperatorObject(elementSelector))                                                                      // 232  // 1436\n    throw Error(\"Can't create equalityValueSelector for operator object\");                                    // 233  // 1437\n                                                                                                              // 234  // 1438\n  // Special-case: null and undefined are equal (if you got undefined in there                                // 235  // 1439\n  // somewhere, or if you got it due to some branch being non-existent in the                                 // 236  // 1440\n  // weird special case), even though they aren't with EJSON.equals.                                          // 237  // 1441\n  if (elementSelector == null) {  // undefined or null                                                        // 238  // 1442\n    return function (value) {                                                                                 // 239  // 1443\n      return value == null;  // undefined or null                                                             // 240  // 1444\n    };                                                                                                        // 241  // 1445\n  }                                                                                                           // 242  // 1446\n                                                                                                              // 243  // 1447\n  return function (value) {                                                                                   // 244  // 1448\n    return LocalCollection._f._equal(elementSelector, value);                                                 // 245  // 1449\n  };                                                                                                          // 246  // 1450\n};                                                                                                            // 247  // 1451\n                                                                                                              // 248  // 1452\n// Takes an operator object (an object with $ keys) and returns a branched                                    // 249  // 1453\n// matcher for it.                                                                                            // 250  // 1454\nvar operatorBranchedMatcher = function (valueSelector, matcher, isRoot) {                                     // 251  // 1455\n  // Each valueSelector works separately on the various branches.  So one                                     // 252  // 1456\n  // operator can match one branch and another can match another branch.  This                                // 253  // 1457\n  // is OK.                                                                                                   // 254  // 1458\n                                                                                                              // 255  // 1459\n  var operatorMatchers = [];                                                                                  // 256  // 1460\n  _.each(valueSelector, function (operand, operator) {                                                        // 257  // 1461\n    // XXX we should actually implement $eq, which is new in 2.6                                              // 258  // 1462\n    var simpleRange = _.contains(['$lt', '$lte', '$gt', '$gte'], operator) &&                                 // 259  // 1463\n      _.isNumber(operand);                                                                                    // 260  // 1464\n    var simpleInequality = operator === '$ne' && !_.isObject(operand);                                        // 261  // 1465\n    var simpleInclusion = _.contains(['$in', '$nin'], operator) &&                                            // 262  // 1466\n      _.isArray(operand) && !_.any(operand, _.isObject);                                                      // 263  // 1467\n                                                                                                              // 264  // 1468\n    if (! (operator === '$eq' || simpleRange ||                                                               // 265  // 1469\n           simpleInclusion || simpleInequality)) {                                                            // 266  // 1470\n      matcher._isSimple = false;                                                                              // 267  // 1471\n    }                                                                                                         // 268  // 1472\n                                                                                                              // 269  // 1473\n    if (_.has(VALUE_OPERATORS, operator)) {                                                                   // 270  // 1474\n      operatorMatchers.push(                                                                                  // 271  // 1475\n        VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));                                  // 272  // 1476\n    } else if (_.has(ELEMENT_OPERATORS, operator)) {                                                          // 273  // 1477\n      var options = ELEMENT_OPERATORS[operator];                                                              // 274  // 1478\n      operatorMatchers.push(                                                                                  // 275  // 1479\n        convertElementMatcherToBranchedMatcher(                                                               // 276  // 1480\n          options.compileElementSelector(                                                                     // 277  // 1481\n            operand, valueSelector, matcher),                                                                 // 278  // 1482\n          options));                                                                                          // 279  // 1483\n    } else {                                                                                                  // 280  // 1484\n      throw new Error(\"Unrecognized operator: \" + operator);                                                  // 281  // 1485\n    }                                                                                                         // 282  // 1486\n  });                                                                                                         // 283  // 1487\n                                                                                                              // 284  // 1488\n  return andBranchedMatchers(operatorMatchers);                                                               // 285  // 1489\n};                                                                                                            // 286  // 1490\n                                                                                                              // 287  // 1491\nvar compileArrayOfDocumentSelectors = function (                                                              // 288  // 1492\n    selectors, matcher, inElemMatch) {                                                                        // 289  // 1493\n  if (!isArray(selectors) || _.isEmpty(selectors))                                                            // 290  // 1494\n    throw Error(\"$and/$or/$nor must be nonempty array\");                                                      // 291  // 1495\n  return _.map(selectors, function (subSelector) {                                                            // 292  // 1496\n    if (!isPlainObject(subSelector))                                                                          // 293  // 1497\n      throw Error(\"$or/$and/$nor entries need to be full objects\");                                           // 294  // 1498\n    return compileDocumentSelector(                                                                           // 295  // 1499\n      subSelector, matcher, {inElemMatch: inElemMatch});                                                      // 296  // 1500\n  });                                                                                                         // 297  // 1501\n};                                                                                                            // 298  // 1502\n                                                                                                              // 299  // 1503\n// Operators that appear at the top level of a document selector.                                             // 300  // 1504\nvar LOGICAL_OPERATORS = {                                                                                     // 301  // 1505\n  $and: function (subSelector, matcher, inElemMatch) {                                                        // 302  // 1506\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 303  // 1507\n      subSelector, matcher, inElemMatch);                                                                     // 304  // 1508\n    return andDocumentMatchers(matchers);                                                                     // 305  // 1509\n  },                                                                                                          // 306  // 1510\n                                                                                                              // 307  // 1511\n  $or: function (subSelector, matcher, inElemMatch) {                                                         // 308  // 1512\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 309  // 1513\n      subSelector, matcher, inElemMatch);                                                                     // 310  // 1514\n                                                                                                              // 311  // 1515\n    // Special case: if there is only one matcher, use it directly, *preserving*                              // 312  // 1516\n    // any arrayIndices it returns.                                                                           // 313  // 1517\n    if (matchers.length === 1)                                                                                // 314  // 1518\n      return matchers[0];                                                                                     // 315  // 1519\n                                                                                                              // 316  // 1520\n    return function (doc) {                                                                                   // 317  // 1521\n      var result = _.any(matchers, function (f) {                                                             // 318  // 1522\n        return f(doc).result;                                                                                 // 319  // 1523\n      });                                                                                                     // 320  // 1524\n      // $or does NOT set arrayIndices when it has multiple                                                   // 321  // 1525\n      // sub-expressions. (Tested against MongoDB.)                                                           // 322  // 1526\n      return {result: result};                                                                                // 323  // 1527\n    };                                                                                                        // 324  // 1528\n  },                                                                                                          // 325  // 1529\n                                                                                                              // 326  // 1530\n  $nor: function (subSelector, matcher, inElemMatch) {                                                        // 327  // 1531\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 328  // 1532\n      subSelector, matcher, inElemMatch);                                                                     // 329  // 1533\n    return function (doc) {                                                                                   // 330  // 1534\n      var result = _.all(matchers, function (f) {                                                             // 331  // 1535\n        return !f(doc).result;                                                                                // 332  // 1536\n      });                                                                                                     // 333  // 1537\n      // Never set arrayIndices, because we only match if nothing in particular                               // 334  // 1538\n      // \"matched\" (and because this is consistent with MongoDB).                                             // 335  // 1539\n      return {result: result};                                                                                // 336  // 1540\n    };                                                                                                        // 337  // 1541\n  },                                                                                                          // 338  // 1542\n                                                                                                              // 339  // 1543\n  $where: function (selectorValue, matcher) {                                                                 // 340  // 1544\n    // Record that *any* path may be used.                                                                    // 341  // 1545\n    matcher._recordPathUsed('');                                                                              // 342  // 1546\n    matcher._hasWhere = true;                                                                                 // 343  // 1547\n    if (!(selectorValue instanceof Function)) {                                                               // 344  // 1548\n      // XXX MongoDB seems to have more complex logic to decide where or or not                               // 345  // 1549\n      // to add \"return\"; not sure exactly what it is.                                                        // 346  // 1550\n      selectorValue = Function(\"obj\", \"return \" + selectorValue);                                             // 347  // 1551\n    }                                                                                                         // 348  // 1552\n    return function (doc) {                                                                                   // 349  // 1553\n      // We make the document available as both `this` and `obj`.                                             // 350  // 1554\n      // XXX not sure what we should do if this throws                                                        // 351  // 1555\n      return {result: selectorValue.call(doc, doc)};                                                          // 352  // 1556\n    };                                                                                                        // 353  // 1557\n  },                                                                                                          // 354  // 1558\n                                                                                                              // 355  // 1559\n  // This is just used as a comment in the query (in MongoDB, it also ends up in                              // 356  // 1560\n  // query logs); it has no effect on the actual selection.                                                   // 357  // 1561\n  $comment: function () {                                                                                     // 358  // 1562\n    return function () {                                                                                      // 359  // 1563\n      return {result: true};                                                                                  // 360  // 1564\n    };                                                                                                        // 361  // 1565\n  }                                                                                                           // 362  // 1566\n};                                                                                                            // 363  // 1567\n                                                                                                              // 364  // 1568\n// Returns a branched matcher that matches iff the given matcher does not.                                    // 365  // 1569\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it                                     // 366  // 1570\n// means that ALL branch values need to fail to match innerBranchedMatcher.                                   // 367  // 1571\nvar invertBranchedMatcher = function (branchedMatcher) {                                                      // 368  // 1572\n  return function (branchValues) {                                                                            // 369  // 1573\n    var invertMe = branchedMatcher(branchValues);                                                             // 370  // 1574\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to                              // 371  // 1575\n    // say \"update the array element that does not match something\", at least                                 // 372  // 1576\n    // in mongo-land.                                                                                         // 373  // 1577\n    return {result: !invertMe.result};                                                                        // 374  // 1578\n  };                                                                                                          // 375  // 1579\n};                                                                                                            // 376  // 1580\n                                                                                                              // 377  // 1581\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a                                 // 378  // 1582\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as                                // 379  // 1583\n// \"match each branched value independently and combine with                                                  // 380  // 1584\n// convertElementMatcherToBranchedMatcher\".                                                                   // 381  // 1585\nvar VALUE_OPERATORS = {                                                                                       // 382  // 1586\n  $not: function (operand, valueSelector, matcher) {                                                          // 383  // 1587\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));                                     // 384  // 1588\n  },                                                                                                          // 385  // 1589\n  $ne: function (operand) {                                                                                   // 386  // 1590\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                      // 387  // 1591\n      equalityElementMatcher(operand)));                                                                      // 388  // 1592\n  },                                                                                                          // 389  // 1593\n  $nin: function (operand) {                                                                                  // 390  // 1594\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                      // 391  // 1595\n      ELEMENT_OPERATORS.$in.compileElementSelector(operand)));                                                // 392  // 1596\n  },                                                                                                          // 393  // 1597\n  $exists: function (operand) {                                                                               // 394  // 1598\n    var exists = convertElementMatcherToBranchedMatcher(function (value) {                                    // 395  // 1599\n      return value !== undefined;                                                                             // 396  // 1600\n    });                                                                                                       // 397  // 1601\n    return operand ? exists : invertBranchedMatcher(exists);                                                  // 398  // 1602\n  },                                                                                                          // 399  // 1603\n  // $options just provides options for $regex; its logic is inside $regex                                    // 400  // 1604\n  $options: function (operand, valueSelector) {                                                               // 401  // 1605\n    if (!_.has(valueSelector, '$regex'))                                                                      // 402  // 1606\n      throw Error(\"$options needs a $regex\");                                                                 // 403  // 1607\n    return everythingMatcher;                                                                                 // 404  // 1608\n  },                                                                                                          // 405  // 1609\n  // $maxDistance is basically an argument to $near                                                           // 406  // 1610\n  $maxDistance: function (operand, valueSelector) {                                                           // 407  // 1611\n    if (!valueSelector.$near)                                                                                 // 408  // 1612\n      throw Error(\"$maxDistance needs a $near\");                                                              // 409  // 1613\n    return everythingMatcher;                                                                                 // 410  // 1614\n  },                                                                                                          // 411  // 1615\n  $all: function (operand, valueSelector, matcher) {                                                          // 412  // 1616\n    if (!isArray(operand))                                                                                    // 413  // 1617\n      throw Error(\"$all requires array\");                                                                     // 414  // 1618\n    // Not sure why, but this seems to be what MongoDB does.                                                  // 415  // 1619\n    if (_.isEmpty(operand))                                                                                   // 416  // 1620\n      return nothingMatcher;                                                                                  // 417  // 1621\n                                                                                                              // 418  // 1622\n    var branchedMatchers = [];                                                                                // 419  // 1623\n    _.each(operand, function (criterion) {                                                                    // 420  // 1624\n      // XXX handle $all/$elemMatch combination                                                               // 421  // 1625\n      if (isOperatorObject(criterion))                                                                        // 422  // 1626\n        throw Error(\"no $ expressions in $all\");                                                              // 423  // 1627\n      // This is always a regexp or equality selector.                                                        // 424  // 1628\n      branchedMatchers.push(compileValueSelector(criterion, matcher));                                        // 425  // 1629\n    });                                                                                                       // 426  // 1630\n    // andBranchedMatchers does NOT require all selectors to return true on the                               // 427  // 1631\n    // SAME branch.                                                                                           // 428  // 1632\n    return andBranchedMatchers(branchedMatchers);                                                             // 429  // 1633\n  },                                                                                                          // 430  // 1634\n  $near: function (operand, valueSelector, matcher, isRoot) {                                                 // 431  // 1635\n    if (!isRoot)                                                                                              // 432  // 1636\n      throw Error(\"$near can't be inside another $ operator\");                                                // 433  // 1637\n    matcher._hasGeoQuery = true;                                                                              // 434  // 1638\n                                                                                                              // 435  // 1639\n    // There are two kinds of geodata in MongoDB: coordinate pairs and                                        // 436  // 1640\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are                                 // 437  // 1641\n    // marked with a $geometry property.                                                                      // 438  // 1642\n                                                                                                              // 439  // 1643\n    var maxDistance, point, distance;                                                                         // 440  // 1644\n    if (isPlainObject(operand) && _.has(operand, '$geometry')) {                                              // 441  // 1645\n      // GeoJSON \"2dsphere\" mode.                                                                             // 442  // 1646\n      maxDistance = operand.$maxDistance;                                                                     // 443  // 1647\n      point = operand.$geometry;                                                                              // 444  // 1648\n      distance = function (value) {                                                                           // 445  // 1649\n        // XXX: for now, we don't calculate the actual distance between, say,                                 // 446  // 1650\n        // polygon and circle. If people care about this use-case it will get                                 // 447  // 1651\n        // a priority.                                                                                        // 448  // 1652\n        if (!value || !value.type)                                                                            // 449  // 1653\n          return null;                                                                                        // 450  // 1654\n        if (value.type === \"Point\") {                                                                         // 451  // 1655\n          return GeoJSON.pointDistance(point, value);                                                         // 452  // 1656\n        } else {                                                                                              // 453  // 1657\n          return GeoJSON.geometryWithinRadius(value, point, maxDistance)                                      // 454  // 1658\n            ? 0 : maxDistance + 1;                                                                            // 455  // 1659\n        }                                                                                                     // 456  // 1660\n      };                                                                                                      // 457  // 1661\n    } else {                                                                                                  // 458  // 1662\n      maxDistance = valueSelector.$maxDistance;                                                               // 459  // 1663\n      if (!isArray(operand) && !isPlainObject(operand))                                                       // 460  // 1664\n        throw Error(\"$near argument must be coordinate pair or GeoJSON\");                                     // 461  // 1665\n      point = pointToArray(operand);                                                                          // 462  // 1666\n      distance = function (value) {                                                                           // 463  // 1667\n        if (!isArray(value) && !isPlainObject(value))                                                         // 464  // 1668\n          return null;                                                                                        // 465  // 1669\n        return distanceCoordinatePairs(point, value);                                                         // 466  // 1670\n      };                                                                                                      // 467  // 1671\n    }                                                                                                         // 468  // 1672\n                                                                                                              // 469  // 1673\n    return function (branchedValues) {                                                                        // 470  // 1674\n      // There might be multiple points in the document that match the given                                  // 471  // 1675\n      // field. Only one of them needs to be within $maxDistance, but we need to                              // 472  // 1676\n      // evaluate all of them and use the nearest one for the implicit sort                                   // 473  // 1677\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)                                    // 474  // 1678\n      //                                                                                                      // 475  // 1679\n      // Note: This differs from MongoDB's implementation, where a document will                              // 476  // 1680\n      // actually show up *multiple times* in the result set, with one entry for                              // 477  // 1681\n      // each within-$maxDistance branching point.                                                            // 478  // 1682\n      branchedValues = expandArraysInBranches(branchedValues);                                                // 479  // 1683\n      var result = {result: false};                                                                           // 480  // 1684\n      _.each(branchedValues, function (branch) {                                                              // 481  // 1685\n        var curDistance = distance(branch.value);                                                             // 482  // 1686\n        // Skip branches that aren't real points or are too far away.                                         // 483  // 1687\n        if (curDistance === null || curDistance > maxDistance)                                                // 484  // 1688\n          return;                                                                                             // 485  // 1689\n        // Skip anything that's a tie.                                                                        // 486  // 1690\n        if (result.distance !== undefined && result.distance <= curDistance)                                  // 487  // 1691\n          return;                                                                                             // 488  // 1692\n        result.result = true;                                                                                 // 489  // 1693\n        result.distance = curDistance;                                                                        // 490  // 1694\n        if (!branch.arrayIndices)                                                                             // 491  // 1695\n          delete result.arrayIndices;                                                                         // 492  // 1696\n        else                                                                                                  // 493  // 1697\n          result.arrayIndices = branch.arrayIndices;                                                          // 494  // 1698\n      });                                                                                                     // 495  // 1699\n      return result;                                                                                          // 496  // 1700\n    };                                                                                                        // 497  // 1701\n  }                                                                                                           // 498  // 1702\n};                                                                                                            // 499  // 1703\n                                                                                                              // 500  // 1704\n// Helpers for $near.                                                                                         // 501  // 1705\nvar distanceCoordinatePairs = function (a, b) {                                                               // 502  // 1706\n  a = pointToArray(a);                                                                                        // 503  // 1707\n  b = pointToArray(b);                                                                                        // 504  // 1708\n  var x = a[0] - b[0];                                                                                        // 505  // 1709\n  var y = a[1] - b[1];                                                                                        // 506  // 1710\n  if (_.isNaN(x) || _.isNaN(y))                                                                               // 507  // 1711\n    return null;                                                                                              // 508  // 1712\n  return Math.sqrt(x * x + y * y);                                                                            // 509  // 1713\n};                                                                                                            // 510  // 1714\n// Makes sure we get 2 elements array and assume the first one to be x and                                    // 511  // 1715\n// the second one to y no matter what user passes.                                                            // 512  // 1716\n// In case user passes { lon: x, lat: y } returns [x, y]                                                      // 513  // 1717\nvar pointToArray = function (point) {                                                                         // 514  // 1718\n  return _.map(point, _.identity);                                                                            // 515  // 1719\n};                                                                                                            // 516  // 1720\n                                                                                                              // 517  // 1721\n// Helper for $lt/$gt/$lte/$gte.                                                                              // 518  // 1722\nvar makeInequality = function (cmpValueComparator) {                                                          // 519  // 1723\n  return {                                                                                                    // 520  // 1724\n    compileElementSelector: function (operand) {                                                              // 521  // 1725\n      // Arrays never compare false with non-arrays for any inequality.                                       // 522  // 1726\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but                                    // 523  // 1727\n      //     it seems to have been reverted.                                                                  // 524  // 1728\n      //     See https://jira.mongodb.org/browse/SERVER-11444                                                 // 525  // 1729\n      if (isArray(operand)) {                                                                                 // 526  // 1730\n        return function () {                                                                                  // 527  // 1731\n          return false;                                                                                       // 528  // 1732\n        };                                                                                                    // 529  // 1733\n      }                                                                                                       // 530  // 1734\n                                                                                                              // 531  // 1735\n      // Special case: consider undefined and null the same (so true with                                     // 532  // 1736\n      // $gte/$lte).                                                                                          // 533  // 1737\n      if (operand === undefined)                                                                              // 534  // 1738\n        operand = null;                                                                                       // 535  // 1739\n                                                                                                              // 536  // 1740\n      var operandType = LocalCollection._f._type(operand);                                                    // 537  // 1741\n                                                                                                              // 538  // 1742\n      return function (value) {                                                                               // 539  // 1743\n        if (value === undefined)                                                                              // 540  // 1744\n          value = null;                                                                                       // 541  // 1745\n        // Comparisons are never true among things of different type (except                                  // 542  // 1746\n        // null vs undefined).                                                                                // 543  // 1747\n        if (LocalCollection._f._type(value) !== operandType)                                                  // 544  // 1748\n          return false;                                                                                       // 545  // 1749\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));                                   // 546  // 1750\n      };                                                                                                      // 547  // 1751\n    }                                                                                                         // 548  // 1752\n  };                                                                                                          // 549  // 1753\n};                                                                                                            // 550  // 1754\n                                                                                                              // 551  // 1755\n// Each element selector contains:                                                                            // 552  // 1756\n//  - compileElementSelector, a function with args:                                                           // 553  // 1757\n//    - operand - the \"right hand side\" of the operator                                                       // 554  // 1758\n//    - valueSelector - the \"context\" for the operator (so that $regex can find                               // 555  // 1759\n//      $options)                                                                                             // 556  // 1760\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile                              // 557  // 1761\n//      more things)                                                                                          // 558  // 1762\n//    returning a function mapping a single value to bool.                                                    // 559  // 1763\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from                                 // 560  // 1764\n//    being called                                                                                            // 561  // 1765\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to                                  // 562  // 1766\n//    expandArraysInBranches if it is called                                                                  // 563  // 1767\nELEMENT_OPERATORS = {                                                                                         // 564  // 1768\n  $lt: makeInequality(function (cmpValue) {                                                                   // 565  // 1769\n    return cmpValue < 0;                                                                                      // 566  // 1770\n  }),                                                                                                         // 567  // 1771\n  $gt: makeInequality(function (cmpValue) {                                                                   // 568  // 1772\n    return cmpValue > 0;                                                                                      // 569  // 1773\n  }),                                                                                                         // 570  // 1774\n  $lte: makeInequality(function (cmpValue) {                                                                  // 571  // 1775\n    return cmpValue <= 0;                                                                                     // 572  // 1776\n  }),                                                                                                         // 573  // 1777\n  $gte: makeInequality(function (cmpValue) {                                                                  // 574  // 1778\n    return cmpValue >= 0;                                                                                     // 575  // 1779\n  }),                                                                                                         // 576  // 1780\n  $mod: {                                                                                                     // 577  // 1781\n    compileElementSelector: function (operand) {                                                              // 578  // 1782\n      if (!(isArray(operand) && operand.length === 2                                                          // 579  // 1783\n            && typeof(operand[0]) === 'number'                                                                // 580  // 1784\n            && typeof(operand[1]) === 'number')) {                                                            // 581  // 1785\n        throw Error(\"argument to $mod must be an array of two numbers\");                                      // 582  // 1786\n      }                                                                                                       // 583  // 1787\n      // XXX could require to be ints or round or something                                                   // 584  // 1788\n      var divisor = operand[0];                                                                               // 585  // 1789\n      var remainder = operand[1];                                                                             // 586  // 1790\n      return function (value) {                                                                               // 587  // 1791\n        return typeof value === 'number' && value % divisor === remainder;                                    // 588  // 1792\n      };                                                                                                      // 589  // 1793\n    }                                                                                                         // 590  // 1794\n  },                                                                                                          // 591  // 1795\n  $in: {                                                                                                      // 592  // 1796\n    compileElementSelector: function (operand) {                                                              // 593  // 1797\n      if (!isArray(operand))                                                                                  // 594  // 1798\n        throw Error(\"$in needs an array\");                                                                    // 595  // 1799\n                                                                                                              // 596  // 1800\n      var elementMatchers = [];                                                                               // 597  // 1801\n      _.each(operand, function (option) {                                                                     // 598  // 1802\n        if (option instanceof RegExp)                                                                         // 599  // 1803\n          elementMatchers.push(regexpElementMatcher(option));                                                 // 600  // 1804\n        else if (isOperatorObject(option))                                                                    // 601  // 1805\n          throw Error(\"cannot nest $ under $in\");                                                             // 602  // 1806\n        else                                                                                                  // 603  // 1807\n          elementMatchers.push(equalityElementMatcher(option));                                               // 604  // 1808\n      });                                                                                                     // 605  // 1809\n                                                                                                              // 606  // 1810\n      return function (value) {                                                                               // 607  // 1811\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.                                         // 608  // 1812\n        if (value === undefined)                                                                              // 609  // 1813\n          value = null;                                                                                       // 610  // 1814\n        return _.any(elementMatchers, function (e) {                                                          // 611  // 1815\n          return e(value);                                                                                    // 612  // 1816\n        });                                                                                                   // 613  // 1817\n      };                                                                                                      // 614  // 1818\n    }                                                                                                         // 615  // 1819\n  },                                                                                                          // 616  // 1820\n  $size: {                                                                                                    // 617  // 1821\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we                                // 618  // 1822\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a                                // 619  // 1823\n    // possible value.                                                                                        // 620  // 1824\n    dontExpandLeafArrays: true,                                                                               // 621  // 1825\n    compileElementSelector: function (operand) {                                                              // 622  // 1826\n      if (typeof operand === 'string') {                                                                      // 623  // 1827\n        // Don't ask me why, but by experimentation, this seems to be what Mongo                              // 624  // 1828\n        // does.                                                                                              // 625  // 1829\n        operand = 0;                                                                                          // 626  // 1830\n      } else if (typeof operand !== 'number') {                                                               // 627  // 1831\n        throw Error(\"$size needs a number\");                                                                  // 628  // 1832\n      }                                                                                                       // 629  // 1833\n      return function (value) {                                                                               // 630  // 1834\n        return isArray(value) && value.length === operand;                                                    // 631  // 1835\n      };                                                                                                      // 632  // 1836\n    }                                                                                                         // 633  // 1837\n  },                                                                                                          // 634  // 1838\n  $type: {                                                                                                    // 635  // 1839\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should                                 // 636  // 1840\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:                                 // 637  // 1841\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but                                 // 638  // 1842\n    // should *not* include it itself.                                                                        // 639  // 1843\n    dontIncludeLeafArrays: true,                                                                              // 640  // 1844\n    compileElementSelector: function (operand) {                                                              // 641  // 1845\n      if (typeof operand !== 'number')                                                                        // 642  // 1846\n        throw Error(\"$type needs a number\");                                                                  // 643  // 1847\n      return function (value) {                                                                               // 644  // 1848\n        return value !== undefined                                                                            // 645  // 1849\n          && LocalCollection._f._type(value) === operand;                                                     // 646  // 1850\n      };                                                                                                      // 647  // 1851\n    }                                                                                                         // 648  // 1852\n  },                                                                                                          // 649  // 1853\n  $regex: {                                                                                                   // 650  // 1854\n    compileElementSelector: function (operand, valueSelector) {                                               // 651  // 1855\n      if (!(typeof operand === 'string' || operand instanceof RegExp))                                        // 652  // 1856\n        throw Error(\"$regex has to be a string or RegExp\");                                                   // 653  // 1857\n                                                                                                              // 654  // 1858\n      var regexp;                                                                                             // 655  // 1859\n      if (valueSelector.$options !== undefined) {                                                             // 656  // 1860\n        // Options passed in $options (even the empty string) always overrides                                // 657  // 1861\n        // options in the RegExp object itself. (See also                                                     // 658  // 1862\n        // Mongo.Collection._rewriteSelector.)                                                                // 659  // 1863\n                                                                                                              // 660  // 1864\n        // Be clear that we only support the JS-supported options, not extended                               // 661  // 1865\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s                              // 662  // 1866\n        // by transforming the regexp, but not today...                                                       // 663  // 1867\n        if (/[^gim]/.test(valueSelector.$options))                                                            // 664  // 1868\n          throw new Error(\"Only the i, m, and g regexp options are supported\");                               // 665  // 1869\n                                                                                                              // 666  // 1870\n        var regexSource = operand instanceof RegExp ? operand.source : operand;                               // 667  // 1871\n        regexp = new RegExp(regexSource, valueSelector.$options);                                             // 668  // 1872\n      } else if (operand instanceof RegExp) {                                                                 // 669  // 1873\n        regexp = operand;                                                                                     // 670  // 1874\n      } else {                                                                                                // 671  // 1875\n        regexp = new RegExp(operand);                                                                         // 672  // 1876\n      }                                                                                                       // 673  // 1877\n      return regexpElementMatcher(regexp);                                                                    // 674  // 1878\n    }                                                                                                         // 675  // 1879\n  },                                                                                                          // 676  // 1880\n  $elemMatch: {                                                                                               // 677  // 1881\n    dontExpandLeafArrays: true,                                                                               // 678  // 1882\n    compileElementSelector: function (operand, valueSelector, matcher) {                                      // 679  // 1883\n      if (!isPlainObject(operand))                                                                            // 680  // 1884\n        throw Error(\"$elemMatch need an object\");                                                             // 681  // 1885\n                                                                                                              // 682  // 1886\n      var subMatcher, isDocMatcher;                                                                           // 683  // 1887\n      if (isOperatorObject(operand, true)) {                                                                  // 684  // 1888\n        subMatcher = compileValueSelector(operand, matcher);                                                  // 685  // 1889\n        isDocMatcher = false;                                                                                 // 686  // 1890\n      } else {                                                                                                // 687  // 1891\n        // This is NOT the same as compileValueSelector(operand), and not just                                // 688  // 1892\n        // because of the slightly different calling convention.                                              // 689  // 1893\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not                                       // 690  // 1894\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.                               // 691  // 1895\n        subMatcher = compileDocumentSelector(operand, matcher,                                                // 692  // 1896\n                                             {inElemMatch: true});                                            // 693  // 1897\n        isDocMatcher = true;                                                                                  // 694  // 1898\n      }                                                                                                       // 695  // 1899\n                                                                                                              // 696  // 1900\n      return function (value) {                                                                               // 697  // 1901\n        if (!isArray(value))                                                                                  // 698  // 1902\n          return false;                                                                                       // 699  // 1903\n        for (var i = 0; i < value.length; ++i) {                                                              // 700  // 1904\n          var arrayElement = value[i];                                                                        // 701  // 1905\n          var arg;                                                                                            // 702  // 1906\n          if (isDocMatcher) {                                                                                 // 703  // 1907\n            // We can only match {$elemMatch: {b: 3}} against objects.                                        // 704  // 1908\n            // (We can also match against arrays, if there's numeric indices,                                 // 705  // 1909\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)                                          // 706  // 1910\n            if (!isPlainObject(arrayElement) && !isArray(arrayElement))                                       // 707  // 1911\n              return false;                                                                                   // 708  // 1912\n            arg = arrayElement;                                                                               // 709  // 1913\n          } else {                                                                                            // 710  // 1914\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches                                   // 711  // 1915\n            // {a: [8]} but not {a: [[8]]}                                                                    // 712  // 1916\n            arg = [{value: arrayElement, dontIterate: true}];                                                 // 713  // 1917\n          }                                                                                                   // 714  // 1918\n          // XXX support $near in $elemMatch by propagating $distance?                                        // 715  // 1919\n          if (subMatcher(arg).result)                                                                         // 716  // 1920\n            return i;   // specially understood to mean \"use as arrayIndices\"                                 // 717  // 1921\n        }                                                                                                     // 718  // 1922\n        return false;                                                                                         // 719  // 1923\n      };                                                                                                      // 720  // 1924\n    }                                                                                                         // 721  // 1925\n  }                                                                                                           // 722  // 1926\n};                                                                                                            // 723  // 1927\n                                                                                                              // 724  // 1928\n// makeLookupFunction(key) returns a lookup function.                                                         // 725  // 1929\n//                                                                                                            // 726  // 1930\n// A lookup function takes in a document and returns an array of matching                                     // 727  // 1931\n// branches.  If no arrays are found while looking up the key, this array will                                // 728  // 1932\n// have exactly one branches (possibly 'undefined', if some segment of the key                                // 729  // 1933\n// was not found).                                                                                            // 730  // 1934\n//                                                                                                            // 731  // 1935\n// If arrays are found in the middle, this can have more than one element, since                              // 732  // 1936\n// we \"branch\". When we \"branch\", if there are more key segments to look up,                                  // 733  // 1937\n// then we only pursue branches that are plain objects (not arrays or scalars).                               // 734  // 1938\n// This means we can actually end up with no branches!                                                        // 735  // 1939\n//                                                                                                            // 736  // 1940\n// We do *NOT* branch on arrays that are found at the end (ie, at the last                                    // 737  // 1941\n// dotted member of the key). We just return that array; if you want to                                       // 738  // 1942\n// effectively \"branch\" over the array's values, post-process the lookup                                      // 739  // 1943\n// function with expandArraysInBranches.                                                                      // 740  // 1944\n//                                                                                                            // 741  // 1945\n// Each branch is an object with keys:                                                                        // 742  // 1946\n//  - value: the value at the branch                                                                          // 743  // 1947\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array                               // 744  // 1948\n//    that expandArraysInBranches should NOT expand. This specifically happens                                // 745  // 1949\n//    when there is a numeric index in the key, and ensures the                                               // 746  // 1950\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT                                           // 747  // 1951\n//    match {a: [[5]]}.                                                                                       // 748  // 1952\n//  - arrayIndices: if any array indexing was done during lookup (either due to                               // 749  // 1953\n//    explicit numeric indices or implicit branching), this will be an array of                               // 750  // 1954\n//    the array indices used, from outermost to innermost; it is falsey or                                    // 751  // 1955\n//    absent if no array index is used. If an explicit numeric index is used,                                 // 752  // 1956\n//    the index will be followed in arrayIndices by the string 'x'.                                           // 753  // 1957\n//                                                                                                            // 754  // 1958\n//    Note: arrayIndices is used for two purposes. First, it is used to                                       // 755  // 1959\n//    implement the '$' modifier feature, which only ever looks at its first                                  // 756  // 1960\n//    element.                                                                                                // 757  // 1961\n//                                                                                                            // 758  // 1962\n//    Second, it is used for sort key generation, which needs to be able to tell                              // 759  // 1963\n//    the difference between different paths. Moreover, it needs to                                           // 760  // 1964\n//    differentiate between explicit and implicit branching, which is why                                     // 761  // 1965\n//    there's the somewhat hacky 'x' entry: this means that explicit and                                      // 762  // 1966\n//    implicit array lookups will have different full arrayIndices paths. (That                               // 763  // 1967\n//    code only requires that different paths have different arrayIndices; it                                 // 764  // 1968\n//    doesn't actually \"parse\" arrayIndices. As an alternative, arrayIndices                                  // 765  // 1969\n//    could contain objects with flags like \"implicit\", but I think that only                                 // 766  // 1970\n//    makes the code surrounding them more complex.)                                                          // 767  // 1971\n//                                                                                                            // 768  // 1972\n//    (By the way, this field ends up getting passed around a lot without                                     // 769  // 1973\n//    cloning, so never mutate any arrayIndices field/var in this package!)                                   // 770  // 1974\n//                                                                                                            // 771  // 1975\n//                                                                                                            // 772  // 1976\n// At the top level, you may only pass in a plain object or array.                                            // 773  // 1977\n//                                                                                                            // 774  // 1978\n// See the test 'minimongo - lookup' for some examples of what lookup functions                               // 775  // 1979\n// return.                                                                                                    // 776  // 1980\nmakeLookupFunction = function (key, options) {                                                                // 777  // 1981\n  options = options || {};                                                                                    // 778  // 1982\n  var parts = key.split('.');                                                                                 // 779  // 1983\n  var firstPart = parts.length ? parts[0] : '';                                                               // 780  // 1984\n  var firstPartIsNumeric = isNumericKey(firstPart);                                                           // 781  // 1985\n  var nextPartIsNumeric = parts.length >= 2 && isNumericKey(parts[1]);                                        // 782  // 1986\n  var lookupRest;                                                                                             // 783  // 1987\n  if (parts.length > 1) {                                                                                     // 784  // 1988\n    lookupRest = makeLookupFunction(parts.slice(1).join('.'));                                                // 785  // 1989\n  }                                                                                                           // 786  // 1990\n                                                                                                              // 787  // 1991\n  var omitUnnecessaryFields = function (retVal) {                                                             // 788  // 1992\n    if (!retVal.dontIterate)                                                                                  // 789  // 1993\n      delete retVal.dontIterate;                                                                              // 790  // 1994\n    if (retVal.arrayIndices && !retVal.arrayIndices.length)                                                   // 791  // 1995\n      delete retVal.arrayIndices;                                                                             // 792  // 1996\n    return retVal;                                                                                            // 793  // 1997\n  };                                                                                                          // 794  // 1998\n                                                                                                              // 795  // 1999\n  // Doc will always be a plain object or an array.                                                           // 796  // 2000\n  // apply an explicit numeric index, an array.                                                               // 797  // 2001\n  return function (doc, arrayIndices) {                                                                       // 798  // 2002\n    if (!arrayIndices)                                                                                        // 799  // 2003\n      arrayIndices = [];                                                                                      // 800  // 2004\n                                                                                                              // 801  // 2005\n    if (isArray(doc)) {                                                                                       // 802  // 2006\n      // If we're being asked to do an invalid lookup into an array (non-integer                              // 803  // 2007\n      // or out-of-bounds), return no results (which is different from returning                              // 804  // 2008\n      // a single undefined result, in that `null` equality checks won't match).                              // 805  // 2009\n      if (!(firstPartIsNumeric && firstPart < doc.length))                                                    // 806  // 2010\n        return [];                                                                                            // 807  // 2011\n                                                                                                              // 808  // 2012\n      // Remember that we used this array index. Include an 'x' to indicate that                              // 809  // 2013\n      // the previous index came from being considered as an explicit array                                   // 810  // 2014\n      // index (not branching).                                                                               // 811  // 2015\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');                                                    // 812  // 2016\n    }                                                                                                         // 813  // 2017\n                                                                                                              // 814  // 2018\n    // Do our first lookup.                                                                                   // 815  // 2019\n    var firstLevel = doc[firstPart];                                                                          // 816  // 2020\n                                                                                                              // 817  // 2021\n    // If there is no deeper to dig, return what we found.                                                    // 818  // 2022\n    //                                                                                                        // 819  // 2023\n    // If what we found is an array, most value selectors will choose to treat                                // 820  // 2024\n    // the elements of the array as matchable values in their own right, but                                  // 821  // 2025\n    // that's done outside of the lookup function. (Exceptions to this are $size                              // 822  // 2026\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:                              // 823  // 2027\n    // [[1, 2]]}.)                                                                                            // 824  // 2028\n    //                                                                                                        // 825  // 2029\n    // That said, if we just did an *explicit* array lookup (on doc) to find                                  // 826  // 2030\n    // firstLevel, and firstLevel is an array too, we do NOT want value                                       // 827  // 2031\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.                               // 828  // 2032\n    // So in that case, we mark the return value as \"don't iterate\".                                          // 829  // 2033\n    if (!lookupRest) {                                                                                        // 830  // 2034\n      return [omitUnnecessaryFields({                                                                         // 831  // 2035\n        value: firstLevel,                                                                                    // 832  // 2036\n        dontIterate: isArray(doc) && isArray(firstLevel),                                                     // 833  // 2037\n        arrayIndices: arrayIndices})];                                                                        // 834  // 2038\n    }                                                                                                         // 835  // 2039\n                                                                                                              // 836  // 2040\n    // We need to dig deeper.  But if we can't, because what we've found is not                               // 837  // 2041\n    // an array or plain object, we're done. If we just did a numeric index into                              // 838  // 2042\n    // an array, we return nothing here (this is a change in Mongo 2.5 from                                   // 839  // 2043\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,                                // 840  // 2044\n    // return a single `undefined` (which can, for example, match via equality                                // 841  // 2045\n    // with `null`).                                                                                          // 842  // 2046\n    if (!isIndexable(firstLevel)) {                                                                           // 843  // 2047\n      if (isArray(doc))                                                                                       // 844  // 2048\n        return [];                                                                                            // 845  // 2049\n      return [omitUnnecessaryFields({value: undefined,                                                        // 846  // 2050\n                                      arrayIndices: arrayIndices})];                                          // 847  // 2051\n    }                                                                                                         // 848  // 2052\n                                                                                                              // 849  // 2053\n    var result = [];                                                                                          // 850  // 2054\n    var appendToResult = function (more) {                                                                    // 851  // 2055\n      Array.prototype.push.apply(result, more);                                                               // 852  // 2056\n    };                                                                                                        // 853  // 2057\n                                                                                                              // 854  // 2058\n    // Dig deeper: look up the rest of the parts on whatever we've found.                                     // 855  // 2059\n    // (lookupRest is smart enough to not try to do invalid lookups into                                      // 856  // 2060\n    // firstLevel if it's an array.)                                                                          // 857  // 2061\n    appendToResult(lookupRest(firstLevel, arrayIndices));                                                     // 858  // 2062\n                                                                                                              // 859  // 2063\n    // If we found an array, then in *addition* to potentially treating the next                              // 860  // 2064\n    // part as a literal integer lookup, we should also \"branch\": try to look up                              // 861  // 2065\n    // the rest of the parts on each array element in parallel.                                               // 862  // 2066\n    //                                                                                                        // 863  // 2067\n    // In this case, we *only* dig deeper into array elements that are plain                                  // 864  // 2068\n    // objects. (Recall that we only got this far if we have further to dig.)                                 // 865  // 2069\n    // This makes sense: we certainly don't dig deeper into non-indexable                                     // 866  // 2070\n    // objects. And it would be weird to dig into an array: it's simpler to have                              // 867  // 2071\n    // a rule that explicit integer indexes only apply to an outer array, not to                              // 868  // 2072\n    // an array you find after a branching search.                                                            // 869  // 2073\n    //                                                                                                        // 870  // 2074\n    // In the special case of a numeric part in a *sort selector* (not a query                                // 871  // 2075\n    // selector), we skip the branching: we ONLY allow the numeric part to mean                               // 872  // 2076\n    // \"look up this index\" in that case, not \"also look up this index in all                                 // 873  // 2077\n    // the elements of the array\".                                                                            // 874  // 2078\n    if (isArray(firstLevel) && !(nextPartIsNumeric && options.forSort)) {                                     // 875  // 2079\n      _.each(firstLevel, function (branch, arrayIndex) {                                                      // 876  // 2080\n        if (isPlainObject(branch)) {                                                                          // 877  // 2081\n          appendToResult(lookupRest(                                                                          // 878  // 2082\n            branch,                                                                                           // 879  // 2083\n            arrayIndices.concat(arrayIndex)));                                                                // 880  // 2084\n        }                                                                                                     // 881  // 2085\n      });                                                                                                     // 882  // 2086\n    }                                                                                                         // 883  // 2087\n                                                                                                              // 884  // 2088\n    return result;                                                                                            // 885  // 2089\n  };                                                                                                          // 886  // 2090\n};                                                                                                            // 887  // 2091\nMinimongoTest.makeLookupFunction = makeLookupFunction;                                                        // 888  // 2092\n                                                                                                              // 889  // 2093\nexpandArraysInBranches = function (branches, skipTheArrays) {                                                 // 890  // 2094\n  var branchesOut = [];                                                                                       // 891  // 2095\n  _.each(branches, function (branch) {                                                                        // 892  // 2096\n    var thisIsArray = isArray(branch.value);                                                                  // 893  // 2097\n    // We include the branch itself, *UNLESS* we it's an array that we're going                               // 894  // 2098\n    // to iterate and we're told to skip arrays.  (That's right, we include some                              // 895  // 2099\n    // arrays even skipTheArrays is true: these are arrays that were found via                                // 896  // 2100\n    // explicit numerical indices.)                                                                           // 897  // 2101\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {                                             // 898  // 2102\n      branchesOut.push({                                                                                      // 899  // 2103\n        value: branch.value,                                                                                  // 900  // 2104\n        arrayIndices: branch.arrayIndices                                                                     // 901  // 2105\n      });                                                                                                     // 902  // 2106\n    }                                                                                                         // 903  // 2107\n    if (thisIsArray && !branch.dontIterate) {                                                                 // 904  // 2108\n      _.each(branch.value, function (leaf, i) {                                                               // 905  // 2109\n        branchesOut.push({                                                                                    // 906  // 2110\n          value: leaf,                                                                                        // 907  // 2111\n          arrayIndices: (branch.arrayIndices || []).concat(i)                                                 // 908  // 2112\n        });                                                                                                   // 909  // 2113\n      });                                                                                                     // 910  // 2114\n    }                                                                                                         // 911  // 2115\n  });                                                                                                         // 912  // 2116\n  return branchesOut;                                                                                         // 913  // 2117\n};                                                                                                            // 914  // 2118\n                                                                                                              // 915  // 2119\nvar nothingMatcher = function (docOrBranchedValues) {                                                         // 916  // 2120\n  return {result: false};                                                                                     // 917  // 2121\n};                                                                                                            // 918  // 2122\n                                                                                                              // 919  // 2123\nvar everythingMatcher = function (docOrBranchedValues) {                                                      // 920  // 2124\n  return {result: true};                                                                                      // 921  // 2125\n};                                                                                                            // 922  // 2126\n                                                                                                              // 923  // 2127\n                                                                                                              // 924  // 2128\n// NB: We are cheating and using this function to implement \"AND\" for both                                    // 925  // 2129\n// \"document matchers\" and \"branched matchers\". They both return result objects                               // 926  // 2130\n// but the argument is different: for the former it's a whole doc, whereas for                                // 927  // 2131\n// the latter it's an array of \"branched values\".                                                             // 928  // 2132\nvar andSomeMatchers = function (subMatchers) {                                                                // 929  // 2133\n  if (subMatchers.length === 0)                                                                               // 930  // 2134\n    return everythingMatcher;                                                                                 // 931  // 2135\n  if (subMatchers.length === 1)                                                                               // 932  // 2136\n    return subMatchers[0];                                                                                    // 933  // 2137\n                                                                                                              // 934  // 2138\n  return function (docOrBranches) {                                                                           // 935  // 2139\n    var ret = {};                                                                                             // 936  // 2140\n    ret.result = _.all(subMatchers, function (f) {                                                            // 937  // 2141\n      var subResult = f(docOrBranches);                                                                       // 938  // 2142\n      // Copy a 'distance' number out of the first sub-matcher that has                                       // 939  // 2143\n      // one. Yes, this means that if there are multiple $near fields in a                                    // 940  // 2144\n      // query, something arbitrary happens; this appears to be consistent with                               // 941  // 2145\n      // Mongo.                                                                                               // 942  // 2146\n      if (subResult.result && subResult.distance !== undefined                                                // 943  // 2147\n          && ret.distance === undefined) {                                                                    // 944  // 2148\n        ret.distance = subResult.distance;                                                                    // 945  // 2149\n      }                                                                                                       // 946  // 2150\n      // Similarly, propagate arrayIndices from sub-matchers... but to match                                  // 947  // 2151\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices                                 // 948  // 2152\n      // wins.                                                                                                // 949  // 2153\n      if (subResult.result && subResult.arrayIndices) {                                                       // 950  // 2154\n        ret.arrayIndices = subResult.arrayIndices;                                                            // 951  // 2155\n      }                                                                                                       // 952  // 2156\n      return subResult.result;                                                                                // 953  // 2157\n    });                                                                                                       // 954  // 2158\n                                                                                                              // 955  // 2159\n    // If we didn't actually match, forget any extra metadata we came up with.                                // 956  // 2160\n    if (!ret.result) {                                                                                        // 957  // 2161\n      delete ret.distance;                                                                                    // 958  // 2162\n      delete ret.arrayIndices;                                                                                // 959  // 2163\n    }                                                                                                         // 960  // 2164\n    return ret;                                                                                               // 961  // 2165\n  };                                                                                                          // 962  // 2166\n};                                                                                                            // 963  // 2167\n                                                                                                              // 964  // 2168\nvar andDocumentMatchers = andSomeMatchers;                                                                    // 965  // 2169\nvar andBranchedMatchers = andSomeMatchers;                                                                    // 966  // 2170\n                                                                                                              // 967  // 2171\n                                                                                                              // 968  // 2172\n// helpers used by compiled selector code                                                                     // 969  // 2173\nLocalCollection._f = {                                                                                        // 970  // 2174\n  // XXX for _all and _in, consider building 'inquery' at compile time..                                      // 971  // 2175\n                                                                                                              // 972  // 2176\n  _type: function (v) {                                                                                       // 973  // 2177\n    if (typeof v === \"number\")                                                                                // 974  // 2178\n      return 1;                                                                                               // 975  // 2179\n    if (typeof v === \"string\")                                                                                // 976  // 2180\n      return 2;                                                                                               // 977  // 2181\n    if (typeof v === \"boolean\")                                                                               // 978  // 2182\n      return 8;                                                                                               // 979  // 2183\n    if (isArray(v))                                                                                           // 980  // 2184\n      return 4;                                                                                               // 981  // 2185\n    if (v === null)                                                                                           // 982  // 2186\n      return 10;                                                                                              // 983  // 2187\n    if (v instanceof RegExp)                                                                                  // 984  // 2188\n      // note that typeof(/x/) === \"object\"                                                                   // 985  // 2189\n      return 11;                                                                                              // 986  // 2190\n    if (typeof v === \"function\")                                                                              // 987  // 2191\n      return 13;                                                                                              // 988  // 2192\n    if (v instanceof Date)                                                                                    // 989  // 2193\n      return 9;                                                                                               // 990  // 2194\n    if (EJSON.isBinary(v))                                                                                    // 991  // 2195\n      return 5;                                                                                               // 992  // 2196\n    if (v instanceof MongoID.ObjectID)                                                                        // 993  // 2197\n      return 7;                                                                                               // 994  // 2198\n    return 3; // object                                                                                       // 995  // 2199\n                                                                                                              // 996  // 2200\n    // XXX support some/all of these:                                                                         // 997  // 2201\n    // 14, symbol                                                                                             // 998  // 2202\n    // 15, javascript code with scope                                                                         // 999  // 2203\n    // 16, 18: 32-bit/64-bit integer                                                                          // 1000\n    // 17, timestamp                                                                                          // 1001\n    // 255, minkey                                                                                            // 1002\n    // 127, maxkey                                                                                            // 1003\n  },                                                                                                          // 1004\n                                                                                                              // 1005\n  // deep equality test: use for literal document and array matches                                           // 1006\n  _equal: function (a, b) {                                                                                   // 1007\n    return EJSON.equals(a, b, {keyOrderSensitive: true});                                                     // 1008\n  },                                                                                                          // 1009\n                                                                                                              // 1010\n  // maps a type code to a value that can be used to sort values of                                           // 1011\n  // different types                                                                                          // 1012\n  _typeorder: function (t) {                                                                                  // 1013\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types                           // 1014\n    // XXX what is the correct sort position for Javascript code?                                             // 1015\n    // ('100' in the matrix below)                                                                            // 1016\n    // XXX minkey/maxkey                                                                                      // 1017\n    return [-1,  // (not a type)                                                                              // 1018\n            1,   // number                                                                                    // 1019\n            2,   // string                                                                                    // 1020\n            3,   // object                                                                                    // 1021\n            4,   // array                                                                                     // 1022\n            5,   // binary                                                                                    // 1023\n            -1,  // deprecated                                                                                // 1024\n            6,   // ObjectID                                                                                  // 1025\n            7,   // bool                                                                                      // 1026\n            8,   // Date                                                                                      // 1027\n            0,   // null                                                                                      // 1028\n            9,   // RegExp                                                                                    // 1029\n            -1,  // deprecated                                                                                // 1030\n            100, // JS code                                                                                   // 1031\n            2,   // deprecated (symbol)                                                                       // 1032\n            100, // JS code                                                                                   // 1033\n            1,   // 32-bit int                                                                                // 1034\n            8,   // Mongo timestamp                                                                           // 1035\n            1    // 64-bit int                                                                                // 1036\n           ][t];                                                                                              // 1037\n  },                                                                                                          // 1038\n                                                                                                              // 1039\n  // compare two values of unknown type according to BSON ordering                                            // 1040\n  // semantics. (as an extension, consider 'undefined' to be less than                                        // 1041\n  // any other value.) return negative if a is less, positive if b is                                         // 1042\n  // less, or 0 if equal                                                                                      // 1043\n  _cmp: function (a, b) {                                                                                     // 1044\n    if (a === undefined)                                                                                      // 1045\n      return b === undefined ? 0 : -1;                                                                        // 1046\n    if (b === undefined)                                                                                      // 1047\n      return 1;                                                                                               // 1048\n    var ta = LocalCollection._f._type(a);                                                                     // 1049\n    var tb = LocalCollection._f._type(b);                                                                     // 1050\n    var oa = LocalCollection._f._typeorder(ta);                                                               // 1051\n    var ob = LocalCollection._f._typeorder(tb);                                                               // 1052\n    if (oa !== ob)                                                                                            // 1053\n      return oa < ob ? -1 : 1;                                                                                // 1054\n    if (ta !== tb)                                                                                            // 1055\n      // XXX need to implement this if we implement Symbol or integers, or                                    // 1056\n      // Timestamp                                                                                            // 1057\n      throw Error(\"Missing type coercion logic in _cmp\");                                                     // 1058\n    if (ta === 7) { // ObjectID                                                                               // 1059\n      // Convert to string.                                                                                   // 1060\n      ta = tb = 2;                                                                                            // 1061\n      a = a.toHexString();                                                                                    // 1062\n      b = b.toHexString();                                                                                    // 1063\n    }                                                                                                         // 1064\n    if (ta === 9) { // Date                                                                                   // 1065\n      // Convert to millis.                                                                                   // 1066\n      ta = tb = 1;                                                                                            // 1067\n      a = a.getTime();                                                                                        // 1068\n      b = b.getTime();                                                                                        // 1069\n    }                                                                                                         // 1070\n                                                                                                              // 1071\n    if (ta === 1) // double                                                                                   // 1072\n      return a - b;                                                                                           // 1073\n    if (tb === 2) // string                                                                                   // 1074\n      return a < b ? -1 : (a === b ? 0 : 1);                                                                  // 1075\n    if (ta === 3) { // Object                                                                                 // 1076\n      // this could be much more efficient in the expected case ...                                           // 1077\n      var to_array = function (obj) {                                                                         // 1078\n        var ret = [];                                                                                         // 1079\n        for (var key in obj) {                                                                                // 1080\n          ret.push(key);                                                                                      // 1081\n          ret.push(obj[key]);                                                                                 // 1082\n        }                                                                                                     // 1083\n        return ret;                                                                                           // 1084\n      };                                                                                                      // 1085\n      return LocalCollection._f._cmp(to_array(a), to_array(b));                                               // 1086\n    }                                                                                                         // 1087\n    if (ta === 4) { // Array                                                                                  // 1088\n      for (var i = 0; ; i++) {                                                                                // 1089\n        if (i === a.length)                                                                                   // 1090\n          return (i === b.length) ? 0 : -1;                                                                   // 1091\n        if (i === b.length)                                                                                   // 1092\n          return 1;                                                                                           // 1093\n        var s = LocalCollection._f._cmp(a[i], b[i]);                                                          // 1094\n        if (s !== 0)                                                                                          // 1095\n          return s;                                                                                           // 1096\n      }                                                                                                       // 1097\n    }                                                                                                         // 1098\n    if (ta === 5) { // binary                                                                                 // 1099\n      // Surprisingly, a small binary blob is always less than a large one in                                 // 1100\n      // Mongo.                                                                                               // 1101\n      if (a.length !== b.length)                                                                              // 1102\n        return a.length - b.length;                                                                           // 1103\n      for (i = 0; i < a.length; i++) {                                                                        // 1104\n        if (a[i] < b[i])                                                                                      // 1105\n          return -1;                                                                                          // 1106\n        if (a[i] > b[i])                                                                                      // 1107\n          return 1;                                                                                           // 1108\n      }                                                                                                       // 1109\n      return 0;                                                                                               // 1110\n    }                                                                                                         // 1111\n    if (ta === 8) { // boolean                                                                                // 1112\n      if (a) return b ? 0 : 1;                                                                                // 1113\n      return b ? -1 : 0;                                                                                      // 1114\n    }                                                                                                         // 1115\n    if (ta === 10) // null                                                                                    // 1116\n      return 0;                                                                                               // 1117\n    if (ta === 11) // regexp                                                                                  // 1118\n      throw Error(\"Sorting not supported on regular expression\"); // XXX                                      // 1119\n    // 13: javascript code                                                                                    // 1120\n    // 14: symbol                                                                                             // 1121\n    // 15: javascript code with scope                                                                         // 1122\n    // 16: 32-bit integer                                                                                     // 1123\n    // 17: timestamp                                                                                          // 1124\n    // 18: 64-bit integer                                                                                     // 1125\n    // 255: minkey                                                                                            // 1126\n    // 127: maxkey                                                                                            // 1127\n    if (ta === 13) // javascript code                                                                         // 1128\n      throw Error(\"Sorting not supported on Javascript code\"); // XXX                                         // 1129\n    throw Error(\"Unknown type to sort\");                                                                      // 1130\n  }                                                                                                           // 1131\n};                                                                                                            // 1132\n                                                                                                              // 1133\n// Oddball function used by upsert.                                                                           // 1134\nLocalCollection._removeDollarOperators = function (selector) {                                                // 1135\n  var selectorDoc = {};                                                                                       // 1136\n  for (var k in selector)                                                                                     // 1137\n    if (k.substr(0, 1) !== '$')                                                                               // 1138\n      selectorDoc[k] = selector[k];                                                                           // 1139\n  return selectorDoc;                                                                                         // 1140\n};                                                                                                            // 1141\n                                                                                                              // 1142\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2347\n                                                                                                                      // 2348\n}).call(this);                                                                                                        // 2349\n                                                                                                                      // 2350\n                                                                                                                      // 2351\n                                                                                                                      // 2352\n                                                                                                                      // 2353\n                                                                                                                      // 2354\n                                                                                                                      // 2355\n(function(){                                                                                                          // 2356\n                                                                                                                      // 2357\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2358\n//                                                                                                            //      // 2359\n// packages/minimongo/sort.js                                                                                 //      // 2360\n//                                                                                                            //      // 2361\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2362\n                                                                                                              //      // 2363\n// Give a sort spec, which can be in any of these forms:                                                      // 1    // 2364\n//   {\"key1\": 1, \"key2\": -1}                                                                                  // 2    // 2365\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]                                                                      // 3    // 2366\n//   [\"key1\", [\"key2\", \"desc\"]]                                                                               // 4    // 2367\n//                                                                                                            // 5    // 2368\n// (.. with the first form being dependent on the key enumeration                                             // 6    // 2369\n// behavior of your javascript VM, which usually does what you mean in                                        // 7    // 2370\n// this case if the key names don't look like integers ..)                                                    // 8    // 2371\n//                                                                                                            // 9    // 2372\n// return a function that takes two objects, and returns -1 if the                                            // 10   // 2373\n// first object comes first in order, 1 if the second object comes                                            // 11   // 2374\n// first, or 0 if neither object comes before the other.                                                      // 12   // 2375\n                                                                                                              // 13   // 2376\nMinimongo.Sorter = function (spec, options) {                                                                 // 14   // 2377\n  var self = this;                                                                                            // 15   // 2378\n  options = options || {};                                                                                    // 16   // 2379\n                                                                                                              // 17   // 2380\n  self._sortSpecParts = [];                                                                                   // 18   // 2381\n                                                                                                              // 19   // 2382\n  var addSpecPart = function (path, ascending) {                                                              // 20   // 2383\n    if (!path)                                                                                                // 21   // 2384\n      throw Error(\"sort keys must be non-empty\");                                                             // 22   // 2385\n    if (path.charAt(0) === '$')                                                                               // 23   // 2386\n      throw Error(\"unsupported sort key: \" + path);                                                           // 24   // 2387\n    self._sortSpecParts.push({                                                                                // 25   // 2388\n      path: path,                                                                                             // 26   // 2389\n      lookup: makeLookupFunction(path, {forSort: true}),                                                      // 27   // 2390\n      ascending: ascending                                                                                    // 28   // 2391\n    });                                                                                                       // 29   // 2392\n  };                                                                                                          // 30   // 2393\n                                                                                                              // 31   // 2394\n  if (spec instanceof Array) {                                                                                // 32   // 2395\n    for (var i = 0; i < spec.length; i++) {                                                                   // 33   // 2396\n      if (typeof spec[i] === \"string\") {                                                                      // 34   // 2397\n        addSpecPart(spec[i], true);                                                                           // 35   // 2398\n      } else {                                                                                                // 36   // 2399\n        addSpecPart(spec[i][0], spec[i][1] !== \"desc\");                                                       // 37   // 2400\n      }                                                                                                       // 38   // 2401\n    }                                                                                                         // 39   // 2402\n  } else if (typeof spec === \"object\") {                                                                      // 40   // 2403\n    _.each(spec, function (value, key) {                                                                      // 41   // 2404\n      addSpecPart(key, value >= 0);                                                                           // 42   // 2405\n    });                                                                                                       // 43   // 2406\n  } else {                                                                                                    // 44   // 2407\n    throw Error(\"Bad sort specification: \" + JSON.stringify(spec));                                           // 45   // 2408\n  }                                                                                                           // 46   // 2409\n                                                                                                              // 47   // 2410\n  // To implement affectedByModifier, we piggy-back on top of Matcher's                                       // 48   // 2411\n  // affectedByModifier code; we create a selector that is affected by the same                               // 49   // 2412\n  // modifiers as this sort order. This is only implemented on the server.                                    // 50   // 2413\n  if (self.affectedByModifier) {                                                                              // 51   // 2414\n    var selector = {};                                                                                        // 52   // 2415\n    _.each(self._sortSpecParts, function (spec) {                                                             // 53   // 2416\n      selector[spec.path] = 1;                                                                                // 54   // 2417\n    });                                                                                                       // 55   // 2418\n    self._selectorForAffectedByModifier = new Minimongo.Matcher(selector);                                    // 56   // 2419\n  }                                                                                                           // 57   // 2420\n                                                                                                              // 58   // 2421\n  self._keyComparator = composeComparators(                                                                   // 59   // 2422\n    _.map(self._sortSpecParts, function (spec, i) {                                                           // 60   // 2423\n      return self._keyFieldComparator(i);                                                                     // 61   // 2424\n    }));                                                                                                      // 62   // 2425\n                                                                                                              // 63   // 2426\n  // If you specify a matcher for this Sorter, _keyFilter may be set to a                                     // 64   // 2427\n  // function which selects whether or not a given \"sort key\" (tuple of values                                // 65   // 2428\n  // for the different sort spec fields) is compatible with the selector.                                     // 66   // 2429\n  self._keyFilter = null;                                                                                     // 67   // 2430\n  options.matcher && self._useWithMatcher(options.matcher);                                                   // 68   // 2431\n};                                                                                                            // 69   // 2432\n                                                                                                              // 70   // 2433\n// In addition to these methods, sorter_project.js defines combineIntoProjection                              // 71   // 2434\n// on the server only.                                                                                        // 72   // 2435\n_.extend(Minimongo.Sorter.prototype, {                                                                        // 73   // 2436\n  getComparator: function (options) {                                                                         // 74   // 2437\n    var self = this;                                                                                          // 75   // 2438\n                                                                                                              // 76   // 2439\n    // If we have no distances, just use the comparator from the source                                       // 77   // 2440\n    // specification (which defaults to \"everything is equal\".                                                // 78   // 2441\n    if (!options || !options.distances) {                                                                     // 79   // 2442\n      return self._getBaseComparator();                                                                       // 80   // 2443\n    }                                                                                                         // 81   // 2444\n                                                                                                              // 82   // 2445\n    var distances = options.distances;                                                                        // 83   // 2446\n                                                                                                              // 84   // 2447\n    // Return a comparator which first tries the sort specification, and if that                              // 85   // 2448\n    // says \"it's equal\", breaks ties using $near distances.                                                  // 86   // 2449\n    return composeComparators([self._getBaseComparator(), function (a, b) {                                   // 87   // 2450\n      if (!distances.has(a._id))                                                                              // 88   // 2451\n        throw Error(\"Missing distance for \" + a._id);                                                         // 89   // 2452\n      if (!distances.has(b._id))                                                                              // 90   // 2453\n        throw Error(\"Missing distance for \" + b._id);                                                         // 91   // 2454\n      return distances.get(a._id) - distances.get(b._id);                                                     // 92   // 2455\n    }]);                                                                                                      // 93   // 2456\n  },                                                                                                          // 94   // 2457\n                                                                                                              // 95   // 2458\n  _getPaths: function () {                                                                                    // 96   // 2459\n    var self = this;                                                                                          // 97   // 2460\n    return _.pluck(self._sortSpecParts, 'path');                                                              // 98   // 2461\n  },                                                                                                          // 99   // 2462\n                                                                                                              // 100  // 2463\n  // Finds the minimum key from the doc, according to the sort specs.  (We say                                // 101  // 2464\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"                                // 102  // 2465\n  // sort fields mean we're finding the max for that field.)                                                  // 103  // 2466\n  //                                                                                                          // 104  // 2467\n  // Note that this is NOT \"find the minimum value of the first field, the                                    // 105  // 2468\n  // minimum value of the second field, etc\"... it's \"choose the                                              // 106  // 2469\n  // lexicographically minimum value of the key vector, allowing only keys which                              // 107  // 2470\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:                                // 108  // 2471\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and                              // 109  // 2472\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.                                        // 110  // 2473\n  _getMinKeyFromDoc: function (doc) {                                                                         // 111  // 2474\n    var self = this;                                                                                          // 112  // 2475\n    var minKey = null;                                                                                        // 113  // 2476\n                                                                                                              // 114  // 2477\n    self._generateKeysFromDoc(doc, function (key) {                                                           // 115  // 2478\n      if (!self._keyCompatibleWithSelector(key))                                                              // 116  // 2479\n        return;                                                                                               // 117  // 2480\n                                                                                                              // 118  // 2481\n      if (minKey === null) {                                                                                  // 119  // 2482\n        minKey = key;                                                                                         // 120  // 2483\n        return;                                                                                               // 121  // 2484\n      }                                                                                                       // 122  // 2485\n      if (self._compareKeys(key, minKey) < 0) {                                                               // 123  // 2486\n        minKey = key;                                                                                         // 124  // 2487\n      }                                                                                                       // 125  // 2488\n    });                                                                                                       // 126  // 2489\n                                                                                                              // 127  // 2490\n    // This could happen if our key filter somehow filters out all the keys even                              // 128  // 2491\n    // though somehow the selector matches.                                                                   // 129  // 2492\n    if (minKey === null)                                                                                      // 130  // 2493\n      throw Error(\"sort selector found no keys in doc?\");                                                     // 131  // 2494\n    return minKey;                                                                                            // 132  // 2495\n  },                                                                                                          // 133  // 2496\n                                                                                                              // 134  // 2497\n  _keyCompatibleWithSelector: function (key) {                                                                // 135  // 2498\n    var self = this;                                                                                          // 136  // 2499\n    return !self._keyFilter || self._keyFilter(key);                                                          // 137  // 2500\n  },                                                                                                          // 138  // 2501\n                                                                                                              // 139  // 2502\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling                               // 140  // 2503\n  // 'cb' with the key.                                                                                       // 141  // 2504\n  _generateKeysFromDoc: function (doc, cb) {                                                                  // 142  // 2505\n    var self = this;                                                                                          // 143  // 2506\n                                                                                                              // 144  // 2507\n    if (self._sortSpecParts.length === 0)                                                                     // 145  // 2508\n      throw new Error(\"can't generate keys without a spec\");                                                  // 146  // 2509\n                                                                                                              // 147  // 2510\n    // maps index -> ({'' -> value} or {path -> value})                                                       // 148  // 2511\n    var valuesByIndexAndPath = [];                                                                            // 149  // 2512\n                                                                                                              // 150  // 2513\n    var pathFromIndices = function (indices) {                                                                // 151  // 2514\n      return indices.join(',') + ',';                                                                         // 152  // 2515\n    };                                                                                                        // 153  // 2516\n                                                                                                              // 154  // 2517\n    var knownPaths = null;                                                                                    // 155  // 2518\n                                                                                                              // 156  // 2519\n    _.each(self._sortSpecParts, function (spec, whichField) {                                                 // 157  // 2520\n      // Expand any leaf arrays that we find, and ignore those arrays                                         // 158  // 2521\n      // themselves.  (We never sort based on an array itself.)                                               // 159  // 2522\n      var branches = expandArraysInBranches(spec.lookup(doc), true);                                          // 160  // 2523\n                                                                                                              // 161  // 2524\n      // If there are no values for a key (eg, key goes to an empty array),                                   // 162  // 2525\n      // pretend we found one null value.                                                                     // 163  // 2526\n      if (!branches.length)                                                                                   // 164  // 2527\n        branches = [{value: null}];                                                                           // 165  // 2528\n                                                                                                              // 166  // 2529\n      var usedPaths = false;                                                                                  // 167  // 2530\n      valuesByIndexAndPath[whichField] = {};                                                                  // 168  // 2531\n      _.each(branches, function (branch) {                                                                    // 169  // 2532\n        if (!branch.arrayIndices) {                                                                           // 170  // 2533\n          // If there are no array indices for a branch, then it must be the                                  // 171  // 2534\n          // only branch, because the only thing that produces multiple branches                              // 172  // 2535\n          // is the use of arrays.                                                                            // 173  // 2536\n          if (branches.length > 1)                                                                            // 174  // 2537\n            throw Error(\"multiple branches but no array used?\");                                              // 175  // 2538\n          valuesByIndexAndPath[whichField][''] = branch.value;                                                // 176  // 2539\n          return;                                                                                             // 177  // 2540\n        }                                                                                                     // 178  // 2541\n                                                                                                              // 179  // 2542\n        usedPaths = true;                                                                                     // 180  // 2543\n        var path = pathFromIndices(branch.arrayIndices);                                                      // 181  // 2544\n        if (_.has(valuesByIndexAndPath[whichField], path))                                                    // 182  // 2545\n          throw Error(\"duplicate path: \" + path);                                                             // 183  // 2546\n        valuesByIndexAndPath[whichField][path] = branch.value;                                                // 184  // 2547\n                                                                                                              // 185  // 2548\n        // If two sort fields both go into arrays, they have to go into the                                   // 186  // 2549\n        // exact same arrays and we have to find the same paths.  This is                                     // 187  // 2550\n        // roughly the same condition that makes MongoDB throw this strange                                   // 188  // 2551\n        // error message.  eg, the main thing is that if sort spec is {a: 1,                                  // 189  // 2552\n        // b:1} then a and b cannot both be arrays.                                                           // 190  // 2553\n        //                                                                                                    // 191  // 2554\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'                                 // 192  // 2555\n        // and 'a.x.y' are both arrays, but we don't allow this for now.                                      // 193  // 2556\n        // #NestedArraySort                                                                                   // 194  // 2557\n        // XXX achieve full compatibility here                                                                // 195  // 2558\n        if (knownPaths && !_.has(knownPaths, path)) {                                                         // 196  // 2559\n          throw Error(\"cannot index parallel arrays\");                                                        // 197  // 2560\n        }                                                                                                     // 198  // 2561\n      });                                                                                                     // 199  // 2562\n                                                                                                              // 200  // 2563\n      if (knownPaths) {                                                                                       // 201  // 2564\n        // Similarly to above, paths must match everywhere, unless this is a                                  // 202  // 2565\n        // non-array field.                                                                                   // 203  // 2566\n        if (!_.has(valuesByIndexAndPath[whichField], '') &&                                                   // 204  // 2567\n            _.size(knownPaths) !== _.size(valuesByIndexAndPath[whichField])) {                                // 205  // 2568\n          throw Error(\"cannot index parallel arrays!\");                                                       // 206  // 2569\n        }                                                                                                     // 207  // 2570\n      } else if (usedPaths) {                                                                                 // 208  // 2571\n        knownPaths = {};                                                                                      // 209  // 2572\n        _.each(valuesByIndexAndPath[whichField], function (x, path) {                                         // 210  // 2573\n          knownPaths[path] = true;                                                                            // 211  // 2574\n        });                                                                                                   // 212  // 2575\n      }                                                                                                       // 213  // 2576\n    });                                                                                                       // 214  // 2577\n                                                                                                              // 215  // 2578\n    if (!knownPaths) {                                                                                        // 216  // 2579\n      // Easy case: no use of arrays.                                                                         // 217  // 2580\n      var soleKey = _.map(valuesByIndexAndPath, function (values) {                                           // 218  // 2581\n        if (!_.has(values, ''))                                                                               // 219  // 2582\n          throw Error(\"no value in sole key case?\");                                                          // 220  // 2583\n        return values[''];                                                                                    // 221  // 2584\n      });                                                                                                     // 222  // 2585\n      cb(soleKey);                                                                                            // 223  // 2586\n      return;                                                                                                 // 224  // 2587\n    }                                                                                                         // 225  // 2588\n                                                                                                              // 226  // 2589\n    _.each(knownPaths, function (x, path) {                                                                   // 227  // 2590\n      var key = _.map(valuesByIndexAndPath, function (values) {                                               // 228  // 2591\n        if (_.has(values, ''))                                                                                // 229  // 2592\n          return values[''];                                                                                  // 230  // 2593\n        if (!_.has(values, path))                                                                             // 231  // 2594\n          throw Error(\"missing path?\");                                                                       // 232  // 2595\n        return values[path];                                                                                  // 233  // 2596\n      });                                                                                                     // 234  // 2597\n      cb(key);                                                                                                // 235  // 2598\n    });                                                                                                       // 236  // 2599\n  },                                                                                                          // 237  // 2600\n                                                                                                              // 238  // 2601\n  // Takes in two keys: arrays whose lengths match the number of spec                                         // 239  // 2602\n  // parts. Returns negative, 0, or positive based on using the sort spec to                                  // 240  // 2603\n  // compare fields.                                                                                          // 241  // 2604\n  _compareKeys: function (key1, key2) {                                                                       // 242  // 2605\n    var self = this;                                                                                          // 243  // 2606\n    if (key1.length !== self._sortSpecParts.length ||                                                         // 244  // 2607\n        key2.length !== self._sortSpecParts.length) {                                                         // 245  // 2608\n      throw Error(\"Key has wrong length\");                                                                    // 246  // 2609\n    }                                                                                                         // 247  // 2610\n                                                                                                              // 248  // 2611\n    return self._keyComparator(key1, key2);                                                                   // 249  // 2612\n  },                                                                                                          // 250  // 2613\n                                                                                                              // 251  // 2614\n  // Given an index 'i', returns a comparator that compares two key arrays based                              // 252  // 2615\n  // on field 'i'.                                                                                            // 253  // 2616\n  _keyFieldComparator: function (i) {                                                                         // 254  // 2617\n    var self = this;                                                                                          // 255  // 2618\n    var invert = !self._sortSpecParts[i].ascending;                                                           // 256  // 2619\n    return function (key1, key2) {                                                                            // 257  // 2620\n      var compare = LocalCollection._f._cmp(key1[i], key2[i]);                                                // 258  // 2621\n      if (invert)                                                                                             // 259  // 2622\n        compare = -compare;                                                                                   // 260  // 2623\n      return compare;                                                                                         // 261  // 2624\n    };                                                                                                        // 262  // 2625\n  },                                                                                                          // 263  // 2626\n                                                                                                              // 264  // 2627\n  // Returns a comparator that represents the sort specification (but not                                     // 265  // 2628\n  // including a possible geoquery distance tie-breaker).                                                     // 266  // 2629\n  _getBaseComparator: function () {                                                                           // 267  // 2630\n    var self = this;                                                                                          // 268  // 2631\n                                                                                                              // 269  // 2632\n    // If we're only sorting on geoquery distance and no specs, just say                                      // 270  // 2633\n    // everything is equal.                                                                                   // 271  // 2634\n    if (!self._sortSpecParts.length) {                                                                        // 272  // 2635\n      return function (doc1, doc2) {                                                                          // 273  // 2636\n        return 0;                                                                                             // 274  // 2637\n      };                                                                                                      // 275  // 2638\n    }                                                                                                         // 276  // 2639\n                                                                                                              // 277  // 2640\n    return function (doc1, doc2) {                                                                            // 278  // 2641\n      var key1 = self._getMinKeyFromDoc(doc1);                                                                // 279  // 2642\n      var key2 = self._getMinKeyFromDoc(doc2);                                                                // 280  // 2643\n      return self._compareKeys(key1, key2);                                                                   // 281  // 2644\n    };                                                                                                        // 282  // 2645\n  },                                                                                                          // 283  // 2646\n                                                                                                              // 284  // 2647\n  // In MongoDB, if you have documents                                                                        // 285  // 2648\n  //    {_id: 'x', a: [1, 10]} and                                                                            // 286  // 2649\n  //    {_id: 'y', a: [5, 15]},                                                                               // 287  // 2650\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).                                      // 288  // 2651\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not                                   // 289  // 2652\n  // match the selector, and 5 comes before 10).                                                              // 290  // 2653\n  //                                                                                                          // 291  // 2654\n  // The way this works is pretty subtle!  For example, if the documents                                      // 292  // 2655\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and                                                        // 293  // 2656\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),                                                           // 294  // 2657\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and                                                   // 295  // 2658\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})                                        // 296  // 2659\n  // both follow this rule (y before x).  (ie, you do have to apply this                                      // 297  // 2660\n  // through $elemMatch.)                                                                                     // 298  // 2661\n  //                                                                                                          // 299  // 2662\n  // So if you pass a matcher to this sorter's constructor, we will attempt to                                // 300  // 2663\n  // skip sort keys that don't match the selector. The logic here is pretty                                   // 301  // 2664\n  // subtle and undocumented; we've gotten as close as we can figure out based                                // 302  // 2665\n  // on our understanding of Mongo's behavior.                                                                // 303  // 2666\n  _useWithMatcher: function (matcher) {                                                                       // 304  // 2667\n    var self = this;                                                                                          // 305  // 2668\n                                                                                                              // 306  // 2669\n    if (self._keyFilter)                                                                                      // 307  // 2670\n      throw Error(\"called _useWithMatcher twice?\");                                                           // 308  // 2671\n                                                                                                              // 309  // 2672\n    // If we are only sorting by distance, then we're not going to bother to                                  // 310  // 2673\n    // build a key filter.                                                                                    // 311  // 2674\n    // XXX figure out how geoqueries interact with this stuff                                                 // 312  // 2675\n    if (_.isEmpty(self._sortSpecParts))                                                                       // 313  // 2676\n      return;                                                                                                 // 314  // 2677\n                                                                                                              // 315  // 2678\n    var selector = matcher._selector;                                                                         // 316  // 2679\n                                                                                                              // 317  // 2680\n    // If the user just passed a literal function to find(), then we can't get a                              // 318  // 2681\n    // key filter from it.                                                                                    // 319  // 2682\n    if (selector instanceof Function)                                                                         // 320  // 2683\n      return;                                                                                                 // 321  // 2684\n                                                                                                              // 322  // 2685\n    var constraintsByPath = {};                                                                               // 323  // 2686\n    _.each(self._sortSpecParts, function (spec, i) {                                                          // 324  // 2687\n      constraintsByPath[spec.path] = [];                                                                      // 325  // 2688\n    });                                                                                                       // 326  // 2689\n                                                                                                              // 327  // 2690\n    _.each(selector, function (subSelector, key) {                                                            // 328  // 2691\n      // XXX support $and and $or                                                                             // 329  // 2692\n                                                                                                              // 330  // 2693\n      var constraints = constraintsByPath[key];                                                               // 331  // 2694\n      if (!constraints)                                                                                       // 332  // 2695\n        return;                                                                                               // 333  // 2696\n                                                                                                              // 334  // 2697\n      // XXX it looks like the real MongoDB implementation isn't \"does the                                    // 335  // 2698\n      // regexp match\" but \"does the value fall into a range named by the                                     // 336  // 2699\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But                                     // 337  // 2700\n      // \"does the regexp match\" is a good approximation.                                                     // 338  // 2701\n      if (subSelector instanceof RegExp) {                                                                    // 339  // 2702\n        // As far as we can tell, using either of the options that both we and                                // 340  // 2703\n        // MongoDB support ('i' and 'm') disables use of the key filter. This                                 // 341  // 2704\n        // makes sense: MongoDB mostly appears to be calculating ranges of an                                 // 342  // 2705\n        // index to use, which means it only cares about regexps that match                                   // 343  // 2706\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the                                // 344  // 2707\n        // literal prefix of the regexp from actually meaning one range.                                      // 345  // 2708\n        if (subSelector.ignoreCase || subSelector.multiline)                                                  // 346  // 2709\n          return;                                                                                             // 347  // 2710\n        constraints.push(regexpElementMatcher(subSelector));                                                  // 348  // 2711\n        return;                                                                                               // 349  // 2712\n      }                                                                                                       // 350  // 2713\n                                                                                                              // 351  // 2714\n      if (isOperatorObject(subSelector)) {                                                                    // 352  // 2715\n        _.each(subSelector, function (operand, operator) {                                                    // 353  // 2716\n          if (_.contains(['$lt', '$lte', '$gt', '$gte'], operator)) {                                         // 354  // 2717\n            // XXX this depends on us knowing that these operators don't use any                              // 355  // 2718\n            // of the arguments to compileElementSelector other than operand.                                 // 356  // 2719\n            constraints.push(                                                                                 // 357  // 2720\n              ELEMENT_OPERATORS[operator].compileElementSelector(operand));                                   // 358  // 2721\n          }                                                                                                   // 359  // 2722\n                                                                                                              // 360  // 2723\n          // See comments in the RegExp block above.                                                          // 361  // 2724\n          if (operator === '$regex' && !subSelector.$options) {                                               // 362  // 2725\n            constraints.push(                                                                                 // 363  // 2726\n              ELEMENT_OPERATORS.$regex.compileElementSelector(                                                // 364  // 2727\n                operand, subSelector));                                                                       // 365  // 2728\n          }                                                                                                   // 366  // 2729\n                                                                                                              // 367  // 2730\n          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch                                        // 368  // 2731\n        });                                                                                                   // 369  // 2732\n        return;                                                                                               // 370  // 2733\n      }                                                                                                       // 371  // 2734\n                                                                                                              // 372  // 2735\n      // OK, it's an equality thing.                                                                          // 373  // 2736\n      constraints.push(equalityElementMatcher(subSelector));                                                  // 374  // 2737\n    });                                                                                                       // 375  // 2738\n                                                                                                              // 376  // 2739\n    // It appears that the first sort field is treated differently from the                                   // 377  // 2740\n    // others; we shouldn't create a key filter unless the first sort field is                                // 378  // 2741\n    // restricted, though after that point we can restrict the other sort fields                              // 379  // 2742\n    // or not as we wish.                                                                                     // 380  // 2743\n    if (_.isEmpty(constraintsByPath[self._sortSpecParts[0].path]))                                            // 381  // 2744\n      return;                                                                                                 // 382  // 2745\n                                                                                                              // 383  // 2746\n    self._keyFilter = function (key) {                                                                        // 384  // 2747\n      return _.all(self._sortSpecParts, function (specPart, index) {                                          // 385  // 2748\n        return _.all(constraintsByPath[specPart.path], function (f) {                                         // 386  // 2749\n          return f(key[index]);                                                                               // 387  // 2750\n        });                                                                                                   // 388  // 2751\n      });                                                                                                     // 389  // 2752\n    };                                                                                                        // 390  // 2753\n  }                                                                                                           // 391  // 2754\n});                                                                                                           // 392  // 2755\n                                                                                                              // 393  // 2756\n// Given an array of comparators                                                                              // 394  // 2757\n// (functions (a,b)->(negative or positive or zero)), returns a single                                        // 395  // 2758\n// comparator which uses each comparator in order and returns the first                                       // 396  // 2759\n// non-zero value.                                                                                            // 397  // 2760\nvar composeComparators = function (comparatorArray) {                                                         // 398  // 2761\n  return function (a, b) {                                                                                    // 399  // 2762\n    for (var i = 0; i < comparatorArray.length; ++i) {                                                        // 400  // 2763\n      var compare = comparatorArray[i](a, b);                                                                 // 401  // 2764\n      if (compare !== 0)                                                                                      // 402  // 2765\n        return compare;                                                                                       // 403  // 2766\n    }                                                                                                         // 404  // 2767\n    return 0;                                                                                                 // 405  // 2768\n  };                                                                                                          // 406  // 2769\n};                                                                                                            // 407  // 2770\n                                                                                                              // 408  // 2771\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2772\n                                                                                                                      // 2773\n}).call(this);                                                                                                        // 2774\n                                                                                                                      // 2775\n                                                                                                                      // 2776\n                                                                                                                      // 2777\n                                                                                                                      // 2778\n                                                                                                                      // 2779\n                                                                                                                      // 2780\n(function(){                                                                                                          // 2781\n                                                                                                                      // 2782\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2783\n//                                                                                                            //      // 2784\n// packages/minimongo/projection.js                                                                           //      // 2785\n//                                                                                                            //      // 2786\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2787\n                                                                                                              //      // 2788\n// Knows how to compile a fields projection to a predicate function.                                          // 1    // 2789\n// @returns - Function: a closure that filters out an object according to the                                 // 2    // 2790\n//            fields projection rules:                                                                        // 3    // 2791\n//            @param obj - Object: MongoDB-styled document                                                    // 4    // 2792\n//            @returns - Object: a document with the fields filtered out                                      // 5    // 2793\n//                       according to projection rules. Doesn't retain subfields                              // 6    // 2794\n//                       of passed argument.                                                                  // 7    // 2795\nLocalCollection._compileProjection = function (fields) {                                                      // 8    // 2796\n  LocalCollection._checkSupportedProjection(fields);                                                          // 9    // 2797\n                                                                                                              // 10   // 2798\n  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;                                          // 11   // 2799\n  var details = projectionDetails(fields);                                                                    // 12   // 2800\n                                                                                                              // 13   // 2801\n  // returns transformed doc according to ruleTree                                                            // 14   // 2802\n  var transform = function (doc, ruleTree) {                                                                  // 15   // 2803\n    // Special case for \"sets\"                                                                                // 16   // 2804\n    if (_.isArray(doc))                                                                                       // 17   // 2805\n      return _.map(doc, function (subdoc) { return transform(subdoc, ruleTree); });                           // 18   // 2806\n                                                                                                              // 19   // 2807\n    var res = details.including ? {} : EJSON.clone(doc);                                                      // 20   // 2808\n    _.each(ruleTree, function (rule, key) {                                                                   // 21   // 2809\n      if (!_.has(doc, key))                                                                                   // 22   // 2810\n        return;                                                                                               // 23   // 2811\n      if (_.isObject(rule)) {                                                                                 // 24   // 2812\n        // For sub-objects/subsets we branch                                                                  // 25   // 2813\n        if (_.isObject(doc[key]))                                                                             // 26   // 2814\n          res[key] = transform(doc[key], rule);                                                               // 27   // 2815\n        // Otherwise we don't even touch this subfield                                                        // 28   // 2816\n      } else if (details.including)                                                                           // 29   // 2817\n        res[key] = EJSON.clone(doc[key]);                                                                     // 30   // 2818\n      else                                                                                                    // 31   // 2819\n        delete res[key];                                                                                      // 32   // 2820\n    });                                                                                                       // 33   // 2821\n                                                                                                              // 34   // 2822\n    return res;                                                                                               // 35   // 2823\n  };                                                                                                          // 36   // 2824\n                                                                                                              // 37   // 2825\n  return function (obj) {                                                                                     // 38   // 2826\n    var res = transform(obj, details.tree);                                                                   // 39   // 2827\n                                                                                                              // 40   // 2828\n    if (_idProjection && _.has(obj, '_id'))                                                                   // 41   // 2829\n      res._id = obj._id;                                                                                      // 42   // 2830\n    if (!_idProjection && _.has(res, '_id'))                                                                  // 43   // 2831\n      delete res._id;                                                                                         // 44   // 2832\n    return res;                                                                                               // 45   // 2833\n  };                                                                                                          // 46   // 2834\n};                                                                                                            // 47   // 2835\n                                                                                                              // 48   // 2836\n// Traverses the keys of passed projection and constructs a tree where all                                    // 49   // 2837\n// leaves are either all True or all False                                                                    // 50   // 2838\n// @returns Object:                                                                                           // 51   // 2839\n//  - tree - Object - tree representation of keys involved in projection                                      // 52   // 2840\n//  (exception for '_id' as it is a special case handled separately)                                          // 53   // 2841\n//  - including - Boolean - \"take only certain fields\" type of projection                                     // 54   // 2842\nprojectionDetails = function (fields) {                                                                       // 55   // 2843\n  // Find the non-_id keys (_id is handled specially because it is included unless                            // 56   // 2844\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps                                 // 57   // 2845\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.                                              // 58   // 2846\n  var fieldsKeys = _.keys(fields).sort();                                                                     // 59   // 2847\n                                                                                                              // 60   // 2848\n  // If _id is the only field in the projection, do not remove it, since it is                                // 61   // 2849\n  // required to determine if this is an exclusion or exclusion. Also keep an                                 // 62   // 2850\n  // inclusive _id, since inclusive _id follows the normal rules about mixing                                 // 63   // 2851\n  // inclusive and exclusive fields. If _id is not the only field in the                                      // 64   // 2852\n  // projection and is exclusive, remove it so it can be handled later by a                                   // 65   // 2853\n  // special case, since exclusive _id is always allowed.                                                     // 66   // 2854\n  if (fieldsKeys.length > 0 &&                                                                                // 67   // 2855\n      !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&                                                // 68   // 2856\n      !(_.contains(fieldsKeys, '_id') && fields['_id']))                                                      // 69   // 2857\n    fieldsKeys = _.reject(fieldsKeys, function (key) { return key === '_id'; });                              // 70   // 2858\n                                                                                                              // 71   // 2859\n  var including = null; // Unknown                                                                            // 72   // 2860\n                                                                                                              // 73   // 2861\n  _.each(fieldsKeys, function (keyPath) {                                                                     // 74   // 2862\n    var rule = !!fields[keyPath];                                                                             // 75   // 2863\n    if (including === null)                                                                                   // 76   // 2864\n      including = rule;                                                                                       // 77   // 2865\n    if (including !== rule)                                                                                   // 78   // 2866\n      // This error message is copied from MongoDB shell                                                      // 79   // 2867\n      throw MinimongoError(\"You cannot currently mix including and excluding fields.\");                       // 80   // 2868\n  });                                                                                                         // 81   // 2869\n                                                                                                              // 82   // 2870\n                                                                                                              // 83   // 2871\n  var projectionRulesTree = pathsToTree(                                                                      // 84   // 2872\n    fieldsKeys,                                                                                               // 85   // 2873\n    function (path) { return including; },                                                                    // 86   // 2874\n    function (node, path, fullPath) {                                                                         // 87   // 2875\n      // Check passed projection fields' keys: If you have two rules such as                                  // 88   // 2876\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If                                   // 89   // 2877\n      // that happens, there is a probability you are doing something wrong,                                  // 90   // 2878\n      // framework should notify you about such mistake earlier on cursor                                     // 91   // 2879\n      // compilation step than later during runtime.  Note, that real mongo                                   // 92   // 2880\n      // doesn't do anything about it and the later rule appears in projection                                // 93   // 2881\n      // project, more priority it takes.                                                                     // 94   // 2882\n      //                                                                                                      // 95   // 2883\n      // Example, assume following in mongo shell:                                                            // 96   // 2884\n      // > db.coll.insert({ a: { b: 23, c: 44 } })                                                            // 97   // 2885\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })                                                             // 98   // 2886\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23 } }                                 // 99   // 2887\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })                                                             // 100  // 2888\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23, \"c\" : 44 } }                       // 101  // 2889\n      //                                                                                                      // 102  // 2890\n      // Note, how second time the return set of keys is different.                                           // 103  // 2891\n                                                                                                              // 104  // 2892\n      var currentPath = fullPath;                                                                             // 105  // 2893\n      var anotherPath = path;                                                                                 // 106  // 2894\n      throw MinimongoError(\"both \" + currentPath + \" and \" + anotherPath +                                    // 107  // 2895\n                           \" found in fields option, using both of them may trigger \" +                       // 108  // 2896\n                           \"unexpected behavior. Did you mean to use only one of them?\");                     // 109  // 2897\n    });                                                                                                       // 110  // 2898\n                                                                                                              // 111  // 2899\n  return {                                                                                                    // 112  // 2900\n    tree: projectionRulesTree,                                                                                // 113  // 2901\n    including: including                                                                                      // 114  // 2902\n  };                                                                                                          // 115  // 2903\n};                                                                                                            // 116  // 2904\n                                                                                                              // 117  // 2905\n// paths - Array: list of mongo style paths                                                                   // 118  // 2906\n// newLeafFn - Function: of form function(path) should return a scalar value to                               // 119  // 2907\n//                       put into list created for that path                                                  // 120  // 2908\n// conflictFn - Function: of form function(node, path, fullPath) is called                                    // 121  // 2909\n//                        when building a tree path for 'fullPath' node on                                    // 122  // 2910\n//                        'path' was already a leaf with a value. Must return a                               // 123  // 2911\n//                        conflict resolution.                                                                // 124  // 2912\n// initial tree - Optional Object: starting tree.                                                             // 125  // 2913\n// @returns - Object: tree represented as a set of nested objects                                             // 126  // 2914\npathsToTree = function (paths, newLeafFn, conflictFn, tree) {                                                 // 127  // 2915\n  tree = tree || {};                                                                                          // 128  // 2916\n  _.each(paths, function (keyPath) {                                                                          // 129  // 2917\n    var treePos = tree;                                                                                       // 130  // 2918\n    var pathArr = keyPath.split('.');                                                                         // 131  // 2919\n                                                                                                              // 132  // 2920\n    // use _.all just for iteration with break                                                                // 133  // 2921\n    var success = _.all(pathArr.slice(0, -1), function (key, idx) {                                           // 134  // 2922\n      if (!_.has(treePos, key))                                                                               // 135  // 2923\n        treePos[key] = {};                                                                                    // 136  // 2924\n      else if (!_.isObject(treePos[key])) {                                                                   // 137  // 2925\n        treePos[key] = conflictFn(treePos[key],                                                               // 138  // 2926\n                                  pathArr.slice(0, idx + 1).join('.'),                                        // 139  // 2927\n                                  keyPath);                                                                   // 140  // 2928\n        // break out of loop if we are failing for this path                                                  // 141  // 2929\n        if (!_.isObject(treePos[key]))                                                                        // 142  // 2930\n          return false;                                                                                       // 143  // 2931\n      }                                                                                                       // 144  // 2932\n                                                                                                              // 145  // 2933\n      treePos = treePos[key];                                                                                 // 146  // 2934\n      return true;                                                                                            // 147  // 2935\n    });                                                                                                       // 148  // 2936\n                                                                                                              // 149  // 2937\n    if (success) {                                                                                            // 150  // 2938\n      var lastKey = _.last(pathArr);                                                                          // 151  // 2939\n      if (!_.has(treePos, lastKey))                                                                           // 152  // 2940\n        treePos[lastKey] = newLeafFn(keyPath);                                                                // 153  // 2941\n      else                                                                                                    // 154  // 2942\n        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);                                    // 155  // 2943\n    }                                                                                                         // 156  // 2944\n  });                                                                                                         // 157  // 2945\n                                                                                                              // 158  // 2946\n  return tree;                                                                                                // 159  // 2947\n};                                                                                                            // 160  // 2948\n                                                                                                              // 161  // 2949\nLocalCollection._checkSupportedProjection = function (fields) {                                               // 162  // 2950\n  if (!_.isObject(fields) || _.isArray(fields))                                                               // 163  // 2951\n    throw MinimongoError(\"fields option must be an object\");                                                  // 164  // 2952\n                                                                                                              // 165  // 2953\n  _.each(fields, function (val, keyPath) {                                                                    // 166  // 2954\n    if (_.contains(keyPath.split('.'), '$'))                                                                  // 167  // 2955\n      throw MinimongoError(\"Minimongo doesn't support $ operator in projections yet.\");                       // 168  // 2956\n    if (typeof val === 'object' && _.intersection(['$elemMatch', '$meta', '$slice'], _.keys(val)).length > 0)         // 2957\n      throw MinimongoError(\"Minimongo doesn't support operators in projections yet.\");                        // 170  // 2958\n    if (_.indexOf([1, 0, true, false], val) === -1)                                                           // 171  // 2959\n      throw MinimongoError(\"Projection values should be one of 1, 0, true, or false\");                        // 172  // 2960\n  });                                                                                                         // 173  // 2961\n};                                                                                                            // 174  // 2962\n                                                                                                              // 175  // 2963\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2964\n                                                                                                                      // 2965\n}).call(this);                                                                                                        // 2966\n                                                                                                                      // 2967\n                                                                                                                      // 2968\n                                                                                                                      // 2969\n                                                                                                                      // 2970\n                                                                                                                      // 2971\n                                                                                                                      // 2972\n(function(){                                                                                                          // 2973\n                                                                                                                      // 2974\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2975\n//                                                                                                            //      // 2976\n// packages/minimongo/modify.js                                                                               //      // 2977\n//                                                                                                            //      // 2978\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 2979\n                                                                                                              //      // 2980\n// XXX need a strategy for passing the binding of $ into this                                                 // 1    // 2981\n// function, from the compiled selector                                                                       // 2    // 2982\n//                                                                                                            // 3    // 2983\n// maybe just {key.up.to.just.before.dollarsign: array_index}                                                 // 4    // 2984\n//                                                                                                            // 5    // 2985\n// XXX atomicity: if one modification fails, do we roll back the whole                                        // 6    // 2986\n// change?                                                                                                    // 7    // 2987\n//                                                                                                            // 8    // 2988\n// options:                                                                                                   // 9    // 2989\n//   - isInsert is set when _modify is being called to compute the document to                                // 10   // 2990\n//     insert as part of an upsert operation. We use this primarily to figure                                 // 11   // 2991\n//     out when to set the fields in $setOnInsert, if present.                                                // 12   // 2992\nLocalCollection._modify = function (doc, mod, options) {                                                      // 13   // 2993\n  options = options || {};                                                                                    // 14   // 2994\n  if (!isPlainObject(mod))                                                                                    // 15   // 2995\n    throw MinimongoError(\"Modifier must be an object\");                                                       // 16   // 2996\n                                                                                                              // 17   // 2997\n  // Make sure the caller can't mutate our data structures.                                                   // 18   // 2998\n  mod = EJSON.clone(mod);                                                                                     // 19   // 2999\n                                                                                                              // 20   // 3000\n  var isModifier = isOperatorObject(mod);                                                                     // 21   // 3001\n                                                                                                              // 22   // 3002\n  var newDoc;                                                                                                 // 23   // 3003\n                                                                                                              // 24   // 3004\n  if (!isModifier) {                                                                                          // 25   // 3005\n    if (mod._id && !EJSON.equals(doc._id, mod._id))                                                           // 26   // 3006\n      throw MinimongoError(\"Cannot change the _id of a document\");                                            // 27   // 3007\n                                                                                                              // 28   // 3008\n    // replace the whole document                                                                             // 29   // 3009\n    for (var k in mod) {                                                                                      // 30   // 3010\n      if (/\\./.test(k))                                                                                       // 31   // 3011\n        throw MinimongoError(                                                                                 // 32   // 3012\n          \"When replacing document, field name may not contain '.'\");                                         // 33   // 3013\n    }                                                                                                         // 34   // 3014\n    newDoc = mod;                                                                                             // 35   // 3015\n  } else {                                                                                                    // 36   // 3016\n    // apply modifiers to the doc.                                                                            // 37   // 3017\n    newDoc = EJSON.clone(doc);                                                                                // 38   // 3018\n                                                                                                              // 39   // 3019\n    _.each(mod, function (operand, op) {                                                                      // 40   // 3020\n      var modFunc = MODIFIERS[op];                                                                            // 41   // 3021\n      // Treat $setOnInsert as $set if this is an insert.                                                     // 42   // 3022\n      if (options.isInsert && op === '$setOnInsert')                                                          // 43   // 3023\n        modFunc = MODIFIERS['$set'];                                                                          // 44   // 3024\n      if (!modFunc)                                                                                           // 45   // 3025\n        throw MinimongoError(\"Invalid modifier specified \" + op);                                             // 46   // 3026\n      _.each(operand, function (arg, keypath) {                                                               // 47   // 3027\n        if (keypath === '') {                                                                                 // 48   // 3028\n          throw MinimongoError(\"An empty update path is not valid.\");                                         // 49   // 3029\n        }                                                                                                     // 50   // 3030\n                                                                                                              // 51   // 3031\n        if (keypath === '_id') {                                                                              // 52   // 3032\n          throw MinimongoError(\"Mod on _id not allowed\");                                                     // 53   // 3033\n        }                                                                                                     // 54   // 3034\n                                                                                                              // 55   // 3035\n        var keyparts = keypath.split('.');                                                                    // 56   // 3036\n                                                                                                              // 57   // 3037\n        if (! _.all(keyparts, _.identity)) {                                                                  // 58   // 3038\n          throw MinimongoError(                                                                               // 59   // 3039\n            \"The update path '\" + keypath +                                                                   // 60   // 3040\n              \"' contains an empty field name, which is not allowed.\");                                       // 61   // 3041\n        }                                                                                                     // 62   // 3042\n                                                                                                              // 63   // 3043\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);                                                        // 64   // 3044\n        var forbidArray = (op === \"$rename\");                                                                 // 65   // 3045\n        var target = findModTarget(newDoc, keyparts, {                                                        // 66   // 3046\n          noCreate: NO_CREATE_MODIFIERS[op],                                                                  // 67   // 3047\n          forbidArray: (op === \"$rename\"),                                                                    // 68   // 3048\n          arrayIndices: options.arrayIndices                                                                  // 69   // 3049\n        });                                                                                                   // 70   // 3050\n        var field = keyparts.pop();                                                                           // 71   // 3051\n        modFunc(target, field, arg, keypath, newDoc);                                                         // 72   // 3052\n      });                                                                                                     // 73   // 3053\n    });                                                                                                       // 74   // 3054\n  }                                                                                                           // 75   // 3055\n                                                                                                              // 76   // 3056\n  // move new document into place.                                                                            // 77   // 3057\n  _.each(_.keys(doc), function (k) {                                                                          // 78   // 3058\n    // Note: this used to be for (var k in doc) however, this does not                                        // 79   // 3059\n    // work right in Opera. Deleting from a doc while iterating over it                                       // 80   // 3060\n    // would sometimes cause opera to skip some keys.                                                         // 81   // 3061\n    if (k !== '_id')                                                                                          // 82   // 3062\n      delete doc[k];                                                                                          // 83   // 3063\n  });                                                                                                         // 84   // 3064\n  _.each(newDoc, function (v, k) {                                                                            // 85   // 3065\n    doc[k] = v;                                                                                               // 86   // 3066\n  });                                                                                                         // 87   // 3067\n};                                                                                                            // 88   // 3068\n                                                                                                              // 89   // 3069\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],                                        // 90   // 3070\n// and then you would operate on the 'e' property of the returned                                             // 91   // 3071\n// object.                                                                                                    // 92   // 3072\n//                                                                                                            // 93   // 3073\n// if options.noCreate is falsey, creates intermediate levels of                                              // 94   // 3074\n// structure as necessary, like mkdir -p (and raises an exception if                                          // 95   // 3075\n// that would mean giving a non-numeric property to an array.) if                                             // 96   // 3076\n// options.noCreate is true, return undefined instead.                                                        // 97   // 3077\n//                                                                                                            // 98   // 3078\n// may modify the last element of keyparts to signal to the caller that it needs                              // 99   // 3079\n// to use a different value to index into the returned object (for example,                                   // 100  // 3080\n// ['a', '01'] -> ['a', 1]).                                                                                  // 101  // 3081\n//                                                                                                            // 102  // 3082\n// if forbidArray is true, return null if the keypath goes through an array.                                  // 103  // 3083\n//                                                                                                            // 104  // 3084\n// if options.arrayIndices is set, use its first element for the (first) '$' in                               // 105  // 3085\n// the path.                                                                                                  // 106  // 3086\nvar findModTarget = function (doc, keyparts, options) {                                                       // 107  // 3087\n  options = options || {};                                                                                    // 108  // 3088\n  var usedArrayIndex = false;                                                                                 // 109  // 3089\n  for (var i = 0; i < keyparts.length; i++) {                                                                 // 110  // 3090\n    var last = (i === keyparts.length - 1);                                                                   // 111  // 3091\n    var keypart = keyparts[i];                                                                                // 112  // 3092\n    var indexable = isIndexable(doc);                                                                         // 113  // 3093\n    if (!indexable) {                                                                                         // 114  // 3094\n      if (options.noCreate)                                                                                   // 115  // 3095\n        return undefined;                                                                                     // 116  // 3096\n      var e = MinimongoError(                                                                                 // 117  // 3097\n        \"cannot use the part '\" + keypart + \"' to traverse \" + doc);                                          // 118  // 3098\n      e.setPropertyError = true;                                                                              // 119  // 3099\n      throw e;                                                                                                // 120  // 3100\n    }                                                                                                         // 121  // 3101\n    if (doc instanceof Array) {                                                                               // 122  // 3102\n      if (options.forbidArray)                                                                                // 123  // 3103\n        return null;                                                                                          // 124  // 3104\n      if (keypart === '$') {                                                                                  // 125  // 3105\n        if (usedArrayIndex)                                                                                   // 126  // 3106\n          throw MinimongoError(\"Too many positional (i.e. '$') elements\");                                    // 127  // 3107\n        if (!options.arrayIndices || !options.arrayIndices.length) {                                          // 128  // 3108\n          throw MinimongoError(\"The positional operator did not find the \" +                                  // 129  // 3109\n                               \"match needed from the query\");                                                // 130  // 3110\n        }                                                                                                     // 131  // 3111\n        keypart = options.arrayIndices[0];                                                                    // 132  // 3112\n        usedArrayIndex = true;                                                                                // 133  // 3113\n      } else if (isNumericKey(keypart)) {                                                                     // 134  // 3114\n        keypart = parseInt(keypart);                                                                          // 135  // 3115\n      } else {                                                                                                // 136  // 3116\n        if (options.noCreate)                                                                                 // 137  // 3117\n          return undefined;                                                                                   // 138  // 3118\n        throw MinimongoError(                                                                                 // 139  // 3119\n          \"can't append to array using string field name [\"                                                   // 140  // 3120\n                    + keypart + \"]\");                                                                         // 141  // 3121\n      }                                                                                                       // 142  // 3122\n      if (last)                                                                                               // 143  // 3123\n        // handle 'a.01'                                                                                      // 144  // 3124\n        keyparts[i] = keypart;                                                                                // 145  // 3125\n      if (options.noCreate && keypart >= doc.length)                                                          // 146  // 3126\n        return undefined;                                                                                     // 147  // 3127\n      while (doc.length < keypart)                                                                            // 148  // 3128\n        doc.push(null);                                                                                       // 149  // 3129\n      if (!last) {                                                                                            // 150  // 3130\n        if (doc.length === keypart)                                                                           // 151  // 3131\n          doc.push({});                                                                                       // 152  // 3132\n        else if (typeof doc[keypart] !== \"object\")                                                            // 153  // 3133\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] +                                     // 154  // 3134\n                      \"' of list value \" + JSON.stringify(doc[keypart]));                                     // 155  // 3135\n      }                                                                                                       // 156  // 3136\n    } else {                                                                                                  // 157  // 3137\n      if (keypart.length && keypart.substr(0, 1) === '$')                                                     // 158  // 3138\n        throw MinimongoError(\"can't set field named \" + keypart);                                             // 159  // 3139\n      if (!(keypart in doc)) {                                                                                // 160  // 3140\n        if (options.noCreate)                                                                                 // 161  // 3141\n          return undefined;                                                                                   // 162  // 3142\n        if (!last)                                                                                            // 163  // 3143\n          doc[keypart] = {};                                                                                  // 164  // 3144\n      }                                                                                                       // 165  // 3145\n    }                                                                                                         // 166  // 3146\n                                                                                                              // 167  // 3147\n    if (last)                                                                                                 // 168  // 3148\n      return doc;                                                                                             // 169  // 3149\n    doc = doc[keypart];                                                                                       // 170  // 3150\n  }                                                                                                           // 171  // 3151\n                                                                                                              // 172  // 3152\n  // notreached                                                                                               // 173  // 3153\n};                                                                                                            // 174  // 3154\n                                                                                                              // 175  // 3155\nvar NO_CREATE_MODIFIERS = {                                                                                   // 176  // 3156\n  $unset: true,                                                                                               // 177  // 3157\n  $pop: true,                                                                                                 // 178  // 3158\n  $rename: true,                                                                                              // 179  // 3159\n  $pull: true,                                                                                                // 180  // 3160\n  $pullAll: true                                                                                              // 181  // 3161\n};                                                                                                            // 182  // 3162\n                                                                                                              // 183  // 3163\nvar MODIFIERS = {                                                                                             // 184  // 3164\n  $inc: function (target, field, arg) {                                                                       // 185  // 3165\n    if (typeof arg !== \"number\")                                                                              // 186  // 3166\n      throw MinimongoError(\"Modifier $inc allowed for numbers only\");                                         // 187  // 3167\n    if (field in target) {                                                                                    // 188  // 3168\n      if (typeof target[field] !== \"number\")                                                                  // 189  // 3169\n        throw MinimongoError(\"Cannot apply $inc modifier to non-number\");                                     // 190  // 3170\n      target[field] += arg;                                                                                   // 191  // 3171\n    } else {                                                                                                  // 192  // 3172\n      target[field] = arg;                                                                                    // 193  // 3173\n    }                                                                                                         // 194  // 3174\n  },                                                                                                          // 195  // 3175\n  $set: function (target, field, arg) {                                                                       // 196  // 3176\n    if (!_.isObject(target)) { // not an array or an object                                                   // 197  // 3177\n      var e = MinimongoError(\"Cannot set property on non-object field\");                                      // 198  // 3178\n      e.setPropertyError = true;                                                                              // 199  // 3179\n      throw e;                                                                                                // 200  // 3180\n    }                                                                                                         // 201  // 3181\n    if (target === null) {                                                                                    // 202  // 3182\n      var e = MinimongoError(\"Cannot set property on null\");                                                  // 203  // 3183\n      e.setPropertyError = true;                                                                              // 204  // 3184\n      throw e;                                                                                                // 205  // 3185\n    }                                                                                                         // 206  // 3186\n    target[field] = arg;                                                                                      // 207  // 3187\n  },                                                                                                          // 208  // 3188\n  $setOnInsert: function (target, field, arg) {                                                               // 209  // 3189\n    // converted to `$set` in `_modify`                                                                       // 210  // 3190\n  },                                                                                                          // 211  // 3191\n  $unset: function (target, field, arg) {                                                                     // 212  // 3192\n    if (target !== undefined) {                                                                               // 213  // 3193\n      if (target instanceof Array) {                                                                          // 214  // 3194\n        if (field in target)                                                                                  // 215  // 3195\n          target[field] = null;                                                                               // 216  // 3196\n      } else                                                                                                  // 217  // 3197\n        delete target[field];                                                                                 // 218  // 3198\n    }                                                                                                         // 219  // 3199\n  },                                                                                                          // 220  // 3200\n  $push: function (target, field, arg) {                                                                      // 221  // 3201\n    if (target[field] === undefined)                                                                          // 222  // 3202\n      target[field] = [];                                                                                     // 223  // 3203\n    if (!(target[field] instanceof Array))                                                                    // 224  // 3204\n      throw MinimongoError(\"Cannot apply $push modifier to non-array\");                                       // 225  // 3205\n                                                                                                              // 226  // 3206\n    if (!(arg && arg.$each)) {                                                                                // 227  // 3207\n      // Simple mode: not $each                                                                               // 228  // 3208\n      target[field].push(arg);                                                                                // 229  // 3209\n      return;                                                                                                 // 230  // 3210\n    }                                                                                                         // 231  // 3211\n                                                                                                              // 232  // 3212\n    // Fancy mode: $each (and maybe $slice and $sort and $position)                                           // 233  // 3213\n    var toPush = arg.$each;                                                                                   // 234  // 3214\n    if (!(toPush instanceof Array))                                                                           // 235  // 3215\n      throw MinimongoError(\"$each must be an array\");                                                         // 236  // 3216\n                                                                                                              // 237  // 3217\n    // Parse $position                                                                                        // 238  // 3218\n    var position = undefined;                                                                                 // 239  // 3219\n    if ('$position' in arg) {                                                                                 // 240  // 3220\n      if (typeof arg.$position !== \"number\")                                                                  // 241  // 3221\n        throw MinimongoError(\"$position must be a numeric value\");                                            // 242  // 3222\n      // XXX should check to make sure integer                                                                // 243  // 3223\n      if (arg.$position < 0)                                                                                  // 244  // 3224\n        throw MinimongoError(\"$position in $push must be zero or positive\");                                  // 245  // 3225\n      position = arg.$position;                                                                               // 246  // 3226\n    }                                                                                                         // 247  // 3227\n                                                                                                              // 248  // 3228\n    // Parse $slice.                                                                                          // 249  // 3229\n    var slice = undefined;                                                                                    // 250  // 3230\n    if ('$slice' in arg) {                                                                                    // 251  // 3231\n      if (typeof arg.$slice !== \"number\")                                                                     // 252  // 3232\n        throw MinimongoError(\"$slice must be a numeric value\");                                               // 253  // 3233\n      // XXX should check to make sure integer                                                                // 254  // 3234\n      if (arg.$slice > 0)                                                                                     // 255  // 3235\n        throw MinimongoError(\"$slice in $push must be zero or negative\");                                     // 256  // 3236\n      slice = arg.$slice;                                                                                     // 257  // 3237\n    }                                                                                                         // 258  // 3238\n                                                                                                              // 259  // 3239\n    // Parse $sort.                                                                                           // 260  // 3240\n    var sortFunction = undefined;                                                                             // 261  // 3241\n    if (arg.$sort) {                                                                                          // 262  // 3242\n      if (slice === undefined)                                                                                // 263  // 3243\n        throw MinimongoError(\"$sort requires $slice to be present\");                                          // 264  // 3244\n      // XXX this allows us to use a $sort whose value is an array, but that's                                // 265  // 3245\n      // actually an extension of the Node driver, so it won't work                                           // 266  // 3246\n      // server-side. Could be confusing!                                                                     // 267  // 3247\n      // XXX is it correct that we don't do geo-stuff here?                                                   // 268  // 3248\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();                                         // 269  // 3249\n      for (var i = 0; i < toPush.length; i++) {                                                               // 270  // 3250\n        if (LocalCollection._f._type(toPush[i]) !== 3) {                                                      // 271  // 3251\n          throw MinimongoError(\"$push like modifiers using $sort \" +                                          // 272  // 3252\n                      \"require all elements to be objects\");                                                  // 273  // 3253\n        }                                                                                                     // 274  // 3254\n      }                                                                                                       // 275  // 3255\n    }                                                                                                         // 276  // 3256\n                                                                                                              // 277  // 3257\n    // Actually push.                                                                                         // 278  // 3258\n    if (position === undefined) {                                                                             // 279  // 3259\n      for (var j = 0; j < toPush.length; j++)                                                                 // 280  // 3260\n        target[field].push(toPush[j]);                                                                        // 281  // 3261\n    } else {                                                                                                  // 282  // 3262\n      var spliceArguments = [position, 0];                                                                    // 283  // 3263\n      for (var j = 0; j < toPush.length; j++)                                                                 // 284  // 3264\n        spliceArguments.push(toPush[j]);                                                                      // 285  // 3265\n      Array.prototype.splice.apply(target[field], spliceArguments);                                           // 286  // 3266\n    }                                                                                                         // 287  // 3267\n                                                                                                              // 288  // 3268\n    // Actually sort.                                                                                         // 289  // 3269\n    if (sortFunction)                                                                                         // 290  // 3270\n      target[field].sort(sortFunction);                                                                       // 291  // 3271\n                                                                                                              // 292  // 3272\n    // Actually slice.                                                                                        // 293  // 3273\n    if (slice !== undefined) {                                                                                // 294  // 3274\n      if (slice === 0)                                                                                        // 295  // 3275\n        target[field] = [];  // differs from Array.slice!                                                     // 296  // 3276\n      else                                                                                                    // 297  // 3277\n        target[field] = target[field].slice(slice);                                                           // 298  // 3278\n    }                                                                                                         // 299  // 3279\n  },                                                                                                          // 300  // 3280\n  $pushAll: function (target, field, arg) {                                                                   // 301  // 3281\n    if (!(typeof arg === \"object\" && arg instanceof Array))                                                   // 302  // 3282\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");                              // 303  // 3283\n    var x = target[field];                                                                                    // 304  // 3284\n    if (x === undefined)                                                                                      // 305  // 3285\n      target[field] = arg;                                                                                    // 306  // 3286\n    else if (!(x instanceof Array))                                                                           // 307  // 3287\n      throw MinimongoError(\"Cannot apply $pushAll modifier to non-array\");                                    // 308  // 3288\n    else {                                                                                                    // 309  // 3289\n      for (var i = 0; i < arg.length; i++)                                                                    // 310  // 3290\n        x.push(arg[i]);                                                                                       // 311  // 3291\n    }                                                                                                         // 312  // 3292\n  },                                                                                                          // 313  // 3293\n  $addToSet: function (target, field, arg) {                                                                  // 314  // 3294\n    var isEach = false;                                                                                       // 315  // 3295\n    if (typeof arg === \"object\") {                                                                            // 316  // 3296\n      //check if first key is '$each'                                                                         // 317  // 3297\n      for (var k in arg) {                                                                                    // 318  // 3298\n        if (k === \"$each\")                                                                                    // 319  // 3299\n          isEach = true;                                                                                      // 320  // 3300\n        break;                                                                                                // 321  // 3301\n      }                                                                                                       // 322  // 3302\n    }                                                                                                         // 323  // 3303\n    var values = isEach ? arg[\"$each\"] : [arg];                                                               // 324  // 3304\n    var x = target[field];                                                                                    // 325  // 3305\n    if (x === undefined)                                                                                      // 326  // 3306\n      target[field] = values;                                                                                 // 327  // 3307\n    else if (!(x instanceof Array))                                                                           // 328  // 3308\n      throw MinimongoError(\"Cannot apply $addToSet modifier to non-array\");                                   // 329  // 3309\n    else {                                                                                                    // 330  // 3310\n      _.each(values, function (value) {                                                                       // 331  // 3311\n        for (var i = 0; i < x.length; i++)                                                                    // 332  // 3312\n          if (LocalCollection._f._equal(value, x[i]))                                                         // 333  // 3313\n            return;                                                                                           // 334  // 3314\n        x.push(value);                                                                                        // 335  // 3315\n      });                                                                                                     // 336  // 3316\n    }                                                                                                         // 337  // 3317\n  },                                                                                                          // 338  // 3318\n  $pop: function (target, field, arg) {                                                                       // 339  // 3319\n    if (target === undefined)                                                                                 // 340  // 3320\n      return;                                                                                                 // 341  // 3321\n    var x = target[field];                                                                                    // 342  // 3322\n    if (x === undefined)                                                                                      // 343  // 3323\n      return;                                                                                                 // 344  // 3324\n    else if (!(x instanceof Array))                                                                           // 345  // 3325\n      throw MinimongoError(\"Cannot apply $pop modifier to non-array\");                                        // 346  // 3326\n    else {                                                                                                    // 347  // 3327\n      if (typeof arg === 'number' && arg < 0)                                                                 // 348  // 3328\n        x.splice(0, 1);                                                                                       // 349  // 3329\n      else                                                                                                    // 350  // 3330\n        x.pop();                                                                                              // 351  // 3331\n    }                                                                                                         // 352  // 3332\n  },                                                                                                          // 353  // 3333\n  $pull: function (target, field, arg) {                                                                      // 354  // 3334\n    if (target === undefined)                                                                                 // 355  // 3335\n      return;                                                                                                 // 356  // 3336\n    var x = target[field];                                                                                    // 357  // 3337\n    if (x === undefined)                                                                                      // 358  // 3338\n      return;                                                                                                 // 359  // 3339\n    else if (!(x instanceof Array))                                                                           // 360  // 3340\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");                               // 361  // 3341\n    else {                                                                                                    // 362  // 3342\n      var out = [];                                                                                           // 363  // 3343\n      if (typeof arg === \"object\" && !(arg instanceof Array)) {                                               // 364  // 3344\n        // XXX would be much nicer to compile this once, rather than                                          // 365  // 3345\n        // for each document we modify.. but usually we're not                                                // 366  // 3346\n        // modifying that many documents, so we'll let it slide for                                           // 367  // 3347\n        // now                                                                                                // 368  // 3348\n                                                                                                              // 369  // 3349\n        // XXX Minimongo.Matcher isn't up for the job, because we need                                        // 370  // 3350\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something                                            // 371  // 3351\n        // like {$gt: 4} is not normally a complete selector.                                                 // 372  // 3352\n        // same issue as $elemMatch possibly?                                                                 // 373  // 3353\n        var matcher = new Minimongo.Matcher(arg);                                                             // 374  // 3354\n        for (var i = 0; i < x.length; i++)                                                                    // 375  // 3355\n          if (!matcher.documentMatches(x[i]).result)                                                          // 376  // 3356\n            out.push(x[i]);                                                                                   // 377  // 3357\n      } else {                                                                                                // 378  // 3358\n        for (var i = 0; i < x.length; i++)                                                                    // 379  // 3359\n          if (!LocalCollection._f._equal(x[i], arg))                                                          // 380  // 3360\n            out.push(x[i]);                                                                                   // 381  // 3361\n      }                                                                                                       // 382  // 3362\n      target[field] = out;                                                                                    // 383  // 3363\n    }                                                                                                         // 384  // 3364\n  },                                                                                                          // 385  // 3365\n  $pullAll: function (target, field, arg) {                                                                   // 386  // 3366\n    if (!(typeof arg === \"object\" && arg instanceof Array))                                                   // 387  // 3367\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");                              // 388  // 3368\n    if (target === undefined)                                                                                 // 389  // 3369\n      return;                                                                                                 // 390  // 3370\n    var x = target[field];                                                                                    // 391  // 3371\n    if (x === undefined)                                                                                      // 392  // 3372\n      return;                                                                                                 // 393  // 3373\n    else if (!(x instanceof Array))                                                                           // 394  // 3374\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");                               // 395  // 3375\n    else {                                                                                                    // 396  // 3376\n      var out = [];                                                                                           // 397  // 3377\n      for (var i = 0; i < x.length; i++) {                                                                    // 398  // 3378\n        var exclude = false;                                                                                  // 399  // 3379\n        for (var j = 0; j < arg.length; j++) {                                                                // 400  // 3380\n          if (LocalCollection._f._equal(x[i], arg[j])) {                                                      // 401  // 3381\n            exclude = true;                                                                                   // 402  // 3382\n            break;                                                                                            // 403  // 3383\n          }                                                                                                   // 404  // 3384\n        }                                                                                                     // 405  // 3385\n        if (!exclude)                                                                                         // 406  // 3386\n          out.push(x[i]);                                                                                     // 407  // 3387\n      }                                                                                                       // 408  // 3388\n      target[field] = out;                                                                                    // 409  // 3389\n    }                                                                                                         // 410  // 3390\n  },                                                                                                          // 411  // 3391\n  $rename: function (target, field, arg, keypath, doc) {                                                      // 412  // 3392\n    if (keypath === arg)                                                                                      // 413  // 3393\n      // no idea why mongo has this restriction..                                                             // 414  // 3394\n      throw MinimongoError(\"$rename source must differ from target\");                                         // 415  // 3395\n    if (target === null)                                                                                      // 416  // 3396\n      throw MinimongoError(\"$rename source field invalid\");                                                   // 417  // 3397\n    if (typeof arg !== \"string\")                                                                              // 418  // 3398\n      throw MinimongoError(\"$rename target must be a string\");                                                // 419  // 3399\n    if (target === undefined)                                                                                 // 420  // 3400\n      return;                                                                                                 // 421  // 3401\n    var v = target[field];                                                                                    // 422  // 3402\n    delete target[field];                                                                                     // 423  // 3403\n                                                                                                              // 424  // 3404\n    var keyparts = arg.split('.');                                                                            // 425  // 3405\n    var target2 = findModTarget(doc, keyparts, {forbidArray: true});                                          // 426  // 3406\n    if (target2 === null)                                                                                     // 427  // 3407\n      throw MinimongoError(\"$rename target field invalid\");                                                   // 428  // 3408\n    var field2 = keyparts.pop();                                                                              // 429  // 3409\n    target2[field2] = v;                                                                                      // 430  // 3410\n  },                                                                                                          // 431  // 3411\n  $bit: function (target, field, arg) {                                                                       // 432  // 3412\n    // XXX mongo only supports $bit on integers, and we only support                                          // 433  // 3413\n    // native javascript numbers (doubles) so far, so we can't support $bit                                   // 434  // 3414\n    throw MinimongoError(\"$bit is not supported\");                                                            // 435  // 3415\n  }                                                                                                           // 436  // 3416\n};                                                                                                            // 437  // 3417\n                                                                                                              // 438  // 3418\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3419\n                                                                                                                      // 3420\n}).call(this);                                                                                                        // 3421\n                                                                                                                      // 3422\n                                                                                                                      // 3423\n                                                                                                                      // 3424\n                                                                                                                      // 3425\n                                                                                                                      // 3426\n                                                                                                                      // 3427\n(function(){                                                                                                          // 3428\n                                                                                                                      // 3429\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3430\n//                                                                                                            //      // 3431\n// packages/minimongo/diff.js                                                                                 //      // 3432\n//                                                                                                            //      // 3433\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3434\n                                                                                                              //      // 3435\n// ordered: bool.                                                                                             // 1    // 3436\n// old_results and new_results: collections of documents.                                                     // 2    // 3437\n//    if ordered, they are arrays.                                                                            // 3    // 3438\n//    if unordered, they are IdMaps                                                                           // 4    // 3439\nLocalCollection._diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {           // 5    // 3440\n  return DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);                   // 6    // 3441\n};                                                                                                            // 7    // 3442\n                                                                                                              // 8    // 3443\nLocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {           // 9    // 3444\n  return DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);                   // 10   // 3445\n};                                                                                                            // 11   // 3446\n                                                                                                              // 12   // 3447\n                                                                                                              // 13   // 3448\nLocalCollection._diffQueryOrderedChanges =                                                                    // 14   // 3449\n  function (oldResults, newResults, observer, options) {                                                      // 15   // 3450\n  return DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);                     // 16   // 3451\n};                                                                                                            // 17   // 3452\n                                                                                                              // 18   // 3453\nLocalCollection._diffObjects = function (left, right, callbacks) {                                            // 19   // 3454\n  return DiffSequence.diffObjects(left, right, callbacks);                                                    // 20   // 3455\n};                                                                                                            // 21   // 3456\n                                                                                                              // 22   // 3457\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3458\n                                                                                                                      // 3459\n}).call(this);                                                                                                        // 3460\n                                                                                                                      // 3461\n                                                                                                                      // 3462\n                                                                                                                      // 3463\n                                                                                                                      // 3464\n                                                                                                                      // 3465\n                                                                                                                      // 3466\n(function(){                                                                                                          // 3467\n                                                                                                                      // 3468\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3469\n//                                                                                                            //      // 3470\n// packages/minimongo/id_map.js                                                                               //      // 3471\n//                                                                                                            //      // 3472\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3473\n                                                                                                              //      // 3474\nLocalCollection._IdMap = function () {                                                                        // 1    // 3475\n  var self = this;                                                                                            // 2    // 3476\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);                                                     // 3    // 3477\n};                                                                                                            // 4    // 3478\n                                                                                                              // 5    // 3479\nMeteor._inherits(LocalCollection._IdMap, IdMap);                                                              // 6    // 3480\n                                                                                                              // 7    // 3481\n                                                                                                              // 8    // 3482\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3483\n                                                                                                                      // 3484\n}).call(this);                                                                                                        // 3485\n                                                                                                                      // 3486\n                                                                                                                      // 3487\n                                                                                                                      // 3488\n                                                                                                                      // 3489\n                                                                                                                      // 3490\n                                                                                                                      // 3491\n(function(){                                                                                                          // 3492\n                                                                                                                      // 3493\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3494\n//                                                                                                            //      // 3495\n// packages/minimongo/observe.js                                                                              //      // 3496\n//                                                                                                            //      // 3497\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3498\n                                                                                                              //      // 3499\n// XXX maybe move these into another ObserveHelpers package or something                                      // 1    // 3500\n                                                                                                              // 2    // 3501\n// _CachingChangeObserver is an object which receives observeChanges callbacks                                // 3    // 3502\n// and keeps a cache of the current cursor state up to date in self.docs. Users                               // 4    // 3503\n// of this class should read the docs field but not modify it. You should pass                                // 5    // 3504\n// the \"applyChange\" field as the callbacks to the underlying observeChanges                                  // 6    // 3505\n// call. Optionally, you can specify your own observeChanges callbacks which are                              // 7    // 3506\n// invoked immediately before the docs field is updated; this object is made                                  // 8    // 3507\n// available as `this` to those callbacks.                                                                    // 9    // 3508\nLocalCollection._CachingChangeObserver = function (options) {                                                 // 10   // 3509\n  var self = this;                                                                                            // 11   // 3510\n  options = options || {};                                                                                    // 12   // 3511\n                                                                                                              // 13   // 3512\n  var orderedFromCallbacks = options.callbacks &&                                                             // 14   // 3513\n        LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);                                // 15   // 3514\n  if (_.has(options, 'ordered')) {                                                                            // 16   // 3515\n    self.ordered = options.ordered;                                                                           // 17   // 3516\n    if (options.callbacks && options.ordered !== orderedFromCallbacks)                                        // 18   // 3517\n      throw Error(\"ordered option doesn't match callbacks\");                                                  // 19   // 3518\n  } else if (options.callbacks) {                                                                             // 20   // 3519\n    self.ordered = orderedFromCallbacks;                                                                      // 21   // 3520\n  } else {                                                                                                    // 22   // 3521\n    throw Error(\"must provide ordered or callbacks\");                                                         // 23   // 3522\n  }                                                                                                           // 24   // 3523\n  var callbacks = options.callbacks || {};                                                                    // 25   // 3524\n                                                                                                              // 26   // 3525\n  if (self.ordered) {                                                                                         // 27   // 3526\n    self.docs = new OrderedDict(MongoID.idStringify);                                                         // 28   // 3527\n    self.applyChange = {                                                                                      // 29   // 3528\n      addedBefore: function (id, fields, before) {                                                            // 30   // 3529\n        var doc = EJSON.clone(fields);                                                                        // 31   // 3530\n        doc._id = id;                                                                                         // 32   // 3531\n        callbacks.addedBefore && callbacks.addedBefore.call(                                                  // 33   // 3532\n          self, id, fields, before);                                                                          // 34   // 3533\n        // This line triggers if we provide added with movedBefore.                                           // 35   // 3534\n        callbacks.added && callbacks.added.call(self, id, fields);                                            // 36   // 3535\n        // XXX could `before` be a falsy ID?  Technically                                                     // 37   // 3536\n        // idStringify seems to allow for them -- though                                                      // 38   // 3537\n        // OrderedDict won't call stringify on a falsy arg.                                                   // 39   // 3538\n        self.docs.putBefore(id, doc, before || null);                                                         // 40   // 3539\n      },                                                                                                      // 41   // 3540\n      movedBefore: function (id, before) {                                                                    // 42   // 3541\n        var doc = self.docs.get(id);                                                                          // 43   // 3542\n        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);                                // 44   // 3543\n        self.docs.moveBefore(id, before || null);                                                             // 45   // 3544\n      }                                                                                                       // 46   // 3545\n    };                                                                                                        // 47   // 3546\n  } else {                                                                                                    // 48   // 3547\n    self.docs = new LocalCollection._IdMap;                                                                   // 49   // 3548\n    self.applyChange = {                                                                                      // 50   // 3549\n      added: function (id, fields) {                                                                          // 51   // 3550\n        var doc = EJSON.clone(fields);                                                                        // 52   // 3551\n        callbacks.added && callbacks.added.call(self, id, fields);                                            // 53   // 3552\n        doc._id = id;                                                                                         // 54   // 3553\n        self.docs.set(id,  doc);                                                                              // 55   // 3554\n      }                                                                                                       // 56   // 3555\n    };                                                                                                        // 57   // 3556\n  }                                                                                                           // 58   // 3557\n                                                                                                              // 59   // 3558\n  // The methods in _IdMap and OrderedDict used by these callbacks are                                        // 60   // 3559\n  // identical.                                                                                               // 61   // 3560\n  self.applyChange.changed = function (id, fields) {                                                          // 62   // 3561\n    var doc = self.docs.get(id);                                                                              // 63   // 3562\n    if (!doc)                                                                                                 // 64   // 3563\n      throw new Error(\"Unknown id for changed: \" + id);                                                       // 65   // 3564\n    callbacks.changed && callbacks.changed.call(                                                              // 66   // 3565\n      self, id, EJSON.clone(fields));                                                                         // 67   // 3566\n    DiffSequence.applyChanges(doc, fields);                                                                   // 68   // 3567\n  };                                                                                                          // 69   // 3568\n  self.applyChange.removed = function (id) {                                                                  // 70   // 3569\n    callbacks.removed && callbacks.removed.call(self, id);                                                    // 71   // 3570\n    self.docs.remove(id);                                                                                     // 72   // 3571\n  };                                                                                                          // 73   // 3572\n};                                                                                                            // 74   // 3573\n                                                                                                              // 75   // 3574\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {                            // 76   // 3575\n  var transform = cursor.getTransform() || function (doc) {return doc;};                                      // 77   // 3576\n  var suppressed = !!observeCallbacks._suppress_initial;                                                      // 78   // 3577\n                                                                                                              // 79   // 3578\n  var observeChangesCallbacks;                                                                                // 80   // 3579\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {                                        // 81   // 3580\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the                                  // 82   // 3581\n    // linear scans required to generate them.  This lets observers that don't                                // 83   // 3582\n    // need absolute indices benefit from the other features of this API --                                   // 84   // 3583\n    // relative order, transforms, and applyChanges -- without the speed hit.                                 // 85   // 3584\n    var indices = !observeCallbacks._no_indices;                                                              // 86   // 3585\n    observeChangesCallbacks = {                                                                               // 87   // 3586\n      addedBefore: function (id, fields, before) {                                                            // 88   // 3587\n        var self = this;                                                                                      // 89   // 3588\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added))                              // 90   // 3589\n          return;                                                                                             // 91   // 3590\n        var doc = transform(_.extend(fields, {_id: id}));                                                     // 92   // 3591\n        if (observeCallbacks.addedAt) {                                                                       // 93   // 3592\n          var index = indices                                                                                 // 94   // 3593\n                ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                               // 95   // 3594\n          observeCallbacks.addedAt(doc, index, before);                                                       // 96   // 3595\n        } else {                                                                                              // 97   // 3596\n          observeCallbacks.added(doc);                                                                        // 98   // 3597\n        }                                                                                                     // 99   // 3598\n      },                                                                                                      // 100  // 3599\n      changed: function (id, fields) {                                                                        // 101  // 3600\n        var self = this;                                                                                      // 102  // 3601\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed))                                        // 103  // 3602\n          return;                                                                                             // 104  // 3603\n        var doc = EJSON.clone(self.docs.get(id));                                                             // 105  // 3604\n        if (!doc)                                                                                             // 106  // 3605\n          throw new Error(\"Unknown id for changed: \" + id);                                                   // 107  // 3606\n        var oldDoc = transform(EJSON.clone(doc));                                                             // 108  // 3607\n        DiffSequence.applyChanges(doc, fields);                                                               // 109  // 3608\n        doc = transform(doc);                                                                                 // 110  // 3609\n        if (observeCallbacks.changedAt) {                                                                     // 111  // 3610\n          var index = indices ? self.docs.indexOf(id) : -1;                                                   // 112  // 3611\n          observeCallbacks.changedAt(doc, oldDoc, index);                                                     // 113  // 3612\n        } else {                                                                                              // 114  // 3613\n          observeCallbacks.changed(doc, oldDoc);                                                              // 115  // 3614\n        }                                                                                                     // 116  // 3615\n      },                                                                                                      // 117  // 3616\n      movedBefore: function (id, before) {                                                                    // 118  // 3617\n        var self = this;                                                                                      // 119  // 3618\n        if (!observeCallbacks.movedTo)                                                                        // 120  // 3619\n          return;                                                                                             // 121  // 3620\n        var from = indices ? self.docs.indexOf(id) : -1;                                                      // 122  // 3621\n                                                                                                              // 123  // 3622\n        var to = indices                                                                                      // 124  // 3623\n              ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                                 // 125  // 3624\n        // When not moving backwards, adjust for the fact that removing the                                   // 126  // 3625\n        // document slides everything back one slot.                                                          // 127  // 3626\n        if (to > from)                                                                                        // 128  // 3627\n          --to;                                                                                               // 129  // 3628\n        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))),                                   // 130  // 3629\n                                 from, to, before || null);                                                   // 131  // 3630\n      },                                                                                                      // 132  // 3631\n      removed: function (id) {                                                                                // 133  // 3632\n        var self = this;                                                                                      // 134  // 3633\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed))                                        // 135  // 3634\n          return;                                                                                             // 136  // 3635\n        // technically maybe there should be an EJSON.clone here, but it's about                              // 137  // 3636\n        // to be removed from self.docs!                                                                      // 138  // 3637\n        var doc = transform(self.docs.get(id));                                                               // 139  // 3638\n        if (observeCallbacks.removedAt) {                                                                     // 140  // 3639\n          var index = indices ? self.docs.indexOf(id) : -1;                                                   // 141  // 3640\n          observeCallbacks.removedAt(doc, index);                                                             // 142  // 3641\n        } else {                                                                                              // 143  // 3642\n          observeCallbacks.removed(doc);                                                                      // 144  // 3643\n        }                                                                                                     // 145  // 3644\n      }                                                                                                       // 146  // 3645\n    };                                                                                                        // 147  // 3646\n  } else {                                                                                                    // 148  // 3647\n    observeChangesCallbacks = {                                                                               // 149  // 3648\n      added: function (id, fields) {                                                                          // 150  // 3649\n        if (!suppressed && observeCallbacks.added) {                                                          // 151  // 3650\n          var doc = _.extend(fields, {_id:  id});                                                             // 152  // 3651\n          observeCallbacks.added(transform(doc));                                                             // 153  // 3652\n        }                                                                                                     // 154  // 3653\n      },                                                                                                      // 155  // 3654\n      changed: function (id, fields) {                                                                        // 156  // 3655\n        var self = this;                                                                                      // 157  // 3656\n        if (observeCallbacks.changed) {                                                                       // 158  // 3657\n          var oldDoc = self.docs.get(id);                                                                     // 159  // 3658\n          var doc = EJSON.clone(oldDoc);                                                                      // 160  // 3659\n          DiffSequence.applyChanges(doc, fields);                                                             // 161  // 3660\n          observeCallbacks.changed(transform(doc),                                                            // 162  // 3661\n                                   transform(EJSON.clone(oldDoc)));                                           // 163  // 3662\n        }                                                                                                     // 164  // 3663\n      },                                                                                                      // 165  // 3664\n      removed: function (id) {                                                                                // 166  // 3665\n        var self = this;                                                                                      // 167  // 3666\n        if (observeCallbacks.removed) {                                                                       // 168  // 3667\n          observeCallbacks.removed(transform(self.docs.get(id)));                                             // 169  // 3668\n        }                                                                                                     // 170  // 3669\n      }                                                                                                       // 171  // 3670\n    };                                                                                                        // 172  // 3671\n  }                                                                                                           // 173  // 3672\n                                                                                                              // 174  // 3673\n  var changeObserver = new LocalCollection._CachingChangeObserver(                                            // 175  // 3674\n    {callbacks: observeChangesCallbacks});                                                                    // 176  // 3675\n  var handle = cursor.observeChanges(changeObserver.applyChange);                                             // 177  // 3676\n  suppressed = false;                                                                                         // 178  // 3677\n                                                                                                              // 179  // 3678\n  return handle;                                                                                              // 180  // 3679\n};                                                                                                            // 181  // 3680\n                                                                                                              // 182  // 3681\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3682\n                                                                                                                      // 3683\n}).call(this);                                                                                                        // 3684\n                                                                                                                      // 3685\n                                                                                                                      // 3686\n                                                                                                                      // 3687\n                                                                                                                      // 3688\n                                                                                                                      // 3689\n                                                                                                                      // 3690\n(function(){                                                                                                          // 3691\n                                                                                                                      // 3692\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3693\n//                                                                                                            //      // 3694\n// packages/minimongo/objectid.js                                                                             //      // 3695\n//                                                                                                            //      // 3696\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3697\n                                                                                                              //      // 3698\n// Is this selector just shorthand for lookup by _id?                                                         // 1    // 3699\nLocalCollection._selectorIsId = function (selector) {                                                         // 2    // 3700\n  return (typeof selector === \"string\") ||                                                                    // 3    // 3701\n    (typeof selector === \"number\") ||                                                                         // 4    // 3702\n    selector instanceof MongoID.ObjectID;                                                                     // 5    // 3703\n};                                                                                                            // 6    // 3704\n                                                                                                              // 7    // 3705\n// Is the selector just lookup by _id (shorthand or not)?                                                     // 8    // 3706\nLocalCollection._selectorIsIdPerhapsAsObject = function (selector) {                                          // 9    // 3707\n  return LocalCollection._selectorIsId(selector) ||                                                           // 10   // 3708\n    (selector && typeof selector === \"object\" &&                                                              // 11   // 3709\n     selector._id && LocalCollection._selectorIsId(selector._id) &&                                           // 12   // 3710\n     _.size(selector) === 1);                                                                                 // 13   // 3711\n};                                                                                                            // 14   // 3712\n                                                                                                              // 15   // 3713\n// If this is a selector which explicitly constrains the match by ID to a finite                              // 16   // 3714\n// number of documents, returns a list of their IDs.  Otherwise returns                                       // 17   // 3715\n// null. Note that the selector may have other restrictions so it may not even                                // 18   // 3716\n// match those document!  We care about $in and $and since those are generated                                // 19   // 3717\n// access-controlled update and remove.                                                                       // 20   // 3718\nLocalCollection._idsMatchedBySelector = function (selector) {                                                 // 21   // 3719\n  // Is the selector just an ID?                                                                              // 22   // 3720\n  if (LocalCollection._selectorIsId(selector))                                                                // 23   // 3721\n    return [selector];                                                                                        // 24   // 3722\n  if (!selector)                                                                                              // 25   // 3723\n    return null;                                                                                              // 26   // 3724\n                                                                                                              // 27   // 3725\n  // Do we have an _id clause?                                                                                // 28   // 3726\n  if (_.has(selector, '_id')) {                                                                               // 29   // 3727\n    // Is the _id clause just an ID?                                                                          // 30   // 3728\n    if (LocalCollection._selectorIsId(selector._id))                                                          // 31   // 3729\n      return [selector._id];                                                                                  // 32   // 3730\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?                                                       // 33   // 3731\n    if (selector._id && selector._id.$in                                                                      // 34   // 3732\n        && _.isArray(selector._id.$in)                                                                        // 35   // 3733\n        && !_.isEmpty(selector._id.$in)                                                                       // 36   // 3734\n        && _.all(selector._id.$in, LocalCollection._selectorIsId)) {                                          // 37   // 3735\n      return selector._id.$in;                                                                                // 38   // 3736\n    }                                                                                                         // 39   // 3737\n    return null;                                                                                              // 40   // 3738\n  }                                                                                                           // 41   // 3739\n                                                                                                              // 42   // 3740\n  // If this is a top-level $and, and any of the clauses constrain their                                      // 43   // 3741\n  // documents, then the whole selector is constrained by any one clause's                                    // 44   // 3742\n  // constraint. (Well, by their intersection, but that seems unlikely.)                                      // 45   // 3743\n  if (selector.$and && _.isArray(selector.$and)) {                                                            // 46   // 3744\n    for (var i = 0; i < selector.$and.length; ++i) {                                                          // 47   // 3745\n      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);                                   // 48   // 3746\n      if (subIds)                                                                                             // 49   // 3747\n        return subIds;                                                                                        // 50   // 3748\n    }                                                                                                         // 51   // 3749\n  }                                                                                                           // 52   // 3750\n                                                                                                              // 53   // 3751\n  return null;                                                                                                // 54   // 3752\n};                                                                                                            // 55   // 3753\n                                                                                                              // 56   // 3754\n                                                                                                              // 57   // 3755\n                                                                                                              // 58   // 3756\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3757\n                                                                                                                      // 3758\n}).call(this);                                                                                                        // 3759\n                                                                                                                      // 3760\n                                                                                                                      // 3761\n                                                                                                                      // 3762\n                                                                                                                      // 3763\n                                                                                                                      // 3764\n                                                                                                                      // 3765\n(function(){                                                                                                          // 3766\n                                                                                                                      // 3767\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3768\n//                                                                                                            //      // 3769\n// packages/minimongo/selector_projection.js                                                                  //      // 3770\n//                                                                                                            //      // 3771\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3772\n                                                                                                              //      // 3773\n// Knows how to combine a mongo selector and a fields projection to a new fields                              // 1    // 3774\n// projection taking into account active fields from the passed selector.                                     // 2    // 3775\n// @returns Object - projection object (same as fields option of mongo cursor)                                // 3    // 3776\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {                                   // 4    // 3777\n  var self = this;                                                                                            // 5    // 3778\n  var selectorPaths = Minimongo._pathsElidingNumericKeys(self._getPaths());                                   // 6    // 3779\n                                                                                                              // 7    // 3780\n  // Special case for $where operator in the selector - projection should depend                              // 8    // 3781\n  // on all fields of the document. getSelectorPaths returns a list of paths                                  // 9    // 3782\n  // selector depends on. If one of the paths is '' (empty string) representing                               // 10   // 3783\n  // the root or the whole document, complete projection should be returned.                                  // 11   // 3784\n  if (_.contains(selectorPaths, ''))                                                                          // 12   // 3785\n    return {};                                                                                                // 13   // 3786\n                                                                                                              // 14   // 3787\n  return combineImportantPathsIntoProjection(selectorPaths, projection);                                      // 15   // 3788\n};                                                                                                            // 16   // 3789\n                                                                                                              // 17   // 3790\nMinimongo._pathsElidingNumericKeys = function (paths) {                                                       // 18   // 3791\n  var self = this;                                                                                            // 19   // 3792\n  return _.map(paths, function (path) {                                                                       // 20   // 3793\n    return _.reject(path.split('.'), isNumericKey).join('.');                                                 // 21   // 3794\n  });                                                                                                         // 22   // 3795\n};                                                                                                            // 23   // 3796\n                                                                                                              // 24   // 3797\ncombineImportantPathsIntoProjection = function (paths, projection) {                                          // 25   // 3798\n  var prjDetails = projectionDetails(projection);                                                             // 26   // 3799\n  var tree = prjDetails.tree;                                                                                 // 27   // 3800\n  var mergedProjection = {};                                                                                  // 28   // 3801\n                                                                                                              // 29   // 3802\n  // merge the paths to include                                                                               // 30   // 3803\n  tree = pathsToTree(paths,                                                                                   // 31   // 3804\n                     function (path) { return true; },                                                        // 32   // 3805\n                     function (node, path, fullPath) { return true; },                                        // 33   // 3806\n                     tree);                                                                                   // 34   // 3807\n  mergedProjection = treeToPaths(tree);                                                                       // 35   // 3808\n  if (prjDetails.including) {                                                                                 // 36   // 3809\n    // both selector and projection are pointing on fields to include                                         // 37   // 3810\n    // so we can just return the merged tree                                                                  // 38   // 3811\n    return mergedProjection;                                                                                  // 39   // 3812\n  } else {                                                                                                    // 40   // 3813\n    // selector is pointing at fields to include                                                              // 41   // 3814\n    // projection is pointing at fields to exclude                                                            // 42   // 3815\n    // make sure we don't exclude important paths                                                             // 43   // 3816\n    var mergedExclProjection = {};                                                                            // 44   // 3817\n    _.each(mergedProjection, function (incl, path) {                                                          // 45   // 3818\n      if (!incl)                                                                                              // 46   // 3819\n        mergedExclProjection[path] = false;                                                                   // 47   // 3820\n    });                                                                                                       // 48   // 3821\n                                                                                                              // 49   // 3822\n    return mergedExclProjection;                                                                              // 50   // 3823\n  }                                                                                                           // 51   // 3824\n};                                                                                                            // 52   // 3825\n                                                                                                              // 53   // 3826\n// Returns a set of key paths similar to                                                                      // 54   // 3827\n// { 'foo.bar': 1, 'a.b.c': 1 }                                                                               // 55   // 3828\nvar treeToPaths = function (tree, prefix) {                                                                   // 56   // 3829\n  prefix = prefix || '';                                                                                      // 57   // 3830\n  var result = {};                                                                                            // 58   // 3831\n                                                                                                              // 59   // 3832\n  _.each(tree, function (val, key) {                                                                          // 60   // 3833\n    if (_.isObject(val))                                                                                      // 61   // 3834\n      _.extend(result, treeToPaths(val, prefix + key + '.'));                                                 // 62   // 3835\n    else                                                                                                      // 63   // 3836\n      result[prefix + key] = val;                                                                             // 64   // 3837\n  });                                                                                                         // 65   // 3838\n                                                                                                              // 66   // 3839\n  return result;                                                                                              // 67   // 3840\n};                                                                                                            // 68   // 3841\n                                                                                                              // 69   // 3842\n                                                                                                              // 70   // 3843\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3844\n                                                                                                                      // 3845\n}).call(this);                                                                                                        // 3846\n                                                                                                                      // 3847\n                                                                                                                      // 3848\n                                                                                                                      // 3849\n                                                                                                                      // 3850\n                                                                                                                      // 3851\n                                                                                                                      // 3852\n(function(){                                                                                                          // 3853\n                                                                                                                      // 3854\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3855\n//                                                                                                            //      // 3856\n// packages/minimongo/selector_modifier.js                                                                    //      // 3857\n//                                                                                                            //      // 3858\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 3859\n                                                                                                              //      // 3860\n// Returns true if the modifier applied to some document may change the result                                // 1    // 3861\n// of matching the document by selector                                                                       // 2    // 3862\n// The modifier is always in a form of Object:                                                                // 3    // 3863\n//  - $set                                                                                                    // 4    // 3864\n//    - 'a.b.22.z': value                                                                                     // 5    // 3865\n//    - 'foo.bar': 42                                                                                         // 6    // 3866\n//  - $unset                                                                                                  // 7    // 3867\n//    - 'abc.d': 1                                                                                            // 8    // 3868\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {                                        // 9    // 3869\n  var self = this;                                                                                            // 10   // 3870\n  // safe check for $set/$unset being objects                                                                 // 11   // 3871\n  modifier = _.extend({ $set: {}, $unset: {} }, modifier);                                                    // 12   // 3872\n  var modifiedPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));                                  // 13   // 3873\n  var meaningfulPaths = self._getPaths();                                                                     // 14   // 3874\n                                                                                                              // 15   // 3875\n  return _.any(modifiedPaths, function (path) {                                                               // 16   // 3876\n    var mod = path.split('.');                                                                                // 17   // 3877\n    return _.any(meaningfulPaths, function (meaningfulPath) {                                                 // 18   // 3878\n      var sel = meaningfulPath.split('.');                                                                    // 19   // 3879\n      var i = 0, j = 0;                                                                                       // 20   // 3880\n                                                                                                              // 21   // 3881\n      while (i < sel.length && j < mod.length) {                                                              // 22   // 3882\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {                                                   // 23   // 3883\n          // foo.4.bar selector affected by foo.4 modifier                                                    // 24   // 3884\n          // foo.3.bar selector unaffected by foo.4 modifier                                                  // 25   // 3885\n          if (sel[i] === mod[j])                                                                              // 26   // 3886\n            i++, j++;                                                                                         // 27   // 3887\n          else                                                                                                // 28   // 3888\n            return false;                                                                                     // 29   // 3889\n        } else if (isNumericKey(sel[i])) {                                                                    // 30   // 3890\n          // foo.4.bar selector unaffected by foo.bar modifier                                                // 31   // 3891\n          return false;                                                                                       // 32   // 3892\n        } else if (isNumericKey(mod[j])) {                                                                    // 33   // 3893\n          j++;                                                                                                // 34   // 3894\n        } else if (sel[i] === mod[j])                                                                         // 35   // 3895\n          i++, j++;                                                                                           // 36   // 3896\n        else                                                                                                  // 37   // 3897\n          return false;                                                                                       // 38   // 3898\n      }                                                                                                       // 39   // 3899\n                                                                                                              // 40   // 3900\n      // One is a prefix of another, taking numeric fields into account                                       // 41   // 3901\n      return true;                                                                                            // 42   // 3902\n    });                                                                                                       // 43   // 3903\n  });                                                                                                         // 44   // 3904\n};                                                                                                            // 45   // 3905\n                                                                                                              // 46   // 3906\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made                               // 47   // 3907\n// for this exact purpose.                                                                                    // 48   // 3908\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {                                         // 49   // 3909\n  var self = this;                                                                                            // 50   // 3910\n  return self._selectorForAffectedByModifier.affectedByModifier(modifier);                                    // 51   // 3911\n};                                                                                                            // 52   // 3912\n                                                                                                              // 53   // 3913\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`                               // 54   // 3914\n//                           only. (assumed to come from oplog)                                               // 55   // 3915\n// @returns - Boolean: if after applying the modifier, selector can start                                     // 56   // 3916\n//                     accepting the modified value.                                                          // 57   // 3917\n// NOTE: assumes that document affected by modifier didn't match this Matcher                                 // 58   // 3918\n// before, so if modifier can't convince selector in a positive change it would                               // 59   // 3919\n// stay 'false'.                                                                                              // 60   // 3920\n// Currently doesn't support $-operators and numeric indices precisely.                                       // 61   // 3921\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {                                   // 62   // 3922\n  var self = this;                                                                                            // 63   // 3923\n  if (!this.affectedByModifier(modifier))                                                                     // 64   // 3924\n    return false;                                                                                             // 65   // 3925\n                                                                                                              // 66   // 3926\n  modifier = _.extend({$set:{}, $unset:{}}, modifier);                                                        // 67   // 3927\n  var modifierPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));                                  // 68   // 3928\n                                                                                                              // 69   // 3929\n  if (!self.isSimple())                                                                                       // 70   // 3930\n    return true;                                                                                              // 71   // 3931\n                                                                                                              // 72   // 3932\n  if (_.any(self._getPaths(), pathHasNumericKeys) ||                                                          // 73   // 3933\n      _.any(modifierPaths, pathHasNumericKeys))                                                               // 74   // 3934\n    return true;                                                                                              // 75   // 3935\n                                                                                                              // 76   // 3936\n  // check if there is a $set or $unset that indicates something is an                                        // 77   // 3937\n  // object rather than a scalar in the actual object where we saw $-operator                                 // 78   // 3938\n  // NOTE: it is correct since we allow only scalars in $-operators                                           // 79   // 3939\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would                                   // 80   // 3940\n  // definitely set the result to false as 'a.b' appears to be an object.                                     // 81   // 3941\n  var expectedScalarIsObject = _.any(self._selector, function (sel, path) {                                   // 82   // 3942\n    if (! isOperatorObject(sel))                                                                              // 83   // 3943\n      return false;                                                                                           // 84   // 3944\n    return _.any(modifierPaths, function (modifierPath) {                                                     // 85   // 3945\n      return startsWith(modifierPath, path + '.');                                                            // 86   // 3946\n    });                                                                                                       // 87   // 3947\n  });                                                                                                         // 88   // 3948\n                                                                                                              // 89   // 3949\n  if (expectedScalarIsObject)                                                                                 // 90   // 3950\n    return false;                                                                                             // 91   // 3951\n                                                                                                              // 92   // 3952\n  // See if we can apply the modifier on the ideally matching object. If it                                   // 93   // 3953\n  // still matches the selector, then the modifier could have turned the real                                 // 94   // 3954\n  // object in the database into something matching.                                                          // 95   // 3955\n  var matchingDocument = EJSON.clone(self.matchingDocument());                                                // 96   // 3956\n                                                                                                              // 97   // 3957\n  // The selector is too complex, anything can happen.                                                        // 98   // 3958\n  if (matchingDocument === null)                                                                              // 99   // 3959\n    return true;                                                                                              // 100  // 3960\n                                                                                                              // 101  // 3961\n  try {                                                                                                       // 102  // 3962\n    LocalCollection._modify(matchingDocument, modifier);                                                      // 103  // 3963\n  } catch (e) {                                                                                               // 104  // 3964\n    // Couldn't set a property on a field which is a scalar or null in the                                    // 105  // 3965\n    // selector.                                                                                              // 106  // 3966\n    // Example:                                                                                               // 107  // 3967\n    // real document: { 'a.b': 3 }                                                                            // 108  // 3968\n    // selector: { 'a': 12 }                                                                                  // 109  // 3969\n    // converted selector (ideal document): { 'a': 12 }                                                       // 110  // 3970\n    // modifier: { $set: { 'a.b': 4 } }                                                                       // 111  // 3971\n    // We don't know what real document was like but from the error raised by                                 // 112  // 3972\n    // $set on a scalar field we can reason that the structure of real document                               // 113  // 3973\n    // is completely different.                                                                               // 114  // 3974\n    if (e.name === \"MinimongoError\" && e.setPropertyError)                                                    // 115  // 3975\n      return false;                                                                                           // 116  // 3976\n    throw e;                                                                                                  // 117  // 3977\n  }                                                                                                           // 118  // 3978\n                                                                                                              // 119  // 3979\n  return self.documentMatches(matchingDocument).result;                                                       // 120  // 3980\n};                                                                                                            // 121  // 3981\n                                                                                                              // 122  // 3982\n// Returns an object that would match the selector if possible or null if the                                 // 123  // 3983\n// selector is too complex for us to analyze                                                                  // 124  // 3984\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }                                            // 125  // 3985\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }                                         // 126  // 3986\nMinimongo.Matcher.prototype.matchingDocument = function () {                                                  // 127  // 3987\n  var self = this;                                                                                            // 128  // 3988\n                                                                                                              // 129  // 3989\n  // check if it was computed before                                                                          // 130  // 3990\n  if (self._matchingDocument !== undefined)                                                                   // 131  // 3991\n    return self._matchingDocument;                                                                            // 132  // 3992\n                                                                                                              // 133  // 3993\n  // If the analysis of this selector is too hard for our implementation                                      // 134  // 3994\n  // fallback to \"YES\"                                                                                        // 135  // 3995\n  var fallback = false;                                                                                       // 136  // 3996\n  self._matchingDocument = pathsToTree(self._getPaths(),                                                      // 137  // 3997\n    function (path) {                                                                                         // 138  // 3998\n      var valueSelector = self._selector[path];                                                               // 139  // 3999\n      if (isOperatorObject(valueSelector)) {                                                                  // 140  // 4000\n        // if there is a strict equality, there is a good                                                     // 141  // 4001\n        // chance we can use one of those as \"matching\"                                                       // 142  // 4002\n        // dummy value                                                                                        // 143  // 4003\n        if (valueSelector.$in) {                                                                              // 144  // 4004\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });                                // 145  // 4005\n                                                                                                              // 146  // 4006\n          // Return anything from $in that matches the whole selector for this                                // 147  // 4007\n          // path. If nothing matches, returns `undefined` as nothing can make                                // 148  // 4008\n          // this selector into `true`.                                                                       // 149  // 4009\n          return _.find(valueSelector.$in, function (x) {                                                     // 150  // 4010\n            return matcher.documentMatches({ placeholder: x }).result;                                        // 151  // 4011\n          });                                                                                                 // 152  // 4012\n        } else if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {                         // 153  // 4013\n          var lowerBound = -Infinity, upperBound = Infinity;                                                  // 154  // 4014\n          _.each(['$lte', '$lt'], function (op) {                                                             // 155  // 4015\n            if (_.has(valueSelector, op) && valueSelector[op] < upperBound)                                   // 156  // 4016\n              upperBound = valueSelector[op];                                                                 // 157  // 4017\n          });                                                                                                 // 158  // 4018\n          _.each(['$gte', '$gt'], function (op) {                                                             // 159  // 4019\n            if (_.has(valueSelector, op) && valueSelector[op] > lowerBound)                                   // 160  // 4020\n              lowerBound = valueSelector[op];                                                                 // 161  // 4021\n          });                                                                                                 // 162  // 4022\n                                                                                                              // 163  // 4023\n          var middle = (lowerBound + upperBound) / 2;                                                         // 164  // 4024\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });                                // 165  // 4025\n          if (!matcher.documentMatches({ placeholder: middle }).result &&                                     // 166  // 4026\n              (middle === lowerBound || middle === upperBound))                                               // 167  // 4027\n            fallback = true;                                                                                  // 168  // 4028\n                                                                                                              // 169  // 4029\n          return middle;                                                                                      // 170  // 4030\n        } else if (onlyContainsKeys(valueSelector, ['$nin',' $ne'])) {                                        // 171  // 4031\n          // Since self._isSimple makes sure $nin and $ne are not combined with                               // 172  // 4032\n          // objects or arrays, we can confidently return an empty object as it                               // 173  // 4033\n          // never matches any scalar.                                                                        // 174  // 4034\n          return {};                                                                                          // 175  // 4035\n        } else {                                                                                              // 176  // 4036\n          fallback = true;                                                                                    // 177  // 4037\n        }                                                                                                     // 178  // 4038\n      }                                                                                                       // 179  // 4039\n      return self._selector[path];                                                                            // 180  // 4040\n    },                                                                                                        // 181  // 4041\n    _.identity /*conflict resolution is no resolution*/);                                                     // 182  // 4042\n                                                                                                              // 183  // 4043\n  if (fallback)                                                                                               // 184  // 4044\n    self._matchingDocument = null;                                                                            // 185  // 4045\n                                                                                                              // 186  // 4046\n  return self._matchingDocument;                                                                              // 187  // 4047\n};                                                                                                            // 188  // 4048\n                                                                                                              // 189  // 4049\nvar getPaths = function (sel) {                                                                               // 190  // 4050\n  return _.keys(new Minimongo.Matcher(sel)._paths);                                                           // 191  // 4051\n  return _.chain(sel).map(function (v, k) {                                                                   // 192  // 4052\n    // we don't know how to handle $where because it can be anything                                          // 193  // 4053\n    if (k === \"$where\")                                                                                       // 194  // 4054\n      return ''; // matches everything                                                                        // 195  // 4055\n    // we branch from $or/$and/$nor operator                                                                  // 196  // 4056\n    if (_.contains(['$or', '$and', '$nor'], k))                                                               // 197  // 4057\n      return _.map(v, getPaths);                                                                              // 198  // 4058\n    // the value is a literal or some comparison operator                                                     // 199  // 4059\n    return k;                                                                                                 // 200  // 4060\n  }).flatten().uniq().value();                                                                                // 201  // 4061\n};                                                                                                            // 202  // 4062\n                                                                                                              // 203  // 4063\n// A helper to ensure object has only certain keys                                                            // 204  // 4064\nvar onlyContainsKeys = function (obj, keys) {                                                                 // 205  // 4065\n  return _.all(obj, function (v, k) {                                                                         // 206  // 4066\n    return _.contains(keys, k);                                                                               // 207  // 4067\n  });                                                                                                         // 208  // 4068\n};                                                                                                            // 209  // 4069\n                                                                                                              // 210  // 4070\nvar pathHasNumericKeys = function (path) {                                                                    // 211  // 4071\n  return _.any(path.split('.'), isNumericKey);                                                                // 212  // 4072\n}                                                                                                             // 213  // 4073\n                                                                                                              // 214  // 4074\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                    // 215  // 4075\nvar startsWith = function(str, starts) {                                                                      // 216  // 4076\n  return str.length >= starts.length &&                                                                       // 217  // 4077\n    str.substring(0, starts.length) === starts;                                                               // 218  // 4078\n};                                                                                                            // 219  // 4079\n                                                                                                              // 220  // 4080\n                                                                                                              // 221  // 4081\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 4082\n                                                                                                                      // 4083\n}).call(this);                                                                                                        // 4084\n                                                                                                                      // 4085\n                                                                                                                      // 4086\n                                                                                                                      // 4087\n                                                                                                                      // 4088\n                                                                                                                      // 4089\n                                                                                                                      // 4090\n(function(){                                                                                                          // 4091\n                                                                                                                      // 4092\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 4093\n//                                                                                                            //      // 4094\n// packages/minimongo/sorter_projection.js                                                                    //      // 4095\n//                                                                                                            //      // 4096\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 4097\n                                                                                                              //      // 4098\nMinimongo.Sorter.prototype.combineIntoProjection = function (projection) {                                    // 1    // 4099\n  var self = this;                                                                                            // 2    // 4100\n  var specPaths = Minimongo._pathsElidingNumericKeys(self._getPaths());                                       // 3    // 4101\n  return combineImportantPathsIntoProjection(specPaths, projection);                                          // 4    // 4102\n};                                                                                                            // 5    // 4103\n                                                                                                              // 6    // 4104\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////      // 4105\n                                                                                                                      // 4106\n}).call(this);                                                                                                        // 4107\n                                                                                                                      // 4108\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.minimongo = {\n  LocalCollection: LocalCollection,\n  Minimongo: Minimongo,\n  MinimongoTest: MinimongoTest\n};\n\n})();\n","servePath":"/packages/minimongo.js","sourceMap":{"version":3,"sources":["/packages/minimongo/packages/minimongo.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/minimongo.js","sourcesContent":["(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/minimongo.js                                                                            //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// XXX type checking on selectors (graceful error if malformed)                                               // 1\n                                                                                                              // 2\n// LocalCollection: a set of documents that supports queries and modifiers.                                   // 3\n                                                                                                              // 4\n// Cursor: a specification for a particular subset of documents, w/                                           // 5\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),                        // 6\n                                                                                                              // 7\n// ObserveHandle: the return value of a live query.                                                           // 8\n                                                                                                              // 9\nLocalCollection = function (name) {                                                                           // 10\n  var self = this;                                                                                            // 11\n  self.name = name;                                                                                           // 12\n  // _id -> document (also containing id)                                                                     // 13\n  self._docs = new LocalCollection._IdMap;                                                                    // 14\n                                                                                                              // 15\n  self._observeQueue = new Meteor._SynchronousQueue();                                                        // 16\n                                                                                                              // 17\n  self.next_qid = 1; // live query id generator                                                               // 18\n                                                                                                              // 19\n  // qid -> live query object. keys:                                                                          // 20\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.                                  // 21\n  //  results: array (ordered) or object (unordered) of current results                                       // 22\n  //    (aliased with self._docs!)                                                                            // 23\n  //  resultsSnapshot: snapshot of results. null if not paused.                                               // 24\n  //  cursor: Cursor object for the query.                                                                    // 25\n  //  selector, sorter, (callbacks): functions                                                                // 26\n  self.queries = {};                                                                                          // 27\n                                                                                                              // 28\n  // null if not saving originals; an IdMap from id to original document value if                             // 29\n  // saving originals. See comments before saveOriginals().                                                   // 30\n  self._savedOriginals = null;                                                                                // 31\n                                                                                                              // 32\n  // True when observers are paused and we should not send callbacks.                                         // 33\n  self.paused = false;                                                                                        // 34\n};                                                                                                            // 35\n                                                                                                              // 36\nMinimongo = {};                                                                                               // 37\n                                                                                                              // 38\n// Object exported only for unit testing.                                                                     // 39\n// Use it to export private functions to test in Tinytest.                                                    // 40\nMinimongoTest = {};                                                                                           // 41\n                                                                                                              // 42\nMinimongoError = function (message) {                                                                         // 43\n  var e = new Error(message);                                                                                 // 44\n  e.name = \"MinimongoError\";                                                                                  // 45\n  return e;                                                                                                   // 46\n};                                                                                                            // 47\n                                                                                                              // 48\n                                                                                                              // 49\n// options may include sort, skip, limit, reactive                                                            // 50\n// sort may be any of these forms:                                                                            // 51\n//     {a: 1, b: -1}                                                                                          // 52\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]                                                                          // 53\n//     [\"a\", [\"b\", \"desc\"]]                                                                                   // 54\n//   (in the first form you're beholden to key enumeration order in                                           // 55\n//   your javascript VM)                                                                                      // 56\n//                                                                                                            // 57\n// reactive: if given, and false, don't register with Tracker (default                                        // 58\n// is true)                                                                                                   // 59\n//                                                                                                            // 60\n// XXX possibly should support retrieving a subset of fields? and                                             // 61\n// have it be a hint (ignored on the client, when not copying the                                             // 62\n// doc?)                                                                                                      // 63\n//                                                                                                            // 64\n// XXX sort does not yet support subkeys ('a.b') .. fix that!                                                 // 65\n// XXX add one more sort form: \"key\"                                                                          // 66\n// XXX tests                                                                                                  // 67\nLocalCollection.prototype.find = function (selector, options) {                                               // 68\n  // default syntax for everything is to omit the selector argument.                                          // 69\n  // but if selector is explicitly passed in as false or undefined, we                                        // 70\n  // want a selector that matches nothing.                                                                    // 71\n  if (arguments.length === 0)                                                                                 // 72\n    selector = {};                                                                                            // 73\n                                                                                                              // 74\n  return new LocalCollection.Cursor(this, selector, options);                                                 // 75\n};                                                                                                            // 76\n                                                                                                              // 77\n// don't call this ctor directly.  use LocalCollection.find().                                                // 78\n                                                                                                              // 79\nLocalCollection.Cursor = function (collection, selector, options) {                                           // 80\n  var self = this;                                                                                            // 81\n  if (!options) options = {};                                                                                 // 82\n                                                                                                              // 83\n  self.collection = collection;                                                                               // 84\n  self.sorter = null;                                                                                         // 85\n  self.matcher = new Minimongo.Matcher(selector);                                                             // 86\n                                                                                                              // 87\n  if (LocalCollection._selectorIsId(selector)) {                                                              // 88\n    // stash for fast path                                                                                    // 89\n    self._selectorId = selector;                                                                              // 90\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                        // 91\n    // also do the fast path for { _id: idString }                                                            // 92\n    self._selectorId = selector._id;                                                                          // 93\n  } else {                                                                                                    // 94\n    self._selectorId = undefined;                                                                             // 95\n    if (self.matcher.hasGeoQuery() || options.sort) {                                                         // 96\n      self.sorter = new Minimongo.Sorter(options.sort || [],                                                  // 97\n                                         { matcher: self.matcher });                                          // 98\n    }                                                                                                         // 99\n  }                                                                                                           // 100\n                                                                                                              // 101\n  self.skip = options.skip;                                                                                   // 102\n  self.limit = options.limit;                                                                                 // 103\n  self.fields = options.fields;                                                                               // 104\n                                                                                                              // 105\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});                                 // 106\n                                                                                                              // 107\n  self._transform = LocalCollection.wrapTransform(options.transform);                                         // 108\n                                                                                                              // 109\n  // by default, queries register w/ Tracker when it is available.                                            // 110\n  if (typeof Tracker !== \"undefined\")                                                                         // 111\n    self.reactive = (options.reactive === undefined) ? true : options.reactive;                               // 112\n};                                                                                                            // 113\n                                                                                                              // 114\n// Since we don't actually have a \"nextObject\" interface, there's really no                                   // 115\n// reason to have a \"rewind\" interface.  All it did was make multiple calls                                   // 116\n// to fetch/map/forEach return nothing the second time.                                                       // 117\n// XXX COMPAT WITH 0.8.1                                                                                      // 118\nLocalCollection.Cursor.prototype.rewind = function () {                                                       // 119\n};                                                                                                            // 120\n                                                                                                              // 121\nLocalCollection.prototype.findOne = function (selector, options) {                                            // 122\n  if (arguments.length === 0)                                                                                 // 123\n    selector = {};                                                                                            // 124\n                                                                                                              // 125\n  // NOTE: by setting limit 1 here, we end up using very inefficient                                          // 126\n  // code that recomputes the whole query on each update. The upside is                                       // 127\n  // that when you reactively depend on a findOne you only get                                                // 128\n  // invalidated when the found object changes, not any object in the                                         // 129\n  // collection. Most findOne will be by id, which has a fast path, so                                        // 130\n  // this might not be a big deal. In most cases, invalidation causes                                         // 131\n  // the called to re-query anyway, so this should be a net performance                                       // 132\n  // improvement.                                                                                             // 133\n  options = options || {};                                                                                    // 134\n  options.limit = 1;                                                                                          // 135\n                                                                                                              // 136\n  return this.find(selector, options).fetch()[0];                                                             // 137\n};                                                                                                            // 138\n                                                                                                              // 139\n/**                                                                                                           // 140\n * @callback IterationCallback                                                                                // 141\n * @param {Object} doc                                                                                        // 142\n * @param {Number} index                                                                                      // 143\n */                                                                                                           // 144\n/**                                                                                                           // 145\n * @summary Call `callback` once for each matching document, sequentially and synchronously.                  // 146\n * @locus Anywhere                                                                                            // 147\n * @method  forEach                                                                                           // 148\n * @instance                                                                                                  // 149\n * @memberOf Mongo.Cursor                                                                                     // 150\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                      // 152\n */                                                                                                           // 153\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {                                     // 154\n  var self = this;                                                                                            // 155\n                                                                                                              // 156\n  var objects = self._getRawObjects({ordered: true});                                                         // 157\n                                                                                                              // 158\n  if (self.reactive) {                                                                                        // 159\n    self._depend({                                                                                            // 160\n      addedBefore: true,                                                                                      // 161\n      removed: true,                                                                                          // 162\n      changed: true,                                                                                          // 163\n      movedBefore: true});                                                                                    // 164\n  }                                                                                                           // 165\n                                                                                                              // 166\n  _.each(objects, function (elt, i) {                                                                         // 167\n    // This doubles as a clone operation.                                                                     // 168\n    elt = self._projectionFn(elt);                                                                            // 169\n                                                                                                              // 170\n    if (self._transform)                                                                                      // 171\n      elt = self._transform(elt);                                                                             // 172\n    callback.call(thisArg, elt, i, self);                                                                     // 173\n  });                                                                                                         // 174\n};                                                                                                            // 175\n                                                                                                              // 176\nLocalCollection.Cursor.prototype.getTransform = function () {                                                 // 177\n  return this._transform;                                                                                     // 178\n};                                                                                                            // 179\n                                                                                                              // 180\n/**                                                                                                           // 181\n * @summary Map callback over all matching documents.  Returns an Array.                                      // 182\n * @locus Anywhere                                                                                            // 183\n * @method map                                                                                                // 184\n * @instance                                                                                                  // 185\n * @memberOf Mongo.Cursor                                                                                     // 186\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                      // 188\n */                                                                                                           // 189\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {                                         // 190\n  var self = this;                                                                                            // 191\n  var res = [];                                                                                               // 192\n  self.forEach(function (doc, index) {                                                                        // 193\n    res.push(callback.call(thisArg, doc, index, self));                                                       // 194\n  });                                                                                                         // 195\n  return res;                                                                                                 // 196\n};                                                                                                            // 197\n                                                                                                              // 198\n/**                                                                                                           // 199\n * @summary Return all matching documents as an Array.                                                        // 200\n * @memberOf Mongo.Cursor                                                                                     // 201\n * @method  fetch                                                                                             // 202\n * @instance                                                                                                  // 203\n * @locus Anywhere                                                                                            // 204\n * @returns {Object[]}                                                                                        // 205\n */                                                                                                           // 206\nLocalCollection.Cursor.prototype.fetch = function () {                                                        // 207\n  var self = this;                                                                                            // 208\n  var res = [];                                                                                               // 209\n  self.forEach(function (doc) {                                                                               // 210\n    res.push(doc);                                                                                            // 211\n  });                                                                                                         // 212\n  return res;                                                                                                 // 213\n};                                                                                                            // 214\n                                                                                                              // 215\n/**                                                                                                           // 216\n * @summary Returns the number of documents that match a query.                                               // 217\n * @memberOf Mongo.Cursor                                                                                     // 218\n * @method  count                                                                                             // 219\n * @instance                                                                                                  // 220\n * @locus Anywhere                                                                                            // 221\n * @returns {Number}                                                                                          // 222\n */                                                                                                           // 223\nLocalCollection.Cursor.prototype.count = function () {                                                        // 224\n  var self = this;                                                                                            // 225\n                                                                                                              // 226\n  if (self.reactive)                                                                                          // 227\n    self._depend({added: true, removed: true},                                                                // 228\n                 true /* allow the observe to be unordered */);                                               // 229\n                                                                                                              // 230\n  return self._getRawObjects({ordered: true}).length;                                                         // 231\n};                                                                                                            // 232\n                                                                                                              // 233\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {                                            // 234\n  var self = this;                                                                                            // 235\n  if (! self.collection.name)                                                                                 // 236\n    throw new Error(\"Can't publish a cursor from a collection without a name.\");                              // 237\n  var collection = self.collection.name;                                                                      // 238\n                                                                                                              // 239\n  // XXX minimongo should not depend on mongo-livedata!                                                       // 240\n  if (! Package.mongo) {                                                                                      // 241\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");                             // 242\n  }                                                                                                           // 243\n                                                                                                              // 244\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);                                // 245\n};                                                                                                            // 246\n                                                                                                              // 247\nLocalCollection.Cursor.prototype._getCollectionName = function () {                                           // 248\n  var self = this;                                                                                            // 249\n  return self.collection.name;                                                                                // 250\n};                                                                                                            // 251\n                                                                                                              // 252\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {                                   // 253\n  if (callbacks.added && callbacks.addedBefore)                                                               // 254\n    throw new Error(\"Please specify only one of added() and addedBefore()\");                                  // 255\n  return !!(callbacks.addedBefore || callbacks.movedBefore);                                                  // 256\n};                                                                                                            // 257\n                                                                                                              // 258\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {                                          // 259\n  if (callbacks.addedAt && callbacks.added)                                                                   // 260\n    throw new Error(\"Please specify only one of added() and addedAt()\");                                      // 261\n  if (callbacks.changedAt && callbacks.changed)                                                               // 262\n    throw new Error(\"Please specify only one of changed() and changedAt()\");                                  // 263\n  if (callbacks.removed && callbacks.removedAt)                                                               // 264\n    throw new Error(\"Please specify only one of removed() and removedAt()\");                                  // 265\n                                                                                                              // 266\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt                                     // 267\n            || callbacks.removedAt);                                                                          // 268\n};                                                                                                            // 269\n                                                                                                              // 270\n// the handle that comes back from observe.                                                                   // 271\nLocalCollection.ObserveHandle = function () {};                                                               // 272\n                                                                                                              // 273\n// options to contain:                                                                                        // 274\n//  * callbacks for observe():                                                                                // 275\n//    - addedAt (document, atIndex)                                                                           // 276\n//    - added (document)                                                                                      // 277\n//    - changedAt (newDocument, oldDocument, atIndex)                                                         // 278\n//    - changed (newDocument, oldDocument)                                                                    // 279\n//    - removedAt (document, atIndex)                                                                         // 280\n//    - removed (document)                                                                                    // 281\n//    - movedTo (document, oldIndex, newIndex)                                                                // 282\n//                                                                                                            // 283\n// attributes available on returned query handle:                                                             // 284\n//  * stop(): end updates                                                                                     // 285\n//  * collection: the collection this query is querying                                                       // 286\n//                                                                                                            // 287\n// iff x is a returned query handle, (x instanceof                                                            // 288\n// LocalCollection.ObserveHandle) is true                                                                     // 289\n//                                                                                                            // 290\n// initial results delivered through added callback                                                           // 291\n// XXX maybe callbacks should take a list of objects, to expose transactions?                                 // 292\n// XXX maybe support field limiting (to limit what you're notified on)                                        // 293\n                                                                                                              // 294\n_.extend(LocalCollection.Cursor.prototype, {                                                                  // 295\n  /**                                                                                                         // 296\n   * @summary Watch a query.  Receive callbacks as the result set changes.                                    // 297\n   * @locus Anywhere                                                                                          // 298\n   * @memberOf Mongo.Cursor                                                                                   // 299\n   * @instance                                                                                                // 300\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes                      // 301\n   */                                                                                                         // 302\n  observe: function (options) {                                                                               // 303\n    var self = this;                                                                                          // 304\n    return LocalCollection._observeFromObserveChanges(self, options);                                         // 305\n  },                                                                                                          // 306\n                                                                                                              // 307\n  /**                                                                                                         // 308\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere                                                                                          // 310\n   * @memberOf Mongo.Cursor                                                                                   // 311\n   * @instance                                                                                                // 312\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes                      // 313\n   */                                                                                                         // 314\n  observeChanges: function (options) {                                                                        // 315\n    var self = this;                                                                                          // 316\n                                                                                                              // 317\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);                                // 318\n                                                                                                              // 319\n    // there are several places that assume you aren't combining skip/limit with                              // 320\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"                              // 321\n    // comment in _modifyAndNotify                                                                            // 322\n    // XXX allow skip/limit with unordered observe                                                            // 323\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit))                                   // 324\n      throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");  // 325\n                                                                                                              // 326\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false))                                  // 327\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");                                    // 328\n                                                                                                              // 329\n    var query = {                                                                                             // 330\n      matcher: self.matcher, // not fast pathed                                                               // 331\n      sorter: ordered && self.sorter,                                                                         // 332\n      distances: (                                                                                            // 333\n        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),                                 // 334\n      resultsSnapshot: null,                                                                                  // 335\n      ordered: ordered,                                                                                       // 336\n      cursor: self,                                                                                           // 337\n      projectionFn: self._projectionFn                                                                        // 338\n    };                                                                                                        // 339\n    var qid;                                                                                                  // 340\n                                                                                                              // 341\n    // Non-reactive queries call added[Before] and then never call anything                                   // 342\n    // else.                                                                                                  // 343\n    if (self.reactive) {                                                                                      // 344\n      qid = self.collection.next_qid++;                                                                       // 345\n      self.collection.queries[qid] = query;                                                                   // 346\n    }                                                                                                         // 347\n    query.results = self._getRawObjects({                                                                     // 348\n      ordered: ordered, distances: query.distances});                                                         // 349\n    if (self.collection.paused)                                                                               // 350\n      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);                                    // 351\n                                                                                                              // 352\n    // wrap callbacks we were passed. callbacks only fire when not paused and                                 // 353\n    // are never undefined                                                                                    // 354\n    // Filters out blacklisted fields according to cursor's projection.                                       // 355\n    // XXX wrong place for this?                                                                              // 356\n                                                                                                              // 357\n    // furthermore, callbacks enqueue until the operation we're working on is                                 // 358\n    // done.                                                                                                  // 359\n    var wrapCallback = function (f) {                                                                         // 360\n      if (!f)                                                                                                 // 361\n        return function () {};                                                                                // 362\n      return function (/*args*/) {                                                                            // 363\n        var context = this;                                                                                   // 364\n        var args = arguments;                                                                                 // 365\n                                                                                                              // 366\n        if (self.collection.paused)                                                                           // 367\n          return;                                                                                             // 368\n                                                                                                              // 369\n        self.collection._observeQueue.queueTask(function () {                                                 // 370\n          f.apply(context, args);                                                                             // 371\n        });                                                                                                   // 372\n      };                                                                                                      // 373\n    };                                                                                                        // 374\n    query.added = wrapCallback(options.added);                                                                // 375\n    query.changed = wrapCallback(options.changed);                                                            // 376\n    query.removed = wrapCallback(options.removed);                                                            // 377\n    if (ordered) {                                                                                            // 378\n      query.addedBefore = wrapCallback(options.addedBefore);                                                  // 379\n      query.movedBefore = wrapCallback(options.movedBefore);                                                  // 380\n    }                                                                                                         // 381\n                                                                                                              // 382\n    if (!options._suppress_initial && !self.collection.paused) {                                              // 383\n      // XXX unify ordered and unordered interface                                                            // 384\n      var each = ordered                                                                                      // 385\n            ? _.bind(_.each, null, query.results)                                                             // 386\n            : _.bind(query.results.forEach, query.results);                                                   // 387\n      each(function (doc) {                                                                                   // 388\n        var fields = EJSON.clone(doc);                                                                        // 389\n                                                                                                              // 390\n        delete fields._id;                                                                                    // 391\n        if (ordered)                                                                                          // 392\n          query.addedBefore(doc._id, self._projectionFn(fields), null);                                       // 393\n        query.added(doc._id, self._projectionFn(fields));                                                     // 394\n      });                                                                                                     // 395\n    }                                                                                                         // 396\n                                                                                                              // 397\n    var handle = new LocalCollection.ObserveHandle;                                                           // 398\n    _.extend(handle, {                                                                                        // 399\n      collection: self.collection,                                                                            // 400\n      stop: function () {                                                                                     // 401\n        if (self.reactive)                                                                                    // 402\n          delete self.collection.queries[qid];                                                                // 403\n      }                                                                                                       // 404\n    });                                                                                                       // 405\n                                                                                                              // 406\n    if (self.reactive && Tracker.active) {                                                                    // 407\n      // XXX in many cases, the same observe will be recreated when                                           // 408\n      // the current autorun is rerun.  we could save work by                                                 // 409\n      // letting it linger across rerun and potentially get                                                   // 410\n      // repurposed if the same observe is performed, using logic                                             // 411\n      // similar to that of Meteor.subscribe.                                                                 // 412\n      Tracker.onInvalidate(function () {                                                                      // 413\n        handle.stop();                                                                                        // 414\n      });                                                                                                     // 415\n    }                                                                                                         // 416\n    // run the observe callbacks resulting from the initial contents                                          // 417\n    // before we leave the observe.                                                                           // 418\n    self.collection._observeQueue.drain();                                                                    // 419\n                                                                                                              // 420\n    return handle;                                                                                            // 421\n  }                                                                                                           // 422\n});                                                                                                           // 423\n                                                                                                              // 424\n// Returns a collection of matching objects, but doesn't deep copy them.                                      // 425\n//                                                                                                            // 426\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit                              // 427\n// properties of the query.  if sorter is falsey, no sort -- you get the natural                              // 428\n// order.                                                                                                     // 429\n//                                                                                                            // 430\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip                              // 431\n// and limit should not be set).                                                                              // 432\n//                                                                                                            // 433\n// If ordered is set and this cursor is a $near geoquery, then this function                                  // 434\n// will use an _IdMap to track each distance from the $near argument point in                                 // 435\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'                                   // 436\n// argument, this function will clear it and use it for this purpose (otherwise                               // 437\n// it will just create its own _IdMap). The observeChanges implementation uses                                // 438\n// this to remember the distances after this function returns.                                                // 439\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {                                        // 440\n  var self = this;                                                                                            // 441\n  options = options || {};                                                                                    // 442\n                                                                                                              // 443\n  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict                                     // 444\n  // compatible                                                                                               // 445\n  var results = options.ordered ? [] : new LocalCollection._IdMap;                                            // 446\n                                                                                                              // 447\n  // fast path for single ID value                                                                            // 448\n  if (self._selectorId !== undefined) {                                                                       // 449\n    // If you have non-zero skip and ask for a single id, you get                                             // 450\n    // nothing. This is so it matches the behavior of the '{_id: foo}'                                        // 451\n    // path.                                                                                                  // 452\n    if (self.skip)                                                                                            // 453\n      return results;                                                                                         // 454\n                                                                                                              // 455\n    var selectedDoc = self.collection._docs.get(self._selectorId);                                            // 456\n    if (selectedDoc) {                                                                                        // 457\n      if (options.ordered)                                                                                    // 458\n        results.push(selectedDoc);                                                                            // 459\n      else                                                                                                    // 460\n        results.set(self._selectorId, selectedDoc);                                                           // 461\n    }                                                                                                         // 462\n    return results;                                                                                           // 463\n  }                                                                                                           // 464\n                                                                                                              // 465\n  // slow path for arbitrary selector, sort, skip, limit                                                      // 466\n                                                                                                              // 467\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,                               // 468\n  // live results set) object.  in other cases, distances is only used inside                                 // 469\n  // this function.                                                                                           // 470\n  var distances;                                                                                              // 471\n  if (self.matcher.hasGeoQuery() && options.ordered) {                                                        // 472\n    if (options.distances) {                                                                                  // 473\n      distances = options.distances;                                                                          // 474\n      distances.clear();                                                                                      // 475\n    } else {                                                                                                  // 476\n      distances = new LocalCollection._IdMap();                                                               // 477\n    }                                                                                                         // 478\n  }                                                                                                           // 479\n                                                                                                              // 480\n  self.collection._docs.forEach(function (doc, id) {                                                          // 481\n    var matchResult = self.matcher.documentMatches(doc);                                                      // 482\n    if (matchResult.result) {                                                                                 // 483\n      if (options.ordered) {                                                                                  // 484\n        results.push(doc);                                                                                    // 485\n        if (distances && matchResult.distance !== undefined)                                                  // 486\n          distances.set(id, matchResult.distance);                                                            // 487\n      } else {                                                                                                // 488\n        results.set(id, doc);                                                                                 // 489\n      }                                                                                                       // 490\n    }                                                                                                         // 491\n    // Fast path for limited unsorted queries.                                                                // 492\n    // XXX 'length' check here seems wrong for ordered                                                        // 493\n    if (self.limit && !self.skip && !self.sorter &&                                                           // 494\n        results.length === self.limit)                                                                        // 495\n      return false;  // break                                                                                 // 496\n    return true;  // continue                                                                                 // 497\n  });                                                                                                         // 498\n                                                                                                              // 499\n  if (!options.ordered)                                                                                       // 500\n    return results;                                                                                           // 501\n                                                                                                              // 502\n  if (self.sorter) {                                                                                          // 503\n    var comparator = self.sorter.getComparator({distances: distances});                                       // 504\n    results.sort(comparator);                                                                                 // 505\n  }                                                                                                           // 506\n                                                                                                              // 507\n  var idx_start = self.skip || 0;                                                                             // 508\n  var idx_end = self.limit ? (self.limit + idx_start) : results.length;                                       // 509\n  return results.slice(idx_start, idx_end);                                                                   // 510\n};                                                                                                            // 511\n                                                                                                              // 512\n// XXX Maybe we need a version of observe that just calls a callback if                                       // 513\n// anything changed.                                                                                          // 514\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {                            // 515\n  var self = this;                                                                                            // 516\n                                                                                                              // 517\n  if (Tracker.active) {                                                                                       // 518\n    var v = new Tracker.Dependency;                                                                           // 519\n    v.depend();                                                                                               // 520\n    var notifyChange = _.bind(v.changed, v);                                                                  // 521\n                                                                                                              // 522\n    var options = {                                                                                           // 523\n      _suppress_initial: true,                                                                                // 524\n      _allow_unordered: _allow_unordered                                                                      // 525\n    };                                                                                                        // 526\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],                                     // 527\n           function (fnName) {                                                                                // 528\n             if (changers[fnName])                                                                            // 529\n               options[fnName] = notifyChange;                                                                // 530\n           });                                                                                                // 531\n                                                                                                              // 532\n    // observeChanges will stop() when this computation is invalidated                                        // 533\n    self.observeChanges(options);                                                                             // 534\n  }                                                                                                           // 535\n};                                                                                                            // 536\n                                                                                                              // 537\n// XXX enforce rule that field names can't start with '$' or contain '.'                                      // 538\n// (real mongodb does in fact enforce this)                                                                   // 539\n// XXX possibly enforce that 'undefined' does not appear (we assume                                           // 540\n// this in our handling of null and $exists)                                                                  // 541\nLocalCollection.prototype.insert = function (doc, callback) {                                                 // 542\n  var self = this;                                                                                            // 543\n  doc = EJSON.clone(doc);                                                                                     // 544\n                                                                                                              // 545\n  if (!_.has(doc, '_id')) {                                                                                   // 546\n    // if you really want to use ObjectIDs, set this global.                                                  // 547\n    // Mongo.Collection specifies its own ids and does not use this code.                                     // 548\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID()                                                // 549\n                                      : Random.id();                                                          // 550\n  }                                                                                                           // 551\n  var id = doc._id;                                                                                           // 552\n                                                                                                              // 553\n  if (self._docs.has(id))                                                                                     // 554\n    throw MinimongoError(\"Duplicate _id '\" + id + \"'\");                                                       // 555\n                                                                                                              // 556\n  self._saveOriginal(id, undefined);                                                                          // 557\n  self._docs.set(id, doc);                                                                                    // 558\n                                                                                                              // 559\n  var queriesToRecompute = [];                                                                                // 560\n  // trigger live queries that match                                                                          // 561\n  for (var qid in self.queries) {                                                                             // 562\n    var query = self.queries[qid];                                                                            // 563\n    var matchResult = query.matcher.documentMatches(doc);                                                     // 564\n    if (matchResult.result) {                                                                                 // 565\n      if (query.distances && matchResult.distance !== undefined)                                              // 566\n        query.distances.set(id, matchResult.distance);                                                        // 567\n      if (query.cursor.skip || query.cursor.limit)                                                            // 568\n        queriesToRecompute.push(qid);                                                                         // 569\n      else                                                                                                    // 570\n        LocalCollection._insertInResults(query, doc);                                                         // 571\n    }                                                                                                         // 572\n  }                                                                                                           // 573\n                                                                                                              // 574\n  _.each(queriesToRecompute, function (qid) {                                                                 // 575\n    if (self.queries[qid])                                                                                    // 576\n      self._recomputeResults(self.queries[qid]);                                                              // 577\n  });                                                                                                         // 578\n  self._observeQueue.drain();                                                                                 // 579\n                                                                                                              // 580\n  // Defer because the caller likely doesn't expect the callback to be run                                    // 581\n  // immediately.                                                                                             // 582\n  if (callback)                                                                                               // 583\n    Meteor.defer(function () {                                                                                // 584\n      callback(null, id);                                                                                     // 585\n    });                                                                                                       // 586\n  return id;                                                                                                  // 587\n};                                                                                                            // 588\n                                                                                                              // 589\n// Iterates over a subset of documents that could match selector; calls                                       // 590\n// f(doc, id) on each of them.  Specifically, if selector specifies                                           // 591\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the                                    // 592\n// same object that is in _docs.                                                                              // 593\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {                                 // 594\n  var self = this;                                                                                            // 595\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                          // 596\n  if (specificIds) {                                                                                          // 597\n    for (var i = 0; i < specificIds.length; ++i) {                                                            // 598\n      var id = specificIds[i];                                                                                // 599\n      var doc = self._docs.get(id);                                                                           // 600\n      if (doc) {                                                                                              // 601\n        var breakIfFalse = f(doc, id);                                                                        // 602\n        if (breakIfFalse === false)                                                                           // 603\n          break;                                                                                              // 604\n      }                                                                                                       // 605\n    }                                                                                                         // 606\n  } else {                                                                                                    // 607\n    self._docs.forEach(f);                                                                                    // 608\n  }                                                                                                           // 609\n};                                                                                                            // 610\n                                                                                                              // 611\nLocalCollection.prototype.remove = function (selector, callback) {                                            // 612\n  var self = this;                                                                                            // 613\n                                                                                                              // 614\n  // Easy special case: if we're not calling observeChanges callbacks and we're                               // 615\n  // not saving originals and we got asked to remove everything, then just empty                              // 616\n  // everything directly.                                                                                     // 617\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {                                   // 618\n    var result = self._docs.size();                                                                           // 619\n    self._docs.clear();                                                                                       // 620\n    _.each(self.queries, function (query) {                                                                   // 621\n      if (query.ordered) {                                                                                    // 622\n        query.results = [];                                                                                   // 623\n      } else {                                                                                                // 624\n        query.results.clear();                                                                                // 625\n      }                                                                                                       // 626\n    });                                                                                                       // 627\n    if (callback) {                                                                                           // 628\n      Meteor.defer(function () {                                                                              // 629\n        callback(null, result);                                                                               // 630\n      });                                                                                                     // 631\n    }                                                                                                         // 632\n    return result;                                                                                            // 633\n  }                                                                                                           // 634\n                                                                                                              // 635\n  var matcher = new Minimongo.Matcher(selector);                                                              // 636\n  var remove = [];                                                                                            // 637\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                                // 638\n    if (matcher.documentMatches(doc).result)                                                                  // 639\n      remove.push(id);                                                                                        // 640\n  });                                                                                                         // 641\n                                                                                                              // 642\n  var queriesToRecompute = [];                                                                                // 643\n  var queryRemove = [];                                                                                       // 644\n  for (var i = 0; i < remove.length; i++) {                                                                   // 645\n    var removeId = remove[i];                                                                                 // 646\n    var removeDoc = self._docs.get(removeId);                                                                 // 647\n    _.each(self.queries, function (query, qid) {                                                              // 648\n      if (query.matcher.documentMatches(removeDoc).result) {                                                  // 649\n        if (query.cursor.skip || query.cursor.limit)                                                          // 650\n          queriesToRecompute.push(qid);                                                                       // 651\n        else                                                                                                  // 652\n          queryRemove.push({qid: qid, doc: removeDoc});                                                       // 653\n      }                                                                                                       // 654\n    });                                                                                                       // 655\n    self._saveOriginal(removeId, removeDoc);                                                                  // 656\n    self._docs.remove(removeId);                                                                              // 657\n  }                                                                                                           // 658\n                                                                                                              // 659\n  // run live query callbacks _after_ we've removed the documents.                                            // 660\n  _.each(queryRemove, function (remove) {                                                                     // 661\n    var query = self.queries[remove.qid];                                                                     // 662\n    if (query) {                                                                                              // 663\n      query.distances && query.distances.remove(remove.doc._id);                                              // 664\n      LocalCollection._removeFromResults(query, remove.doc);                                                  // 665\n    }                                                                                                         // 666\n  });                                                                                                         // 667\n  _.each(queriesToRecompute, function (qid) {                                                                 // 668\n    var query = self.queries[qid];                                                                            // 669\n    if (query)                                                                                                // 670\n      self._recomputeResults(query);                                                                          // 671\n  });                                                                                                         // 672\n  self._observeQueue.drain();                                                                                 // 673\n  result = remove.length;                                                                                     // 674\n  if (callback)                                                                                               // 675\n    Meteor.defer(function () {                                                                                // 676\n      callback(null, result);                                                                                 // 677\n    });                                                                                                       // 678\n  return result;                                                                                              // 679\n};                                                                                                            // 680\n                                                                                                              // 681\n// XXX atomicity: if multi is true, and one modification fails, do                                            // 682\n// we rollback the whole operation, or what?                                                                  // 683\nLocalCollection.prototype.update = function (selector, mod, options, callback) {                              // 684\n  var self = this;                                                                                            // 685\n  if (! callback && options instanceof Function) {                                                            // 686\n    callback = options;                                                                                       // 687\n    options = null;                                                                                           // 688\n  }                                                                                                           // 689\n  if (!options) options = {};                                                                                 // 690\n                                                                                                              // 691\n  var matcher = new Minimongo.Matcher(selector);                                                              // 692\n                                                                                                              // 693\n  // Save the original results of any query that we might need to                                             // 694\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in                                // 695\n  // it. (We don't need to save the original results of paused queries because                                // 696\n  // they already have a resultsSnapshot and we won't be diffing in                                           // 697\n  // _recomputeResults.)                                                                                      // 698\n  var qidToOriginalResults = {};                                                                              // 699\n  _.each(self.queries, function (query, qid) {                                                                // 700\n    // XXX for now, skip/limit implies ordered observe, so query.results is                                   // 701\n    // always an array                                                                                        // 702\n    if ((query.cursor.skip || query.cursor.limit) && ! self.paused)                                           // 703\n      qidToOriginalResults[qid] = EJSON.clone(query.results);                                                 // 704\n  });                                                                                                         // 705\n  var recomputeQids = {};                                                                                     // 706\n                                                                                                              // 707\n  var updateCount = 0;                                                                                        // 708\n                                                                                                              // 709\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                                // 710\n    var queryResult = matcher.documentMatches(doc);                                                           // 711\n    if (queryResult.result) {                                                                                 // 712\n      // XXX Should we save the original even if mod ends up being a no-op?                                   // 713\n      self._saveOriginal(id, doc);                                                                            // 714\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);                               // 715\n      ++updateCount;                                                                                          // 716\n      if (!options.multi)                                                                                     // 717\n        return false;  // break                                                                               // 718\n    }                                                                                                         // 719\n    return true;                                                                                              // 720\n  });                                                                                                         // 721\n                                                                                                              // 722\n  _.each(recomputeQids, function (dummy, qid) {                                                               // 723\n    var query = self.queries[qid];                                                                            // 724\n    if (query)                                                                                                // 725\n      self._recomputeResults(query, qidToOriginalResults[qid]);                                               // 726\n  });                                                                                                         // 727\n  self._observeQueue.drain();                                                                                 // 728\n                                                                                                              // 729\n  // If we are doing an upsert, and we didn't modify any documents yet, then                                  // 730\n  // it's time to do an insert. Figure out what document we are inserting, and                                // 731\n  // generate an id for it.                                                                                   // 732\n  var insertedId;                                                                                             // 733\n  if (updateCount === 0 && options.upsert) {                                                                  // 734\n    var newDoc = LocalCollection._removeDollarOperators(selector);                                            // 735\n    LocalCollection._modify(newDoc, mod, {isInsert: true});                                                   // 736\n    if (! newDoc._id && options.insertedId)                                                                   // 737\n      newDoc._id = options.insertedId;                                                                        // 738\n    insertedId = self.insert(newDoc);                                                                         // 739\n    updateCount = 1;                                                                                          // 740\n  }                                                                                                           // 741\n                                                                                                              // 742\n  // Return the number of affected documents, or in the upsert case, an object                                // 743\n  // containing the number of affected docs and the id of the doc that was                                    // 744\n  // inserted, if any.                                                                                        // 745\n  var result;                                                                                                 // 746\n  if (options._returnObject) {                                                                                // 747\n    result = {                                                                                                // 748\n      numberAffected: updateCount                                                                             // 749\n    };                                                                                                        // 750\n    if (insertedId !== undefined)                                                                             // 751\n      result.insertedId = insertedId;                                                                         // 752\n  } else {                                                                                                    // 753\n    result = updateCount;                                                                                     // 754\n  }                                                                                                           // 755\n                                                                                                              // 756\n  if (callback)                                                                                               // 757\n    Meteor.defer(function () {                                                                                // 758\n      callback(null, result);                                                                                 // 759\n    });                                                                                                       // 760\n  return result;                                                                                              // 761\n};                                                                                                            // 762\n                                                                                                              // 763\n// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is                                       // 764\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:                              // 765\n// true }).                                                                                                   // 766\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {                              // 767\n  var self = this;                                                                                            // 768\n  if (! callback && typeof options === \"function\") {                                                          // 769\n    callback = options;                                                                                       // 770\n    options = {};                                                                                             // 771\n  }                                                                                                           // 772\n  return self.update(selector, mod, _.extend({}, options, {                                                   // 773\n    upsert: true,                                                                                             // 774\n    _returnObject: true                                                                                       // 775\n  }), callback);                                                                                              // 776\n};                                                                                                            // 777\n                                                                                                              // 778\nLocalCollection.prototype._modifyAndNotify = function (                                                       // 779\n    doc, mod, recomputeQids, arrayIndices) {                                                                  // 780\n  var self = this;                                                                                            // 781\n                                                                                                              // 782\n  var matched_before = {};                                                                                    // 783\n  for (var qid in self.queries) {                                                                             // 784\n    var query = self.queries[qid];                                                                            // 785\n    if (query.ordered) {                                                                                      // 786\n      matched_before[qid] = query.matcher.documentMatches(doc).result;                                        // 787\n    } else {                                                                                                  // 788\n      // Because we don't support skip or limit (yet) in unordered queries, we                                // 789\n      // can just do a direct lookup.                                                                         // 790\n      matched_before[qid] = query.results.has(doc._id);                                                       // 791\n    }                                                                                                         // 792\n  }                                                                                                           // 793\n                                                                                                              // 794\n  var old_doc = EJSON.clone(doc);                                                                             // 795\n                                                                                                              // 796\n  LocalCollection._modify(doc, mod, {arrayIndices: arrayIndices});                                            // 797\n                                                                                                              // 798\n  for (qid in self.queries) {                                                                                 // 799\n    query = self.queries[qid];                                                                                // 800\n    var before = matched_before[qid];                                                                         // 801\n    var afterMatch = query.matcher.documentMatches(doc);                                                      // 802\n    var after = afterMatch.result;                                                                            // 803\n    if (after && query.distances && afterMatch.distance !== undefined)                                        // 804\n      query.distances.set(doc._id, afterMatch.distance);                                                      // 805\n                                                                                                              // 806\n    if (query.cursor.skip || query.cursor.limit) {                                                            // 807\n      // We need to recompute any query where the doc may have been in the                                    // 808\n      // cursor's window either before or after the update. (Note that if skip                                // 809\n      // or limit is set, \"before\" and \"after\" being true do not necessarily                                  // 810\n      // mean that the document is in the cursor's output after skip/limit is                                 // 811\n      // applied... but if they are false, then the document definitely is NOT                                // 812\n      // in the output. So it's safe to skip recompute if neither before or                                   // 813\n      // after are true.)                                                                                     // 814\n      if (before || after)                                                                                    // 815\n        recomputeQids[qid] = true;                                                                            // 816\n    } else if (before && !after) {                                                                            // 817\n      LocalCollection._removeFromResults(query, doc);                                                         // 818\n    } else if (!before && after) {                                                                            // 819\n      LocalCollection._insertInResults(query, doc);                                                           // 820\n    } else if (before && after) {                                                                             // 821\n      LocalCollection._updateInResults(query, doc, old_doc);                                                  // 822\n    }                                                                                                         // 823\n  }                                                                                                           // 824\n};                                                                                                            // 825\n                                                                                                              // 826\n// XXX the sorted-query logic below is laughably inefficient. we'll                                           // 827\n// need to come up with a better datastructure for this.                                                      // 828\n//                                                                                                            // 829\n// XXX the logic for observing with a skip or a limit is even more                                            // 830\n// laughably inefficient. we recompute the whole results every time!                                          // 831\n                                                                                                              // 832\nLocalCollection._insertInResults = function (query, doc) {                                                    // 833\n  var fields = EJSON.clone(doc);                                                                              // 834\n  delete fields._id;                                                                                          // 835\n  if (query.ordered) {                                                                                        // 836\n    if (!query.sorter) {                                                                                      // 837\n      query.addedBefore(doc._id, query.projectionFn(fields), null);                                           // 838\n      query.results.push(doc);                                                                                // 839\n    } else {                                                                                                  // 840\n      var i = LocalCollection._insertInSortedList(                                                            // 841\n        query.sorter.getComparator({distances: query.distances}),                                             // 842\n        query.results, doc);                                                                                  // 843\n      var next = query.results[i+1];                                                                          // 844\n      if (next)                                                                                               // 845\n        next = next._id;                                                                                      // 846\n      else                                                                                                    // 847\n        next = null;                                                                                          // 848\n      query.addedBefore(doc._id, query.projectionFn(fields), next);                                           // 849\n    }                                                                                                         // 850\n    query.added(doc._id, query.projectionFn(fields));                                                         // 851\n  } else {                                                                                                    // 852\n    query.added(doc._id, query.projectionFn(fields));                                                         // 853\n    query.results.set(doc._id, doc);                                                                          // 854\n  }                                                                                                           // 855\n};                                                                                                            // 856\n                                                                                                              // 857\nLocalCollection._removeFromResults = function (query, doc) {                                                  // 858\n  if (query.ordered) {                                                                                        // 859\n    var i = LocalCollection._findInOrderedResults(query, doc);                                                // 860\n    query.removed(doc._id);                                                                                   // 861\n    query.results.splice(i, 1);                                                                               // 862\n  } else {                                                                                                    // 863\n    var id = doc._id;  // in case callback mutates doc                                                        // 864\n    query.removed(doc._id);                                                                                   // 865\n    query.results.remove(id);                                                                                 // 866\n  }                                                                                                           // 867\n};                                                                                                            // 868\n                                                                                                              // 869\nLocalCollection._updateInResults = function (query, doc, old_doc) {                                           // 870\n  if (!EJSON.equals(doc._id, old_doc._id))                                                                    // 871\n    throw new Error(\"Can't change a doc's _id while updating\");                                               // 872\n  var projectionFn = query.projectionFn;                                                                      // 873\n  var changedFields = DiffSequence.makeChangedFields(                                                         // 874\n    projectionFn(doc), projectionFn(old_doc));                                                                // 875\n                                                                                                              // 876\n  if (!query.ordered) {                                                                                       // 877\n    if (!_.isEmpty(changedFields)) {                                                                          // 878\n      query.changed(doc._id, changedFields);                                                                  // 879\n      query.results.set(doc._id, doc);                                                                        // 880\n    }                                                                                                         // 881\n    return;                                                                                                   // 882\n  }                                                                                                           // 883\n                                                                                                              // 884\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);                                           // 885\n                                                                                                              // 886\n  if (!_.isEmpty(changedFields))                                                                              // 887\n    query.changed(doc._id, changedFields);                                                                    // 888\n  if (!query.sorter)                                                                                          // 889\n    return;                                                                                                   // 890\n                                                                                                              // 891\n  // just take it out and put it back in again, and see if the index                                          // 892\n  // changes                                                                                                  // 893\n  query.results.splice(orig_idx, 1);                                                                          // 894\n  var new_idx = LocalCollection._insertInSortedList(                                                          // 895\n    query.sorter.getComparator({distances: query.distances}),                                                 // 896\n    query.results, doc);                                                                                      // 897\n  if (orig_idx !== new_idx) {                                                                                 // 898\n    var next = query.results[new_idx+1];                                                                      // 899\n    if (next)                                                                                                 // 900\n      next = next._id;                                                                                        // 901\n    else                                                                                                      // 902\n      next = null;                                                                                            // 903\n    query.movedBefore && query.movedBefore(doc._id, next);                                                    // 904\n  }                                                                                                           // 905\n};                                                                                                            // 906\n                                                                                                              // 907\n// Recomputes the results of a query and runs observe callbacks for the                                       // 908\n// difference between the previous results and the current results (unless                                    // 909\n// paused). Used for skip/limit queries.                                                                      // 910\n//                                                                                                            // 911\n// When this is used by insert or remove, it can just use query.results for the                               // 912\n// old results (and there's no need to pass in oldResults), because these                                     // 913\n// operations don't mutate the documents in the collection. Update needs to pass                              // 914\n// in an oldResults which was deep-copied before the modifier was applied.                                    // 915\n//                                                                                                            // 916\n// oldResults is guaranteed to be ignored if the query is not paused.                                         // 917\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {                                  // 918\n  var self = this;                                                                                            // 919\n  if (! self.paused && ! oldResults)                                                                          // 920\n    oldResults = query.results;                                                                               // 921\n  if (query.distances)                                                                                        // 922\n    query.distances.clear();                                                                                  // 923\n  query.results = query.cursor._getRawObjects({                                                               // 924\n    ordered: query.ordered, distances: query.distances});                                                     // 925\n                                                                                                              // 926\n  if (! self.paused) {                                                                                        // 927\n    LocalCollection._diffQueryChanges(                                                                        // 928\n      query.ordered, oldResults, query.results, query,                                                        // 929\n      { projectionFn: query.projectionFn });                                                                  // 930\n  }                                                                                                           // 931\n};                                                                                                            // 932\n                                                                                                              // 933\n                                                                                                              // 934\nLocalCollection._findInOrderedResults = function (query, doc) {                                               // 935\n  if (!query.ordered)                                                                                         // 936\n    throw new Error(\"Can't call _findInOrderedResults on unordered query\");                                   // 937\n  for (var i = 0; i < query.results.length; i++)                                                              // 938\n    if (query.results[i] === doc)                                                                             // 939\n      return i;                                                                                               // 940\n  throw Error(\"object missing from query\");                                                                   // 941\n};                                                                                                            // 942\n                                                                                                              // 943\n// This binary search puts a value between any equal values, and the first                                    // 944\n// lesser value.                                                                                              // 945\nLocalCollection._binarySearch = function (cmp, array, value) {                                                // 946\n  var first = 0, rangeLength = array.length;                                                                  // 947\n                                                                                                              // 948\n  while (rangeLength > 0) {                                                                                   // 949\n    var halfRange = Math.floor(rangeLength/2);                                                                // 950\n    if (cmp(value, array[first + halfRange]) >= 0) {                                                          // 951\n      first += halfRange + 1;                                                                                 // 952\n      rangeLength -= halfRange + 1;                                                                           // 953\n    } else {                                                                                                  // 954\n      rangeLength = halfRange;                                                                                // 955\n    }                                                                                                         // 956\n  }                                                                                                           // 957\n  return first;                                                                                               // 958\n};                                                                                                            // 959\n                                                                                                              // 960\nLocalCollection._insertInSortedList = function (cmp, array, value) {                                          // 961\n  if (array.length === 0) {                                                                                   // 962\n    array.push(value);                                                                                        // 963\n    return 0;                                                                                                 // 964\n  }                                                                                                           // 965\n                                                                                                              // 966\n  var idx = LocalCollection._binarySearch(cmp, array, value);                                                 // 967\n  array.splice(idx, 0, value);                                                                                // 968\n  return idx;                                                                                                 // 969\n};                                                                                                            // 970\n                                                                                                              // 971\n// To track what documents are affected by a piece of code, call saveOriginals()                              // 972\n// before it and retrieveOriginals() after it. retrieveOriginals returns an                                   // 973\n// object whose keys are the ids of the documents that were affected since the                                // 974\n// call to saveOriginals(), and the values are equal to the document's contents                               // 975\n// at the time of saveOriginals. (In the case of an inserted document, undefined                              // 976\n// is the value.) You must alternate between calls to saveOriginals() and                                     // 977\n// retrieveOriginals().                                                                                       // 978\nLocalCollection.prototype.saveOriginals = function () {                                                       // 979\n  var self = this;                                                                                            // 980\n  if (self._savedOriginals)                                                                                   // 981\n    throw new Error(\"Called saveOriginals twice without retrieveOriginals\");                                  // 982\n  self._savedOriginals = new LocalCollection._IdMap;                                                          // 983\n};                                                                                                            // 984\nLocalCollection.prototype.retrieveOriginals = function () {                                                   // 985\n  var self = this;                                                                                            // 986\n  if (!self._savedOriginals)                                                                                  // 987\n    throw new Error(\"Called retrieveOriginals without saveOriginals\");                                        // 988\n                                                                                                              // 989\n  var originals = self._savedOriginals;                                                                       // 990\n  self._savedOriginals = null;                                                                                // 991\n  return originals;                                                                                           // 992\n};                                                                                                            // 993\n                                                                                                              // 994\nLocalCollection.prototype._saveOriginal = function (id, doc) {                                                // 995\n  var self = this;                                                                                            // 996\n  // Are we even trying to save originals?                                                                    // 997\n  if (!self._savedOriginals)                                                                                  // 998\n    return;                                                                                                   // 999\n  // Have we previously mutated the original (and so 'doc' is not actually                                    // 1000\n  // original)?  (Note the 'has' check rather than truth: we store undefined                                  // 1001\n  // here for inserted docs!)                                                                                 // 1002\n  if (self._savedOriginals.has(id))                                                                           // 1003\n    return;                                                                                                   // 1004\n  self._savedOriginals.set(id, EJSON.clone(doc));                                                             // 1005\n};                                                                                                            // 1006\n                                                                                                              // 1007\n// Pause the observers. No callbacks from observers will fire until                                           // 1008\n// 'resumeObservers' is called.                                                                               // 1009\nLocalCollection.prototype.pauseObservers = function () {                                                      // 1010\n  // No-op if already paused.                                                                                 // 1011\n  if (this.paused)                                                                                            // 1012\n    return;                                                                                                   // 1013\n                                                                                                              // 1014\n  // Set the 'paused' flag such that new observer messages don't fire.                                        // 1015\n  this.paused = true;                                                                                         // 1016\n                                                                                                              // 1017\n  // Take a snapshot of the query results for each query.                                                     // 1018\n  for (var qid in this.queries) {                                                                             // 1019\n    var query = this.queries[qid];                                                                            // 1020\n                                                                                                              // 1021\n    query.resultsSnapshot = EJSON.clone(query.results);                                                       // 1022\n  }                                                                                                           // 1023\n};                                                                                                            // 1024\n                                                                                                              // 1025\n// Resume the observers. Observers immediately receive change                                                 // 1026\n// notifications to bring them to the current state of the                                                    // 1027\n// database. Note that this is not just replaying all the changes that                                        // 1028\n// happened during the pause, it is a smarter 'coalesced' diff.                                               // 1029\nLocalCollection.prototype.resumeObservers = function () {                                                     // 1030\n  var self = this;                                                                                            // 1031\n  // No-op if not paused.                                                                                     // 1032\n  if (!this.paused)                                                                                           // 1033\n    return;                                                                                                   // 1034\n                                                                                                              // 1035\n  // Unset the 'paused' flag. Make sure to do this first, otherwise                                           // 1036\n  // observer methods won't actually fire when we trigger them.                                               // 1037\n  this.paused = false;                                                                                        // 1038\n                                                                                                              // 1039\n  for (var qid in this.queries) {                                                                             // 1040\n    var query = self.queries[qid];                                                                            // 1041\n    // Diff the current results against the snapshot and send to observers.                                   // 1042\n    // pass the query object for its observer callbacks.                                                      // 1043\n    LocalCollection._diffQueryChanges(                                                                        // 1044\n      query.ordered, query.resultsSnapshot, query.results, query,                                             // 1045\n      { projectionFn: query.projectionFn });                                                                  // 1046\n    query.resultsSnapshot = null;                                                                             // 1047\n  }                                                                                                           // 1048\n  self._observeQueue.drain();                                                                                 // 1049\n};                                                                                                            // 1050\n                                                                                                              // 1051\n                                                                                                              // 1052\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/wrap_transform.js                                                                       //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Wrap a transform function to return objects that have the _id field                                        // 1\n// of the untransformed document. This ensures that subsystems such as                                        // 2\n// the observe-sequence package that call `observe` can keep track of                                         // 3\n// the documents identities.                                                                                  // 4\n//                                                                                                            // 5\n// - Require that it returns objects                                                                          // 6\n// - If the return value has an _id field, verify that it matches the                                         // 7\n//   original _id field                                                                                       // 8\n// - If the return value doesn't have an _id field, add it back.                                              // 9\nLocalCollection.wrapTransform = function (transform) {                                                        // 10\n  if (! transform)                                                                                            // 11\n    return null;                                                                                              // 12\n                                                                                                              // 13\n  // No need to doubly-wrap transforms.                                                                       // 14\n  if (transform.__wrappedTransform__)                                                                         // 15\n    return transform;                                                                                         // 16\n                                                                                                              // 17\n  var wrapped = function (doc) {                                                                              // 18\n    if (!_.has(doc, '_id')) {                                                                                 // 19\n      // XXX do we ever have a transform on the oplog's collection? because that                              // 20\n      // collection has no _id.                                                                               // 21\n      throw new Error(\"can only transform documents with _id\");                                               // 22\n    }                                                                                                         // 23\n                                                                                                              // 24\n    var id = doc._id;                                                                                         // 25\n    // XXX consider making tracker a weak dependency and checking Package.tracker here                        // 26\n    var transformed = Tracker.nonreactive(function () {                                                       // 27\n      return transform(doc);                                                                                  // 28\n    });                                                                                                       // 29\n                                                                                                              // 30\n    if (!isPlainObject(transformed)) {                                                                        // 31\n      throw new Error(\"transform must return object\");                                                        // 32\n    }                                                                                                         // 33\n                                                                                                              // 34\n    if (_.has(transformed, '_id')) {                                                                          // 35\n      if (!EJSON.equals(transformed._id, id)) {                                                               // 36\n        throw new Error(\"transformed document can't have different _id\");                                     // 37\n      }                                                                                                       // 38\n    } else {                                                                                                  // 39\n      transformed._id = id;                                                                                   // 40\n    }                                                                                                         // 41\n    return transformed;                                                                                       // 42\n  };                                                                                                          // 43\n  wrapped.__wrappedTransform__ = true;                                                                        // 44\n  return wrapped;                                                                                             // 45\n};                                                                                                            // 46\n                                                                                                              // 47\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/helpers.js                                                                              //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as                               // 1\n// arrays.                                                                                                    // 2\n// XXX maybe this should be EJSON.isArray                                                                     // 3\nisArray = function (x) {                                                                                      // 4\n  return _.isArray(x) && !EJSON.isBinary(x);                                                                  // 5\n};                                                                                                            // 6\n                                                                                                              // 7\n// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about                                   // 8\n// RegExp                                                                                                     // 9\n// XXX note that _type(undefined) === 3!!!!                                                                   // 10\nisPlainObject = LocalCollection._isPlainObject = function (x) {                                               // 11\n  return x && LocalCollection._f._type(x) === 3;                                                              // 12\n};                                                                                                            // 13\n                                                                                                              // 14\nisIndexable = function (x) {                                                                                  // 15\n  return isArray(x) || isPlainObject(x);                                                                      // 16\n};                                                                                                            // 17\n                                                                                                              // 18\n// Returns true if this is an object with at least one key and all keys begin                                 // 19\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and                                // 20\n// others don't.                                                                                              // 21\nisOperatorObject = function (valueSelector, inconsistentOK) {                                                 // 22\n  if (!isPlainObject(valueSelector))                                                                          // 23\n    return false;                                                                                             // 24\n                                                                                                              // 25\n  var theseAreOperators = undefined;                                                                          // 26\n  _.each(valueSelector, function (value, selKey) {                                                            // 27\n    var thisIsOperator = selKey.substr(0, 1) === '$';                                                         // 28\n    if (theseAreOperators === undefined) {                                                                    // 29\n      theseAreOperators = thisIsOperator;                                                                     // 30\n    } else if (theseAreOperators !== thisIsOperator) {                                                        // 31\n      if (!inconsistentOK)                                                                                    // 32\n        throw new Error(\"Inconsistent operator: \" +                                                           // 33\n                        JSON.stringify(valueSelector));                                                       // 34\n      theseAreOperators = false;                                                                              // 35\n    }                                                                                                         // 36\n  });                                                                                                         // 37\n  return !!theseAreOperators;  // {} has no operators                                                         // 38\n};                                                                                                            // 39\n                                                                                                              // 40\n                                                                                                              // 41\n// string can be converted to integer                                                                         // 42\nisNumericKey = function (s) {                                                                                 // 43\n  return /^[0-9]+$/.test(s);                                                                                  // 44\n};                                                                                                            // 45\n                                                                                                              // 46\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/selector.js                                                                             //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// The minimongo selector compiler!                                                                           // 1\n                                                                                                              // 2\n// Terminology:                                                                                               // 3\n//  - a \"selector\" is the EJSON object representing a selector                                                // 4\n//  - a \"matcher\" is its compiled form (whether a full Minimongo.Matcher                                      // 5\n//    object or one of the component lambdas that matches parts of it)                                        // 6\n//  - a \"result object\" is an object with a \"result\" field and maybe                                          // 7\n//    distance and arrayIndices.                                                                              // 8\n//  - a \"branched value\" is an object with a \"value\" field and maybe                                          // 9\n//    \"dontIterate\" and \"arrayIndices\".                                                                       // 10\n//  - a \"document\" is a top-level object that can be stored in a collection.                                  // 11\n//  - a \"lookup function\" is a function that takes in a document and returns                                  // 12\n//    an array of \"branched values\".                                                                          // 13\n//  - a \"branched matcher\" maps from an array of branched values to a result                                  // 14\n//    object.                                                                                                 // 15\n//  - an \"element matcher\" maps from a single value to a bool.                                                // 16\n                                                                                                              // 17\n// Main entry point.                                                                                          // 18\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});                                                      // 19\n//   if (matcher.documentMatches({a: 7})) ...                                                                 // 20\nMinimongo.Matcher = function (selector) {                                                                     // 21\n  var self = this;                                                                                            // 22\n  // A set (object mapping string -> *) of all of the document paths looked                                   // 23\n  // at by the selector. Also includes the empty string if it may look at any                                 // 24\n  // path (eg, $where).                                                                                       // 25\n  self._paths = {};                                                                                           // 26\n  // Set to true if compilation finds a $near.                                                                // 27\n  self._hasGeoQuery = false;                                                                                  // 28\n  // Set to true if compilation finds a $where.                                                               // 29\n  self._hasWhere = false;                                                                                     // 30\n  // Set to false if compilation finds anything other than a simple equality or                               // 31\n  // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with                              // 32\n  // scalars as operands.                                                                                     // 33\n  self._isSimple = true;                                                                                      // 34\n  // Set to a dummy document which always matches this Matcher. Or set to null                                // 35\n  // if such document is too hard to find.                                                                    // 36\n  self._matchingDocument = undefined;                                                                         // 37\n  // A clone of the original selector. It may just be a function if the user                                  // 38\n  // passed in a function; otherwise is definitely an object (eg, IDs are                                     // 39\n  // translated into {_id: ID} first. Used by canBecomeTrueByModifier and                                     // 40\n  // Sorter._useWithMatcher.                                                                                  // 41\n  self._selector = null;                                                                                      // 42\n  self._docMatcher = self._compileSelector(selector);                                                         // 43\n};                                                                                                            // 44\n                                                                                                              // 45\n_.extend(Minimongo.Matcher.prototype, {                                                                       // 46\n  documentMatches: function (doc) {                                                                           // 47\n    if (!doc || typeof doc !== \"object\") {                                                                    // 48\n      throw Error(\"documentMatches needs a document\");                                                        // 49\n    }                                                                                                         // 50\n    return this._docMatcher(doc);                                                                             // 51\n  },                                                                                                          // 52\n  hasGeoQuery: function () {                                                                                  // 53\n    return this._hasGeoQuery;                                                                                 // 54\n  },                                                                                                          // 55\n  hasWhere: function () {                                                                                     // 56\n    return this._hasWhere;                                                                                    // 57\n  },                                                                                                          // 58\n  isSimple: function () {                                                                                     // 59\n    return this._isSimple;                                                                                    // 60\n  },                                                                                                          // 61\n                                                                                                              // 62\n  // Given a selector, return a function that takes one argument, a                                           // 63\n  // document. It returns a result object.                                                                    // 64\n  _compileSelector: function (selector) {                                                                     // 65\n    var self = this;                                                                                          // 66\n    // you can pass a literal function instead of a selector                                                  // 67\n    if (selector instanceof Function) {                                                                       // 68\n      self._isSimple = false;                                                                                 // 69\n      self._selector = selector;                                                                              // 70\n      self._recordPathUsed('');                                                                               // 71\n      return function (doc) {                                                                                 // 72\n        return {result: !!selector.call(doc)};                                                                // 73\n      };                                                                                                      // 74\n    }                                                                                                         // 75\n                                                                                                              // 76\n    // shorthand -- scalars match _id                                                                         // 77\n    if (LocalCollection._selectorIsId(selector)) {                                                            // 78\n      self._selector = {_id: selector};                                                                       // 79\n      self._recordPathUsed('_id');                                                                            // 80\n      return function (doc) {                                                                                 // 81\n        return {result: EJSON.equals(doc._id, selector)};                                                     // 82\n      };                                                                                                      // 83\n    }                                                                                                         // 84\n                                                                                                              // 85\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both                                // 86\n    // likely programmer error, and not what you want, particularly for                                       // 87\n    // destructive operations.                                                                                // 88\n    if (!selector || (('_id' in selector) && !selector._id)) {                                                // 89\n      self._isSimple = false;                                                                                 // 90\n      return nothingMatcher;                                                                                  // 91\n    }                                                                                                         // 92\n                                                                                                              // 93\n    // Top level can't be an array or true or binary.                                                         // 94\n    if (typeof(selector) === 'boolean' || isArray(selector) ||                                                // 95\n        EJSON.isBinary(selector))                                                                             // 96\n      throw new Error(\"Invalid selector: \" + selector);                                                       // 97\n                                                                                                              // 98\n    self._selector = EJSON.clone(selector);                                                                   // 99\n    return compileDocumentSelector(selector, self, {isRoot: true});                                           // 100\n  },                                                                                                          // 101\n  _recordPathUsed: function (path) {                                                                          // 102\n    this._paths[path] = true;                                                                                 // 103\n  },                                                                                                          // 104\n  // Returns a list of key paths the given selector is looking for. It includes                               // 105\n  // the empty string if there is a $where.                                                                   // 106\n  _getPaths: function () {                                                                                    // 107\n    return _.keys(this._paths);                                                                               // 108\n  }                                                                                                           // 109\n});                                                                                                           // 110\n                                                                                                              // 111\n                                                                                                              // 112\n// Takes in a selector that could match a full document (eg, the original                                     // 113\n// selector). Returns a function mapping document->result object.                                             // 114\n//                                                                                                            // 115\n// matcher is the Matcher object we are compiling.                                                            // 116\n//                                                                                                            // 117\n// If this is the root document selector (ie, not wrapped in $and or the like),                               // 118\n// then isRoot is true. (This is used by $near.)                                                              // 119\nvar compileDocumentSelector = function (docSelector, matcher, options) {                                      // 120\n  options = options || {};                                                                                    // 121\n  var docMatchers = [];                                                                                       // 122\n  _.each(docSelector, function (subSelector, key) {                                                           // 123\n    if (key.substr(0, 1) === '$') {                                                                           // 124\n      // Outer operators are either logical operators (they recurse back into                                 // 125\n      // this function), or $where.                                                                           // 126\n      if (!_.has(LOGICAL_OPERATORS, key))                                                                     // 127\n        throw new Error(\"Unrecognized logical operator: \" + key);                                             // 128\n      matcher._isSimple = false;                                                                              // 129\n      docMatchers.push(LOGICAL_OPERATORS[key](subSelector, matcher,                                           // 130\n                                              options.inElemMatch));                                          // 131\n    } else {                                                                                                  // 132\n      // Record this path, but only if we aren't in an elemMatcher, since in an                               // 133\n      // elemMatch this is a path inside an object in an array, not in the doc                                // 134\n      // root.                                                                                                // 135\n      if (!options.inElemMatch)                                                                               // 136\n        matcher._recordPathUsed(key);                                                                         // 137\n      var lookUpByIndex = makeLookupFunction(key);                                                            // 138\n      var valueMatcher =                                                                                      // 139\n        compileValueSelector(subSelector, matcher, options.isRoot);                                           // 140\n      docMatchers.push(function (doc) {                                                                       // 141\n        var branchValues = lookUpByIndex(doc);                                                                // 142\n        return valueMatcher(branchValues);                                                                    // 143\n      });                                                                                                     // 144\n    }                                                                                                         // 145\n  });                                                                                                         // 146\n                                                                                                              // 147\n  return andDocumentMatchers(docMatchers);                                                                    // 148\n};                                                                                                            // 149\n                                                                                                              // 150\n// Takes in a selector that could match a key-indexed value in a document; eg,                                // 151\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to                                // 152\n// indicate equality).  Returns a branched matcher: a function mapping                                        // 153\n// [branched value]->result object.                                                                           // 154\nvar compileValueSelector = function (valueSelector, matcher, isRoot) {                                        // 155\n  if (valueSelector instanceof RegExp) {                                                                      // 156\n    matcher._isSimple = false;                                                                                // 157\n    return convertElementMatcherToBranchedMatcher(                                                            // 158\n      regexpElementMatcher(valueSelector));                                                                   // 159\n  } else if (isOperatorObject(valueSelector)) {                                                               // 160\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);                                           // 161\n  } else {                                                                                                    // 162\n    return convertElementMatcherToBranchedMatcher(                                                            // 163\n      equalityElementMatcher(valueSelector));                                                                 // 164\n  }                                                                                                           // 165\n};                                                                                                            // 166\n                                                                                                              // 167\n// Given an element matcher (which evaluates a single value), returns a branched                              // 168\n// value (which evaluates the element matcher on all the branches and returns a                               // 169\n// more structured return value possibly including arrayIndices).                                             // 170\nvar convertElementMatcherToBranchedMatcher = function (                                                       // 171\n    elementMatcher, options) {                                                                                // 172\n  options = options || {};                                                                                    // 173\n  return function (branches) {                                                                                // 174\n    var expanded = branches;                                                                                  // 175\n    if (!options.dontExpandLeafArrays) {                                                                      // 176\n      expanded = expandArraysInBranches(                                                                      // 177\n        branches, options.dontIncludeLeafArrays);                                                             // 178\n    }                                                                                                         // 179\n    var ret = {};                                                                                             // 180\n    ret.result = _.any(expanded, function (element) {                                                         // 181\n      var matched = elementMatcher(element.value);                                                            // 182\n                                                                                                              // 183\n      // Special case for $elemMatch: it means \"true, and use this as an array                                // 184\n      // index if I didn't already have one\".                                                                 // 185\n      if (typeof matched === 'number') {                                                                      // 186\n        // XXX This code dates from when we only stored a single array index                                  // 187\n        // (for the outermost array). Should we be also including deeper array                                // 188\n        // indices from the $elemMatch match?                                                                 // 189\n        if (!element.arrayIndices)                                                                            // 190\n          element.arrayIndices = [matched];                                                                   // 191\n        matched = true;                                                                                       // 192\n      }                                                                                                       // 193\n                                                                                                              // 194\n      // If some element matched, and it's tagged with array indices, include                                 // 195\n      // those indices in our result object.                                                                  // 196\n      if (matched && element.arrayIndices)                                                                    // 197\n        ret.arrayIndices = element.arrayIndices;                                                              // 198\n                                                                                                              // 199\n      return matched;                                                                                         // 200\n    });                                                                                                       // 201\n    return ret;                                                                                               // 202\n  };                                                                                                          // 203\n};                                                                                                            // 204\n                                                                                                              // 205\n// Takes a RegExp object and returns an element matcher.                                                      // 206\nregexpElementMatcher = function (regexp) {                                                                    // 207\n  return function (value) {                                                                                   // 208\n    if (value instanceof RegExp) {                                                                            // 209\n      // Comparing two regexps means seeing if the regexps are identical                                      // 210\n      // (really!). Underscore knows how.                                                                     // 211\n      return _.isEqual(value, regexp);                                                                        // 212\n    }                                                                                                         // 213\n    // Regexps only work against strings.                                                                     // 214\n    if (typeof value !== 'string')                                                                            // 215\n      return false;                                                                                           // 216\n                                                                                                              // 217\n    // Reset regexp's state to avoid inconsistent matching for objects with the                               // 218\n    // same value on consecutive calls of regexp.test. This happens only if the                               // 219\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for                              // 220\n    // which we should *not* change the lastIndex but MongoDB doesn't support                                 // 221\n    // either of these flags.                                                                                 // 222\n    regexp.lastIndex = 0;                                                                                     // 223\n                                                                                                              // 224\n    return regexp.test(value);                                                                                // 225\n  };                                                                                                          // 226\n};                                                                                                            // 227\n                                                                                                              // 228\n// Takes something that is not an operator object and returns an element matcher                              // 229\n// for equality with that thing.                                                                              // 230\nequalityElementMatcher = function (elementSelector) {                                                         // 231\n  if (isOperatorObject(elementSelector))                                                                      // 232\n    throw Error(\"Can't create equalityValueSelector for operator object\");                                    // 233\n                                                                                                              // 234\n  // Special-case: null and undefined are equal (if you got undefined in there                                // 235\n  // somewhere, or if you got it due to some branch being non-existent in the                                 // 236\n  // weird special case), even though they aren't with EJSON.equals.                                          // 237\n  if (elementSelector == null) {  // undefined or null                                                        // 238\n    return function (value) {                                                                                 // 239\n      return value == null;  // undefined or null                                                             // 240\n    };                                                                                                        // 241\n  }                                                                                                           // 242\n                                                                                                              // 243\n  return function (value) {                                                                                   // 244\n    return LocalCollection._f._equal(elementSelector, value);                                                 // 245\n  };                                                                                                          // 246\n};                                                                                                            // 247\n                                                                                                              // 248\n// Takes an operator object (an object with $ keys) and returns a branched                                    // 249\n// matcher for it.                                                                                            // 250\nvar operatorBranchedMatcher = function (valueSelector, matcher, isRoot) {                                     // 251\n  // Each valueSelector works separately on the various branches.  So one                                     // 252\n  // operator can match one branch and another can match another branch.  This                                // 253\n  // is OK.                                                                                                   // 254\n                                                                                                              // 255\n  var operatorMatchers = [];                                                                                  // 256\n  _.each(valueSelector, function (operand, operator) {                                                        // 257\n    // XXX we should actually implement $eq, which is new in 2.6                                              // 258\n    var simpleRange = _.contains(['$lt', '$lte', '$gt', '$gte'], operator) &&                                 // 259\n      _.isNumber(operand);                                                                                    // 260\n    var simpleInequality = operator === '$ne' && !_.isObject(operand);                                        // 261\n    var simpleInclusion = _.contains(['$in', '$nin'], operator) &&                                            // 262\n      _.isArray(operand) && !_.any(operand, _.isObject);                                                      // 263\n                                                                                                              // 264\n    if (! (operator === '$eq' || simpleRange ||                                                               // 265\n           simpleInclusion || simpleInequality)) {                                                            // 266\n      matcher._isSimple = false;                                                                              // 267\n    }                                                                                                         // 268\n                                                                                                              // 269\n    if (_.has(VALUE_OPERATORS, operator)) {                                                                   // 270\n      operatorMatchers.push(                                                                                  // 271\n        VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));                                  // 272\n    } else if (_.has(ELEMENT_OPERATORS, operator)) {                                                          // 273\n      var options = ELEMENT_OPERATORS[operator];                                                              // 274\n      operatorMatchers.push(                                                                                  // 275\n        convertElementMatcherToBranchedMatcher(                                                               // 276\n          options.compileElementSelector(                                                                     // 277\n            operand, valueSelector, matcher),                                                                 // 278\n          options));                                                                                          // 279\n    } else {                                                                                                  // 280\n      throw new Error(\"Unrecognized operator: \" + operator);                                                  // 281\n    }                                                                                                         // 282\n  });                                                                                                         // 283\n                                                                                                              // 284\n  return andBranchedMatchers(operatorMatchers);                                                               // 285\n};                                                                                                            // 286\n                                                                                                              // 287\nvar compileArrayOfDocumentSelectors = function (                                                              // 288\n    selectors, matcher, inElemMatch) {                                                                        // 289\n  if (!isArray(selectors) || _.isEmpty(selectors))                                                            // 290\n    throw Error(\"$and/$or/$nor must be nonempty array\");                                                      // 291\n  return _.map(selectors, function (subSelector) {                                                            // 292\n    if (!isPlainObject(subSelector))                                                                          // 293\n      throw Error(\"$or/$and/$nor entries need to be full objects\");                                           // 294\n    return compileDocumentSelector(                                                                           // 295\n      subSelector, matcher, {inElemMatch: inElemMatch});                                                      // 296\n  });                                                                                                         // 297\n};                                                                                                            // 298\n                                                                                                              // 299\n// Operators that appear at the top level of a document selector.                                             // 300\nvar LOGICAL_OPERATORS = {                                                                                     // 301\n  $and: function (subSelector, matcher, inElemMatch) {                                                        // 302\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 303\n      subSelector, matcher, inElemMatch);                                                                     // 304\n    return andDocumentMatchers(matchers);                                                                     // 305\n  },                                                                                                          // 306\n                                                                                                              // 307\n  $or: function (subSelector, matcher, inElemMatch) {                                                         // 308\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 309\n      subSelector, matcher, inElemMatch);                                                                     // 310\n                                                                                                              // 311\n    // Special case: if there is only one matcher, use it directly, *preserving*                              // 312\n    // any arrayIndices it returns.                                                                           // 313\n    if (matchers.length === 1)                                                                                // 314\n      return matchers[0];                                                                                     // 315\n                                                                                                              // 316\n    return function (doc) {                                                                                   // 317\n      var result = _.any(matchers, function (f) {                                                             // 318\n        return f(doc).result;                                                                                 // 319\n      });                                                                                                     // 320\n      // $or does NOT set arrayIndices when it has multiple                                                   // 321\n      // sub-expressions. (Tested against MongoDB.)                                                           // 322\n      return {result: result};                                                                                // 323\n    };                                                                                                        // 324\n  },                                                                                                          // 325\n                                                                                                              // 326\n  $nor: function (subSelector, matcher, inElemMatch) {                                                        // 327\n    var matchers = compileArrayOfDocumentSelectors(                                                           // 328\n      subSelector, matcher, inElemMatch);                                                                     // 329\n    return function (doc) {                                                                                   // 330\n      var result = _.all(matchers, function (f) {                                                             // 331\n        return !f(doc).result;                                                                                // 332\n      });                                                                                                     // 333\n      // Never set arrayIndices, because we only match if nothing in particular                               // 334\n      // \"matched\" (and because this is consistent with MongoDB).                                             // 335\n      return {result: result};                                                                                // 336\n    };                                                                                                        // 337\n  },                                                                                                          // 338\n                                                                                                              // 339\n  $where: function (selectorValue, matcher) {                                                                 // 340\n    // Record that *any* path may be used.                                                                    // 341\n    matcher._recordPathUsed('');                                                                              // 342\n    matcher._hasWhere = true;                                                                                 // 343\n    if (!(selectorValue instanceof Function)) {                                                               // 344\n      // XXX MongoDB seems to have more complex logic to decide where or or not                               // 345\n      // to add \"return\"; not sure exactly what it is.                                                        // 346\n      selectorValue = Function(\"obj\", \"return \" + selectorValue);                                             // 347\n    }                                                                                                         // 348\n    return function (doc) {                                                                                   // 349\n      // We make the document available as both `this` and `obj`.                                             // 350\n      // XXX not sure what we should do if this throws                                                        // 351\n      return {result: selectorValue.call(doc, doc)};                                                          // 352\n    };                                                                                                        // 353\n  },                                                                                                          // 354\n                                                                                                              // 355\n  // This is just used as a comment in the query (in MongoDB, it also ends up in                              // 356\n  // query logs); it has no effect on the actual selection.                                                   // 357\n  $comment: function () {                                                                                     // 358\n    return function () {                                                                                      // 359\n      return {result: true};                                                                                  // 360\n    };                                                                                                        // 361\n  }                                                                                                           // 362\n};                                                                                                            // 363\n                                                                                                              // 364\n// Returns a branched matcher that matches iff the given matcher does not.                                    // 365\n// Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it                                     // 366\n// means that ALL branch values need to fail to match innerBranchedMatcher.                                   // 367\nvar invertBranchedMatcher = function (branchedMatcher) {                                                      // 368\n  return function (branchValues) {                                                                            // 369\n    var invertMe = branchedMatcher(branchValues);                                                             // 370\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to                              // 371\n    // say \"update the array element that does not match something\", at least                                 // 372\n    // in mongo-land.                                                                                         // 373\n    return {result: !invertMe.result};                                                                        // 374\n  };                                                                                                          // 375\n};                                                                                                            // 376\n                                                                                                              // 377\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a                                 // 378\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as                                // 379\n// \"match each branched value independently and combine with                                                  // 380\n// convertElementMatcherToBranchedMatcher\".                                                                   // 381\nvar VALUE_OPERATORS = {                                                                                       // 382\n  $not: function (operand, valueSelector, matcher) {                                                          // 383\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));                                     // 384\n  },                                                                                                          // 385\n  $ne: function (operand) {                                                                                   // 386\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                      // 387\n      equalityElementMatcher(operand)));                                                                      // 388\n  },                                                                                                          // 389\n  $nin: function (operand) {                                                                                  // 390\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                      // 391\n      ELEMENT_OPERATORS.$in.compileElementSelector(operand)));                                                // 392\n  },                                                                                                          // 393\n  $exists: function (operand) {                                                                               // 394\n    var exists = convertElementMatcherToBranchedMatcher(function (value) {                                    // 395\n      return value !== undefined;                                                                             // 396\n    });                                                                                                       // 397\n    return operand ? exists : invertBranchedMatcher(exists);                                                  // 398\n  },                                                                                                          // 399\n  // $options just provides options for $regex; its logic is inside $regex                                    // 400\n  $options: function (operand, valueSelector) {                                                               // 401\n    if (!_.has(valueSelector, '$regex'))                                                                      // 402\n      throw Error(\"$options needs a $regex\");                                                                 // 403\n    return everythingMatcher;                                                                                 // 404\n  },                                                                                                          // 405\n  // $maxDistance is basically an argument to $near                                                           // 406\n  $maxDistance: function (operand, valueSelector) {                                                           // 407\n    if (!valueSelector.$near)                                                                                 // 408\n      throw Error(\"$maxDistance needs a $near\");                                                              // 409\n    return everythingMatcher;                                                                                 // 410\n  },                                                                                                          // 411\n  $all: function (operand, valueSelector, matcher) {                                                          // 412\n    if (!isArray(operand))                                                                                    // 413\n      throw Error(\"$all requires array\");                                                                     // 414\n    // Not sure why, but this seems to be what MongoDB does.                                                  // 415\n    if (_.isEmpty(operand))                                                                                   // 416\n      return nothingMatcher;                                                                                  // 417\n                                                                                                              // 418\n    var branchedMatchers = [];                                                                                // 419\n    _.each(operand, function (criterion) {                                                                    // 420\n      // XXX handle $all/$elemMatch combination                                                               // 421\n      if (isOperatorObject(criterion))                                                                        // 422\n        throw Error(\"no $ expressions in $all\");                                                              // 423\n      // This is always a regexp or equality selector.                                                        // 424\n      branchedMatchers.push(compileValueSelector(criterion, matcher));                                        // 425\n    });                                                                                                       // 426\n    // andBranchedMatchers does NOT require all selectors to return true on the                               // 427\n    // SAME branch.                                                                                           // 428\n    return andBranchedMatchers(branchedMatchers);                                                             // 429\n  },                                                                                                          // 430\n  $near: function (operand, valueSelector, matcher, isRoot) {                                                 // 431\n    if (!isRoot)                                                                                              // 432\n      throw Error(\"$near can't be inside another $ operator\");                                                // 433\n    matcher._hasGeoQuery = true;                                                                              // 434\n                                                                                                              // 435\n    // There are two kinds of geodata in MongoDB: coordinate pairs and                                        // 436\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are                                 // 437\n    // marked with a $geometry property.                                                                      // 438\n                                                                                                              // 439\n    var maxDistance, point, distance;                                                                         // 440\n    if (isPlainObject(operand) && _.has(operand, '$geometry')) {                                              // 441\n      // GeoJSON \"2dsphere\" mode.                                                                             // 442\n      maxDistance = operand.$maxDistance;                                                                     // 443\n      point = operand.$geometry;                                                                              // 444\n      distance = function (value) {                                                                           // 445\n        // XXX: for now, we don't calculate the actual distance between, say,                                 // 446\n        // polygon and circle. If people care about this use-case it will get                                 // 447\n        // a priority.                                                                                        // 448\n        if (!value || !value.type)                                                                            // 449\n          return null;                                                                                        // 450\n        if (value.type === \"Point\") {                                                                         // 451\n          return GeoJSON.pointDistance(point, value);                                                         // 452\n        } else {                                                                                              // 453\n          return GeoJSON.geometryWithinRadius(value, point, maxDistance)                                      // 454\n            ? 0 : maxDistance + 1;                                                                            // 455\n        }                                                                                                     // 456\n      };                                                                                                      // 457\n    } else {                                                                                                  // 458\n      maxDistance = valueSelector.$maxDistance;                                                               // 459\n      if (!isArray(operand) && !isPlainObject(operand))                                                       // 460\n        throw Error(\"$near argument must be coordinate pair or GeoJSON\");                                     // 461\n      point = pointToArray(operand);                                                                          // 462\n      distance = function (value) {                                                                           // 463\n        if (!isArray(value) && !isPlainObject(value))                                                         // 464\n          return null;                                                                                        // 465\n        return distanceCoordinatePairs(point, value);                                                         // 466\n      };                                                                                                      // 467\n    }                                                                                                         // 468\n                                                                                                              // 469\n    return function (branchedValues) {                                                                        // 470\n      // There might be multiple points in the document that match the given                                  // 471\n      // field. Only one of them needs to be within $maxDistance, but we need to                              // 472\n      // evaluate all of them and use the nearest one for the implicit sort                                   // 473\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)                                    // 474\n      //                                                                                                      // 475\n      // Note: This differs from MongoDB's implementation, where a document will                              // 476\n      // actually show up *multiple times* in the result set, with one entry for                              // 477\n      // each within-$maxDistance branching point.                                                            // 478\n      branchedValues = expandArraysInBranches(branchedValues);                                                // 479\n      var result = {result: false};                                                                           // 480\n      _.each(branchedValues, function (branch) {                                                              // 481\n        var curDistance = distance(branch.value);                                                             // 482\n        // Skip branches that aren't real points or are too far away.                                         // 483\n        if (curDistance === null || curDistance > maxDistance)                                                // 484\n          return;                                                                                             // 485\n        // Skip anything that's a tie.                                                                        // 486\n        if (result.distance !== undefined && result.distance <= curDistance)                                  // 487\n          return;                                                                                             // 488\n        result.result = true;                                                                                 // 489\n        result.distance = curDistance;                                                                        // 490\n        if (!branch.arrayIndices)                                                                             // 491\n          delete result.arrayIndices;                                                                         // 492\n        else                                                                                                  // 493\n          result.arrayIndices = branch.arrayIndices;                                                          // 494\n      });                                                                                                     // 495\n      return result;                                                                                          // 496\n    };                                                                                                        // 497\n  }                                                                                                           // 498\n};                                                                                                            // 499\n                                                                                                              // 500\n// Helpers for $near.                                                                                         // 501\nvar distanceCoordinatePairs = function (a, b) {                                                               // 502\n  a = pointToArray(a);                                                                                        // 503\n  b = pointToArray(b);                                                                                        // 504\n  var x = a[0] - b[0];                                                                                        // 505\n  var y = a[1] - b[1];                                                                                        // 506\n  if (_.isNaN(x) || _.isNaN(y))                                                                               // 507\n    return null;                                                                                              // 508\n  return Math.sqrt(x * x + y * y);                                                                            // 509\n};                                                                                                            // 510\n// Makes sure we get 2 elements array and assume the first one to be x and                                    // 511\n// the second one to y no matter what user passes.                                                            // 512\n// In case user passes { lon: x, lat: y } returns [x, y]                                                      // 513\nvar pointToArray = function (point) {                                                                         // 514\n  return _.map(point, _.identity);                                                                            // 515\n};                                                                                                            // 516\n                                                                                                              // 517\n// Helper for $lt/$gt/$lte/$gte.                                                                              // 518\nvar makeInequality = function (cmpValueComparator) {                                                          // 519\n  return {                                                                                                    // 520\n    compileElementSelector: function (operand) {                                                              // 521\n      // Arrays never compare false with non-arrays for any inequality.                                       // 522\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but                                    // 523\n      //     it seems to have been reverted.                                                                  // 524\n      //     See https://jira.mongodb.org/browse/SERVER-11444                                                 // 525\n      if (isArray(operand)) {                                                                                 // 526\n        return function () {                                                                                  // 527\n          return false;                                                                                       // 528\n        };                                                                                                    // 529\n      }                                                                                                       // 530\n                                                                                                              // 531\n      // Special case: consider undefined and null the same (so true with                                     // 532\n      // $gte/$lte).                                                                                          // 533\n      if (operand === undefined)                                                                              // 534\n        operand = null;                                                                                       // 535\n                                                                                                              // 536\n      var operandType = LocalCollection._f._type(operand);                                                    // 537\n                                                                                                              // 538\n      return function (value) {                                                                               // 539\n        if (value === undefined)                                                                              // 540\n          value = null;                                                                                       // 541\n        // Comparisons are never true among things of different type (except                                  // 542\n        // null vs undefined).                                                                                // 543\n        if (LocalCollection._f._type(value) !== operandType)                                                  // 544\n          return false;                                                                                       // 545\n        return cmpValueComparator(LocalCollection._f._cmp(value, operand));                                   // 546\n      };                                                                                                      // 547\n    }                                                                                                         // 548\n  };                                                                                                          // 549\n};                                                                                                            // 550\n                                                                                                              // 551\n// Each element selector contains:                                                                            // 552\n//  - compileElementSelector, a function with args:                                                           // 553\n//    - operand - the \"right hand side\" of the operator                                                       // 554\n//    - valueSelector - the \"context\" for the operator (so that $regex can find                               // 555\n//      $options)                                                                                             // 556\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile                              // 557\n//      more things)                                                                                          // 558\n//    returning a function mapping a single value to bool.                                                    // 559\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from                                 // 560\n//    being called                                                                                            // 561\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to                                  // 562\n//    expandArraysInBranches if it is called                                                                  // 563\nELEMENT_OPERATORS = {                                                                                         // 564\n  $lt: makeInequality(function (cmpValue) {                                                                   // 565\n    return cmpValue < 0;                                                                                      // 566\n  }),                                                                                                         // 567\n  $gt: makeInequality(function (cmpValue) {                                                                   // 568\n    return cmpValue > 0;                                                                                      // 569\n  }),                                                                                                         // 570\n  $lte: makeInequality(function (cmpValue) {                                                                  // 571\n    return cmpValue <= 0;                                                                                     // 572\n  }),                                                                                                         // 573\n  $gte: makeInequality(function (cmpValue) {                                                                  // 574\n    return cmpValue >= 0;                                                                                     // 575\n  }),                                                                                                         // 576\n  $mod: {                                                                                                     // 577\n    compileElementSelector: function (operand) {                                                              // 578\n      if (!(isArray(operand) && operand.length === 2                                                          // 579\n            && typeof(operand[0]) === 'number'                                                                // 580\n            && typeof(operand[1]) === 'number')) {                                                            // 581\n        throw Error(\"argument to $mod must be an array of two numbers\");                                      // 582\n      }                                                                                                       // 583\n      // XXX could require to be ints or round or something                                                   // 584\n      var divisor = operand[0];                                                                               // 585\n      var remainder = operand[1];                                                                             // 586\n      return function (value) {                                                                               // 587\n        return typeof value === 'number' && value % divisor === remainder;                                    // 588\n      };                                                                                                      // 589\n    }                                                                                                         // 590\n  },                                                                                                          // 591\n  $in: {                                                                                                      // 592\n    compileElementSelector: function (operand) {                                                              // 593\n      if (!isArray(operand))                                                                                  // 594\n        throw Error(\"$in needs an array\");                                                                    // 595\n                                                                                                              // 596\n      var elementMatchers = [];                                                                               // 597\n      _.each(operand, function (option) {                                                                     // 598\n        if (option instanceof RegExp)                                                                         // 599\n          elementMatchers.push(regexpElementMatcher(option));                                                 // 600\n        else if (isOperatorObject(option))                                                                    // 601\n          throw Error(\"cannot nest $ under $in\");                                                             // 602\n        else                                                                                                  // 603\n          elementMatchers.push(equalityElementMatcher(option));                                               // 604\n      });                                                                                                     // 605\n                                                                                                              // 606\n      return function (value) {                                                                               // 607\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.                                         // 608\n        if (value === undefined)                                                                              // 609\n          value = null;                                                                                       // 610\n        return _.any(elementMatchers, function (e) {                                                          // 611\n          return e(value);                                                                                    // 612\n        });                                                                                                   // 613\n      };                                                                                                      // 614\n    }                                                                                                         // 615\n  },                                                                                                          // 616\n  $size: {                                                                                                    // 617\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we                                // 618\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a                                // 619\n    // possible value.                                                                                        // 620\n    dontExpandLeafArrays: true,                                                                               // 621\n    compileElementSelector: function (operand) {                                                              // 622\n      if (typeof operand === 'string') {                                                                      // 623\n        // Don't ask me why, but by experimentation, this seems to be what Mongo                              // 624\n        // does.                                                                                              // 625\n        operand = 0;                                                                                          // 626\n      } else if (typeof operand !== 'number') {                                                               // 627\n        throw Error(\"$size needs a number\");                                                                  // 628\n      }                                                                                                       // 629\n      return function (value) {                                                                               // 630\n        return isArray(value) && value.length === operand;                                                    // 631\n      };                                                                                                      // 632\n    }                                                                                                         // 633\n  },                                                                                                          // 634\n  $type: {                                                                                                    // 635\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should                                 // 636\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:                                 // 637\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but                                 // 638\n    // should *not* include it itself.                                                                        // 639\n    dontIncludeLeafArrays: true,                                                                              // 640\n    compileElementSelector: function (operand) {                                                              // 641\n      if (typeof operand !== 'number')                                                                        // 642\n        throw Error(\"$type needs a number\");                                                                  // 643\n      return function (value) {                                                                               // 644\n        return value !== undefined                                                                            // 645\n          && LocalCollection._f._type(value) === operand;                                                     // 646\n      };                                                                                                      // 647\n    }                                                                                                         // 648\n  },                                                                                                          // 649\n  $regex: {                                                                                                   // 650\n    compileElementSelector: function (operand, valueSelector) {                                               // 651\n      if (!(typeof operand === 'string' || operand instanceof RegExp))                                        // 652\n        throw Error(\"$regex has to be a string or RegExp\");                                                   // 653\n                                                                                                              // 654\n      var regexp;                                                                                             // 655\n      if (valueSelector.$options !== undefined) {                                                             // 656\n        // Options passed in $options (even the empty string) always overrides                                // 657\n        // options in the RegExp object itself. (See also                                                     // 658\n        // Mongo.Collection._rewriteSelector.)                                                                // 659\n                                                                                                              // 660\n        // Be clear that we only support the JS-supported options, not extended                               // 661\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s                              // 662\n        // by transforming the regexp, but not today...                                                       // 663\n        if (/[^gim]/.test(valueSelector.$options))                                                            // 664\n          throw new Error(\"Only the i, m, and g regexp options are supported\");                               // 665\n                                                                                                              // 666\n        var regexSource = operand instanceof RegExp ? operand.source : operand;                               // 667\n        regexp = new RegExp(regexSource, valueSelector.$options);                                             // 668\n      } else if (operand instanceof RegExp) {                                                                 // 669\n        regexp = operand;                                                                                     // 670\n      } else {                                                                                                // 671\n        regexp = new RegExp(operand);                                                                         // 672\n      }                                                                                                       // 673\n      return regexpElementMatcher(regexp);                                                                    // 674\n    }                                                                                                         // 675\n  },                                                                                                          // 676\n  $elemMatch: {                                                                                               // 677\n    dontExpandLeafArrays: true,                                                                               // 678\n    compileElementSelector: function (operand, valueSelector, matcher) {                                      // 679\n      if (!isPlainObject(operand))                                                                            // 680\n        throw Error(\"$elemMatch need an object\");                                                             // 681\n                                                                                                              // 682\n      var subMatcher, isDocMatcher;                                                                           // 683\n      if (isOperatorObject(operand, true)) {                                                                  // 684\n        subMatcher = compileValueSelector(operand, matcher);                                                  // 685\n        isDocMatcher = false;                                                                                 // 686\n      } else {                                                                                                // 687\n        // This is NOT the same as compileValueSelector(operand), and not just                                // 688\n        // because of the slightly different calling convention.                                              // 689\n        // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not                                       // 690\n        // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.                               // 691\n        subMatcher = compileDocumentSelector(operand, matcher,                                                // 692\n                                             {inElemMatch: true});                                            // 693\n        isDocMatcher = true;                                                                                  // 694\n      }                                                                                                       // 695\n                                                                                                              // 696\n      return function (value) {                                                                               // 697\n        if (!isArray(value))                                                                                  // 698\n          return false;                                                                                       // 699\n        for (var i = 0; i < value.length; ++i) {                                                              // 700\n          var arrayElement = value[i];                                                                        // 701\n          var arg;                                                                                            // 702\n          if (isDocMatcher) {                                                                                 // 703\n            // We can only match {$elemMatch: {b: 3}} against objects.                                        // 704\n            // (We can also match against arrays, if there's numeric indices,                                 // 705\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)                                          // 706\n            if (!isPlainObject(arrayElement) && !isArray(arrayElement))                                       // 707\n              return false;                                                                                   // 708\n            arg = arrayElement;                                                                               // 709\n          } else {                                                                                            // 710\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches                                   // 711\n            // {a: [8]} but not {a: [[8]]}                                                                    // 712\n            arg = [{value: arrayElement, dontIterate: true}];                                                 // 713\n          }                                                                                                   // 714\n          // XXX support $near in $elemMatch by propagating $distance?                                        // 715\n          if (subMatcher(arg).result)                                                                         // 716\n            return i;   // specially understood to mean \"use as arrayIndices\"                                 // 717\n        }                                                                                                     // 718\n        return false;                                                                                         // 719\n      };                                                                                                      // 720\n    }                                                                                                         // 721\n  }                                                                                                           // 722\n};                                                                                                            // 723\n                                                                                                              // 724\n// makeLookupFunction(key) returns a lookup function.                                                         // 725\n//                                                                                                            // 726\n// A lookup function takes in a document and returns an array of matching                                     // 727\n// branches.  If no arrays are found while looking up the key, this array will                                // 728\n// have exactly one branches (possibly 'undefined', if some segment of the key                                // 729\n// was not found).                                                                                            // 730\n//                                                                                                            // 731\n// If arrays are found in the middle, this can have more than one element, since                              // 732\n// we \"branch\". When we \"branch\", if there are more key segments to look up,                                  // 733\n// then we only pursue branches that are plain objects (not arrays or scalars).                               // 734\n// This means we can actually end up with no branches!                                                        // 735\n//                                                                                                            // 736\n// We do *NOT* branch on arrays that are found at the end (ie, at the last                                    // 737\n// dotted member of the key). We just return that array; if you want to                                       // 738\n// effectively \"branch\" over the array's values, post-process the lookup                                      // 739\n// function with expandArraysInBranches.                                                                      // 740\n//                                                                                                            // 741\n// Each branch is an object with keys:                                                                        // 742\n//  - value: the value at the branch                                                                          // 743\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array                               // 744\n//    that expandArraysInBranches should NOT expand. This specifically happens                                // 745\n//    when there is a numeric index in the key, and ensures the                                               // 746\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT                                           // 747\n//    match {a: [[5]]}.                                                                                       // 748\n//  - arrayIndices: if any array indexing was done during lookup (either due to                               // 749\n//    explicit numeric indices or implicit branching), this will be an array of                               // 750\n//    the array indices used, from outermost to innermost; it is falsey or                                    // 751\n//    absent if no array index is used. If an explicit numeric index is used,                                 // 752\n//    the index will be followed in arrayIndices by the string 'x'.                                           // 753\n//                                                                                                            // 754\n//    Note: arrayIndices is used for two purposes. First, it is used to                                       // 755\n//    implement the '$' modifier feature, which only ever looks at its first                                  // 756\n//    element.                                                                                                // 757\n//                                                                                                            // 758\n//    Second, it is used for sort key generation, which needs to be able to tell                              // 759\n//    the difference between different paths. Moreover, it needs to                                           // 760\n//    differentiate between explicit and implicit branching, which is why                                     // 761\n//    there's the somewhat hacky 'x' entry: this means that explicit and                                      // 762\n//    implicit array lookups will have different full arrayIndices paths. (That                               // 763\n//    code only requires that different paths have different arrayIndices; it                                 // 764\n//    doesn't actually \"parse\" arrayIndices. As an alternative, arrayIndices                                  // 765\n//    could contain objects with flags like \"implicit\", but I think that only                                 // 766\n//    makes the code surrounding them more complex.)                                                          // 767\n//                                                                                                            // 768\n//    (By the way, this field ends up getting passed around a lot without                                     // 769\n//    cloning, so never mutate any arrayIndices field/var in this package!)                                   // 770\n//                                                                                                            // 771\n//                                                                                                            // 772\n// At the top level, you may only pass in a plain object or array.                                            // 773\n//                                                                                                            // 774\n// See the test 'minimongo - lookup' for some examples of what lookup functions                               // 775\n// return.                                                                                                    // 776\nmakeLookupFunction = function (key, options) {                                                                // 777\n  options = options || {};                                                                                    // 778\n  var parts = key.split('.');                                                                                 // 779\n  var firstPart = parts.length ? parts[0] : '';                                                               // 780\n  var firstPartIsNumeric = isNumericKey(firstPart);                                                           // 781\n  var nextPartIsNumeric = parts.length >= 2 && isNumericKey(parts[1]);                                        // 782\n  var lookupRest;                                                                                             // 783\n  if (parts.length > 1) {                                                                                     // 784\n    lookupRest = makeLookupFunction(parts.slice(1).join('.'));                                                // 785\n  }                                                                                                           // 786\n                                                                                                              // 787\n  var omitUnnecessaryFields = function (retVal) {                                                             // 788\n    if (!retVal.dontIterate)                                                                                  // 789\n      delete retVal.dontIterate;                                                                              // 790\n    if (retVal.arrayIndices && !retVal.arrayIndices.length)                                                   // 791\n      delete retVal.arrayIndices;                                                                             // 792\n    return retVal;                                                                                            // 793\n  };                                                                                                          // 794\n                                                                                                              // 795\n  // Doc will always be a plain object or an array.                                                           // 796\n  // apply an explicit numeric index, an array.                                                               // 797\n  return function (doc, arrayIndices) {                                                                       // 798\n    if (!arrayIndices)                                                                                        // 799\n      arrayIndices = [];                                                                                      // 800\n                                                                                                              // 801\n    if (isArray(doc)) {                                                                                       // 802\n      // If we're being asked to do an invalid lookup into an array (non-integer                              // 803\n      // or out-of-bounds), return no results (which is different from returning                              // 804\n      // a single undefined result, in that `null` equality checks won't match).                              // 805\n      if (!(firstPartIsNumeric && firstPart < doc.length))                                                    // 806\n        return [];                                                                                            // 807\n                                                                                                              // 808\n      // Remember that we used this array index. Include an 'x' to indicate that                              // 809\n      // the previous index came from being considered as an explicit array                                   // 810\n      // index (not branching).                                                                               // 811\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');                                                    // 812\n    }                                                                                                         // 813\n                                                                                                              // 814\n    // Do our first lookup.                                                                                   // 815\n    var firstLevel = doc[firstPart];                                                                          // 816\n                                                                                                              // 817\n    // If there is no deeper to dig, return what we found.                                                    // 818\n    //                                                                                                        // 819\n    // If what we found is an array, most value selectors will choose to treat                                // 820\n    // the elements of the array as matchable values in their own right, but                                  // 821\n    // that's done outside of the lookup function. (Exceptions to this are $size                              // 822\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:                              // 823\n    // [[1, 2]]}.)                                                                                            // 824\n    //                                                                                                        // 825\n    // That said, if we just did an *explicit* array lookup (on doc) to find                                  // 826\n    // firstLevel, and firstLevel is an array too, we do NOT want value                                       // 827\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.                               // 828\n    // So in that case, we mark the return value as \"don't iterate\".                                          // 829\n    if (!lookupRest) {                                                                                        // 830\n      return [omitUnnecessaryFields({                                                                         // 831\n        value: firstLevel,                                                                                    // 832\n        dontIterate: isArray(doc) && isArray(firstLevel),                                                     // 833\n        arrayIndices: arrayIndices})];                                                                        // 834\n    }                                                                                                         // 835\n                                                                                                              // 836\n    // We need to dig deeper.  But if we can't, because what we've found is not                               // 837\n    // an array or plain object, we're done. If we just did a numeric index into                              // 838\n    // an array, we return nothing here (this is a change in Mongo 2.5 from                                   // 839\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,                                // 840\n    // return a single `undefined` (which can, for example, match via equality                                // 841\n    // with `null`).                                                                                          // 842\n    if (!isIndexable(firstLevel)) {                                                                           // 843\n      if (isArray(doc))                                                                                       // 844\n        return [];                                                                                            // 845\n      return [omitUnnecessaryFields({value: undefined,                                                        // 846\n                                      arrayIndices: arrayIndices})];                                          // 847\n    }                                                                                                         // 848\n                                                                                                              // 849\n    var result = [];                                                                                          // 850\n    var appendToResult = function (more) {                                                                    // 851\n      Array.prototype.push.apply(result, more);                                                               // 852\n    };                                                                                                        // 853\n                                                                                                              // 854\n    // Dig deeper: look up the rest of the parts on whatever we've found.                                     // 855\n    // (lookupRest is smart enough to not try to do invalid lookups into                                      // 856\n    // firstLevel if it's an array.)                                                                          // 857\n    appendToResult(lookupRest(firstLevel, arrayIndices));                                                     // 858\n                                                                                                              // 859\n    // If we found an array, then in *addition* to potentially treating the next                              // 860\n    // part as a literal integer lookup, we should also \"branch\": try to look up                              // 861\n    // the rest of the parts on each array element in parallel.                                               // 862\n    //                                                                                                        // 863\n    // In this case, we *only* dig deeper into array elements that are plain                                  // 864\n    // objects. (Recall that we only got this far if we have further to dig.)                                 // 865\n    // This makes sense: we certainly don't dig deeper into non-indexable                                     // 866\n    // objects. And it would be weird to dig into an array: it's simpler to have                              // 867\n    // a rule that explicit integer indexes only apply to an outer array, not to                              // 868\n    // an array you find after a branching search.                                                            // 869\n    //                                                                                                        // 870\n    // In the special case of a numeric part in a *sort selector* (not a query                                // 871\n    // selector), we skip the branching: we ONLY allow the numeric part to mean                               // 872\n    // \"look up this index\" in that case, not \"also look up this index in all                                 // 873\n    // the elements of the array\".                                                                            // 874\n    if (isArray(firstLevel) && !(nextPartIsNumeric && options.forSort)) {                                     // 875\n      _.each(firstLevel, function (branch, arrayIndex) {                                                      // 876\n        if (isPlainObject(branch)) {                                                                          // 877\n          appendToResult(lookupRest(                                                                          // 878\n            branch,                                                                                           // 879\n            arrayIndices.concat(arrayIndex)));                                                                // 880\n        }                                                                                                     // 881\n      });                                                                                                     // 882\n    }                                                                                                         // 883\n                                                                                                              // 884\n    return result;                                                                                            // 885\n  };                                                                                                          // 886\n};                                                                                                            // 887\nMinimongoTest.makeLookupFunction = makeLookupFunction;                                                        // 888\n                                                                                                              // 889\nexpandArraysInBranches = function (branches, skipTheArrays) {                                                 // 890\n  var branchesOut = [];                                                                                       // 891\n  _.each(branches, function (branch) {                                                                        // 892\n    var thisIsArray = isArray(branch.value);                                                                  // 893\n    // We include the branch itself, *UNLESS* we it's an array that we're going                               // 894\n    // to iterate and we're told to skip arrays.  (That's right, we include some                              // 895\n    // arrays even skipTheArrays is true: these are arrays that were found via                                // 896\n    // explicit numerical indices.)                                                                           // 897\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {                                             // 898\n      branchesOut.push({                                                                                      // 899\n        value: branch.value,                                                                                  // 900\n        arrayIndices: branch.arrayIndices                                                                     // 901\n      });                                                                                                     // 902\n    }                                                                                                         // 903\n    if (thisIsArray && !branch.dontIterate) {                                                                 // 904\n      _.each(branch.value, function (leaf, i) {                                                               // 905\n        branchesOut.push({                                                                                    // 906\n          value: leaf,                                                                                        // 907\n          arrayIndices: (branch.arrayIndices || []).concat(i)                                                 // 908\n        });                                                                                                   // 909\n      });                                                                                                     // 910\n    }                                                                                                         // 911\n  });                                                                                                         // 912\n  return branchesOut;                                                                                         // 913\n};                                                                                                            // 914\n                                                                                                              // 915\nvar nothingMatcher = function (docOrBranchedValues) {                                                         // 916\n  return {result: false};                                                                                     // 917\n};                                                                                                            // 918\n                                                                                                              // 919\nvar everythingMatcher = function (docOrBranchedValues) {                                                      // 920\n  return {result: true};                                                                                      // 921\n};                                                                                                            // 922\n                                                                                                              // 923\n                                                                                                              // 924\n// NB: We are cheating and using this function to implement \"AND\" for both                                    // 925\n// \"document matchers\" and \"branched matchers\". They both return result objects                               // 926\n// but the argument is different: for the former it's a whole doc, whereas for                                // 927\n// the latter it's an array of \"branched values\".                                                             // 928\nvar andSomeMatchers = function (subMatchers) {                                                                // 929\n  if (subMatchers.length === 0)                                                                               // 930\n    return everythingMatcher;                                                                                 // 931\n  if (subMatchers.length === 1)                                                                               // 932\n    return subMatchers[0];                                                                                    // 933\n                                                                                                              // 934\n  return function (docOrBranches) {                                                                           // 935\n    var ret = {};                                                                                             // 936\n    ret.result = _.all(subMatchers, function (f) {                                                            // 937\n      var subResult = f(docOrBranches);                                                                       // 938\n      // Copy a 'distance' number out of the first sub-matcher that has                                       // 939\n      // one. Yes, this means that if there are multiple $near fields in a                                    // 940\n      // query, something arbitrary happens; this appears to be consistent with                               // 941\n      // Mongo.                                                                                               // 942\n      if (subResult.result && subResult.distance !== undefined                                                // 943\n          && ret.distance === undefined) {                                                                    // 944\n        ret.distance = subResult.distance;                                                                    // 945\n      }                                                                                                       // 946\n      // Similarly, propagate arrayIndices from sub-matchers... but to match                                  // 947\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices                                 // 948\n      // wins.                                                                                                // 949\n      if (subResult.result && subResult.arrayIndices) {                                                       // 950\n        ret.arrayIndices = subResult.arrayIndices;                                                            // 951\n      }                                                                                                       // 952\n      return subResult.result;                                                                                // 953\n    });                                                                                                       // 954\n                                                                                                              // 955\n    // If we didn't actually match, forget any extra metadata we came up with.                                // 956\n    if (!ret.result) {                                                                                        // 957\n      delete ret.distance;                                                                                    // 958\n      delete ret.arrayIndices;                                                                                // 959\n    }                                                                                                         // 960\n    return ret;                                                                                               // 961\n  };                                                                                                          // 962\n};                                                                                                            // 963\n                                                                                                              // 964\nvar andDocumentMatchers = andSomeMatchers;                                                                    // 965\nvar andBranchedMatchers = andSomeMatchers;                                                                    // 966\n                                                                                                              // 967\n                                                                                                              // 968\n// helpers used by compiled selector code                                                                     // 969\nLocalCollection._f = {                                                                                        // 970\n  // XXX for _all and _in, consider building 'inquery' at compile time..                                      // 971\n                                                                                                              // 972\n  _type: function (v) {                                                                                       // 973\n    if (typeof v === \"number\")                                                                                // 974\n      return 1;                                                                                               // 975\n    if (typeof v === \"string\")                                                                                // 976\n      return 2;                                                                                               // 977\n    if (typeof v === \"boolean\")                                                                               // 978\n      return 8;                                                                                               // 979\n    if (isArray(v))                                                                                           // 980\n      return 4;                                                                                               // 981\n    if (v === null)                                                                                           // 982\n      return 10;                                                                                              // 983\n    if (v instanceof RegExp)                                                                                  // 984\n      // note that typeof(/x/) === \"object\"                                                                   // 985\n      return 11;                                                                                              // 986\n    if (typeof v === \"function\")                                                                              // 987\n      return 13;                                                                                              // 988\n    if (v instanceof Date)                                                                                    // 989\n      return 9;                                                                                               // 990\n    if (EJSON.isBinary(v))                                                                                    // 991\n      return 5;                                                                                               // 992\n    if (v instanceof MongoID.ObjectID)                                                                        // 993\n      return 7;                                                                                               // 994\n    return 3; // object                                                                                       // 995\n                                                                                                              // 996\n    // XXX support some/all of these:                                                                         // 997\n    // 14, symbol                                                                                             // 998\n    // 15, javascript code with scope                                                                         // 999\n    // 16, 18: 32-bit/64-bit integer                                                                          // 1000\n    // 17, timestamp                                                                                          // 1001\n    // 255, minkey                                                                                            // 1002\n    // 127, maxkey                                                                                            // 1003\n  },                                                                                                          // 1004\n                                                                                                              // 1005\n  // deep equality test: use for literal document and array matches                                           // 1006\n  _equal: function (a, b) {                                                                                   // 1007\n    return EJSON.equals(a, b, {keyOrderSensitive: true});                                                     // 1008\n  },                                                                                                          // 1009\n                                                                                                              // 1010\n  // maps a type code to a value that can be used to sort values of                                           // 1011\n  // different types                                                                                          // 1012\n  _typeorder: function (t) {                                                                                  // 1013\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types                           // 1014\n    // XXX what is the correct sort position for Javascript code?                                             // 1015\n    // ('100' in the matrix below)                                                                            // 1016\n    // XXX minkey/maxkey                                                                                      // 1017\n    return [-1,  // (not a type)                                                                              // 1018\n            1,   // number                                                                                    // 1019\n            2,   // string                                                                                    // 1020\n            3,   // object                                                                                    // 1021\n            4,   // array                                                                                     // 1022\n            5,   // binary                                                                                    // 1023\n            -1,  // deprecated                                                                                // 1024\n            6,   // ObjectID                                                                                  // 1025\n            7,   // bool                                                                                      // 1026\n            8,   // Date                                                                                      // 1027\n            0,   // null                                                                                      // 1028\n            9,   // RegExp                                                                                    // 1029\n            -1,  // deprecated                                                                                // 1030\n            100, // JS code                                                                                   // 1031\n            2,   // deprecated (symbol)                                                                       // 1032\n            100, // JS code                                                                                   // 1033\n            1,   // 32-bit int                                                                                // 1034\n            8,   // Mongo timestamp                                                                           // 1035\n            1    // 64-bit int                                                                                // 1036\n           ][t];                                                                                              // 1037\n  },                                                                                                          // 1038\n                                                                                                              // 1039\n  // compare two values of unknown type according to BSON ordering                                            // 1040\n  // semantics. (as an extension, consider 'undefined' to be less than                                        // 1041\n  // any other value.) return negative if a is less, positive if b is                                         // 1042\n  // less, or 0 if equal                                                                                      // 1043\n  _cmp: function (a, b) {                                                                                     // 1044\n    if (a === undefined)                                                                                      // 1045\n      return b === undefined ? 0 : -1;                                                                        // 1046\n    if (b === undefined)                                                                                      // 1047\n      return 1;                                                                                               // 1048\n    var ta = LocalCollection._f._type(a);                                                                     // 1049\n    var tb = LocalCollection._f._type(b);                                                                     // 1050\n    var oa = LocalCollection._f._typeorder(ta);                                                               // 1051\n    var ob = LocalCollection._f._typeorder(tb);                                                               // 1052\n    if (oa !== ob)                                                                                            // 1053\n      return oa < ob ? -1 : 1;                                                                                // 1054\n    if (ta !== tb)                                                                                            // 1055\n      // XXX need to implement this if we implement Symbol or integers, or                                    // 1056\n      // Timestamp                                                                                            // 1057\n      throw Error(\"Missing type coercion logic in _cmp\");                                                     // 1058\n    if (ta === 7) { // ObjectID                                                                               // 1059\n      // Convert to string.                                                                                   // 1060\n      ta = tb = 2;                                                                                            // 1061\n      a = a.toHexString();                                                                                    // 1062\n      b = b.toHexString();                                                                                    // 1063\n    }                                                                                                         // 1064\n    if (ta === 9) { // Date                                                                                   // 1065\n      // Convert to millis.                                                                                   // 1066\n      ta = tb = 1;                                                                                            // 1067\n      a = a.getTime();                                                                                        // 1068\n      b = b.getTime();                                                                                        // 1069\n    }                                                                                                         // 1070\n                                                                                                              // 1071\n    if (ta === 1) // double                                                                                   // 1072\n      return a - b;                                                                                           // 1073\n    if (tb === 2) // string                                                                                   // 1074\n      return a < b ? -1 : (a === b ? 0 : 1);                                                                  // 1075\n    if (ta === 3) { // Object                                                                                 // 1076\n      // this could be much more efficient in the expected case ...                                           // 1077\n      var to_array = function (obj) {                                                                         // 1078\n        var ret = [];                                                                                         // 1079\n        for (var key in obj) {                                                                                // 1080\n          ret.push(key);                                                                                      // 1081\n          ret.push(obj[key]);                                                                                 // 1082\n        }                                                                                                     // 1083\n        return ret;                                                                                           // 1084\n      };                                                                                                      // 1085\n      return LocalCollection._f._cmp(to_array(a), to_array(b));                                               // 1086\n    }                                                                                                         // 1087\n    if (ta === 4) { // Array                                                                                  // 1088\n      for (var i = 0; ; i++) {                                                                                // 1089\n        if (i === a.length)                                                                                   // 1090\n          return (i === b.length) ? 0 : -1;                                                                   // 1091\n        if (i === b.length)                                                                                   // 1092\n          return 1;                                                                                           // 1093\n        var s = LocalCollection._f._cmp(a[i], b[i]);                                                          // 1094\n        if (s !== 0)                                                                                          // 1095\n          return s;                                                                                           // 1096\n      }                                                                                                       // 1097\n    }                                                                                                         // 1098\n    if (ta === 5) { // binary                                                                                 // 1099\n      // Surprisingly, a small binary blob is always less than a large one in                                 // 1100\n      // Mongo.                                                                                               // 1101\n      if (a.length !== b.length)                                                                              // 1102\n        return a.length - b.length;                                                                           // 1103\n      for (i = 0; i < a.length; i++) {                                                                        // 1104\n        if (a[i] < b[i])                                                                                      // 1105\n          return -1;                                                                                          // 1106\n        if (a[i] > b[i])                                                                                      // 1107\n          return 1;                                                                                           // 1108\n      }                                                                                                       // 1109\n      return 0;                                                                                               // 1110\n    }                                                                                                         // 1111\n    if (ta === 8) { // boolean                                                                                // 1112\n      if (a) return b ? 0 : 1;                                                                                // 1113\n      return b ? -1 : 0;                                                                                      // 1114\n    }                                                                                                         // 1115\n    if (ta === 10) // null                                                                                    // 1116\n      return 0;                                                                                               // 1117\n    if (ta === 11) // regexp                                                                                  // 1118\n      throw Error(\"Sorting not supported on regular expression\"); // XXX                                      // 1119\n    // 13: javascript code                                                                                    // 1120\n    // 14: symbol                                                                                             // 1121\n    // 15: javascript code with scope                                                                         // 1122\n    // 16: 32-bit integer                                                                                     // 1123\n    // 17: timestamp                                                                                          // 1124\n    // 18: 64-bit integer                                                                                     // 1125\n    // 255: minkey                                                                                            // 1126\n    // 127: maxkey                                                                                            // 1127\n    if (ta === 13) // javascript code                                                                         // 1128\n      throw Error(\"Sorting not supported on Javascript code\"); // XXX                                         // 1129\n    throw Error(\"Unknown type to sort\");                                                                      // 1130\n  }                                                                                                           // 1131\n};                                                                                                            // 1132\n                                                                                                              // 1133\n// Oddball function used by upsert.                                                                           // 1134\nLocalCollection._removeDollarOperators = function (selector) {                                                // 1135\n  var selectorDoc = {};                                                                                       // 1136\n  for (var k in selector)                                                                                     // 1137\n    if (k.substr(0, 1) !== '$')                                                                               // 1138\n      selectorDoc[k] = selector[k];                                                                           // 1139\n  return selectorDoc;                                                                                         // 1140\n};                                                                                                            // 1141\n                                                                                                              // 1142\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/sort.js                                                                                 //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Give a sort spec, which can be in any of these forms:                                                      // 1\n//   {\"key1\": 1, \"key2\": -1}                                                                                  // 2\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]                                                                      // 3\n//   [\"key1\", [\"key2\", \"desc\"]]                                                                               // 4\n//                                                                                                            // 5\n// (.. with the first form being dependent on the key enumeration                                             // 6\n// behavior of your javascript VM, which usually does what you mean in                                        // 7\n// this case if the key names don't look like integers ..)                                                    // 8\n//                                                                                                            // 9\n// return a function that takes two objects, and returns -1 if the                                            // 10\n// first object comes first in order, 1 if the second object comes                                            // 11\n// first, or 0 if neither object comes before the other.                                                      // 12\n                                                                                                              // 13\nMinimongo.Sorter = function (spec, options) {                                                                 // 14\n  var self = this;                                                                                            // 15\n  options = options || {};                                                                                    // 16\n                                                                                                              // 17\n  self._sortSpecParts = [];                                                                                   // 18\n                                                                                                              // 19\n  var addSpecPart = function (path, ascending) {                                                              // 20\n    if (!path)                                                                                                // 21\n      throw Error(\"sort keys must be non-empty\");                                                             // 22\n    if (path.charAt(0) === '$')                                                                               // 23\n      throw Error(\"unsupported sort key: \" + path);                                                           // 24\n    self._sortSpecParts.push({                                                                                // 25\n      path: path,                                                                                             // 26\n      lookup: makeLookupFunction(path, {forSort: true}),                                                      // 27\n      ascending: ascending                                                                                    // 28\n    });                                                                                                       // 29\n  };                                                                                                          // 30\n                                                                                                              // 31\n  if (spec instanceof Array) {                                                                                // 32\n    for (var i = 0; i < spec.length; i++) {                                                                   // 33\n      if (typeof spec[i] === \"string\") {                                                                      // 34\n        addSpecPart(spec[i], true);                                                                           // 35\n      } else {                                                                                                // 36\n        addSpecPart(spec[i][0], spec[i][1] !== \"desc\");                                                       // 37\n      }                                                                                                       // 38\n    }                                                                                                         // 39\n  } else if (typeof spec === \"object\") {                                                                      // 40\n    _.each(spec, function (value, key) {                                                                      // 41\n      addSpecPart(key, value >= 0);                                                                           // 42\n    });                                                                                                       // 43\n  } else {                                                                                                    // 44\n    throw Error(\"Bad sort specification: \" + JSON.stringify(spec));                                           // 45\n  }                                                                                                           // 46\n                                                                                                              // 47\n  // To implement affectedByModifier, we piggy-back on top of Matcher's                                       // 48\n  // affectedByModifier code; we create a selector that is affected by the same                               // 49\n  // modifiers as this sort order. This is only implemented on the server.                                    // 50\n  if (self.affectedByModifier) {                                                                              // 51\n    var selector = {};                                                                                        // 52\n    _.each(self._sortSpecParts, function (spec) {                                                             // 53\n      selector[spec.path] = 1;                                                                                // 54\n    });                                                                                                       // 55\n    self._selectorForAffectedByModifier = new Minimongo.Matcher(selector);                                    // 56\n  }                                                                                                           // 57\n                                                                                                              // 58\n  self._keyComparator = composeComparators(                                                                   // 59\n    _.map(self._sortSpecParts, function (spec, i) {                                                           // 60\n      return self._keyFieldComparator(i);                                                                     // 61\n    }));                                                                                                      // 62\n                                                                                                              // 63\n  // If you specify a matcher for this Sorter, _keyFilter may be set to a                                     // 64\n  // function which selects whether or not a given \"sort key\" (tuple of values                                // 65\n  // for the different sort spec fields) is compatible with the selector.                                     // 66\n  self._keyFilter = null;                                                                                     // 67\n  options.matcher && self._useWithMatcher(options.matcher);                                                   // 68\n};                                                                                                            // 69\n                                                                                                              // 70\n// In addition to these methods, sorter_project.js defines combineIntoProjection                              // 71\n// on the server only.                                                                                        // 72\n_.extend(Minimongo.Sorter.prototype, {                                                                        // 73\n  getComparator: function (options) {                                                                         // 74\n    var self = this;                                                                                          // 75\n                                                                                                              // 76\n    // If we have no distances, just use the comparator from the source                                       // 77\n    // specification (which defaults to \"everything is equal\".                                                // 78\n    if (!options || !options.distances) {                                                                     // 79\n      return self._getBaseComparator();                                                                       // 80\n    }                                                                                                         // 81\n                                                                                                              // 82\n    var distances = options.distances;                                                                        // 83\n                                                                                                              // 84\n    // Return a comparator which first tries the sort specification, and if that                              // 85\n    // says \"it's equal\", breaks ties using $near distances.                                                  // 86\n    return composeComparators([self._getBaseComparator(), function (a, b) {                                   // 87\n      if (!distances.has(a._id))                                                                              // 88\n        throw Error(\"Missing distance for \" + a._id);                                                         // 89\n      if (!distances.has(b._id))                                                                              // 90\n        throw Error(\"Missing distance for \" + b._id);                                                         // 91\n      return distances.get(a._id) - distances.get(b._id);                                                     // 92\n    }]);                                                                                                      // 93\n  },                                                                                                          // 94\n                                                                                                              // 95\n  _getPaths: function () {                                                                                    // 96\n    var self = this;                                                                                          // 97\n    return _.pluck(self._sortSpecParts, 'path');                                                              // 98\n  },                                                                                                          // 99\n                                                                                                              // 100\n  // Finds the minimum key from the doc, according to the sort specs.  (We say                                // 101\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"                                // 102\n  // sort fields mean we're finding the max for that field.)                                                  // 103\n  //                                                                                                          // 104\n  // Note that this is NOT \"find the minimum value of the first field, the                                    // 105\n  // minimum value of the second field, etc\"... it's \"choose the                                              // 106\n  // lexicographically minimum value of the key vector, allowing only keys which                              // 107\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:                                // 108\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and                              // 109\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.                                        // 110\n  _getMinKeyFromDoc: function (doc) {                                                                         // 111\n    var self = this;                                                                                          // 112\n    var minKey = null;                                                                                        // 113\n                                                                                                              // 114\n    self._generateKeysFromDoc(doc, function (key) {                                                           // 115\n      if (!self._keyCompatibleWithSelector(key))                                                              // 116\n        return;                                                                                               // 117\n                                                                                                              // 118\n      if (minKey === null) {                                                                                  // 119\n        minKey = key;                                                                                         // 120\n        return;                                                                                               // 121\n      }                                                                                                       // 122\n      if (self._compareKeys(key, minKey) < 0) {                                                               // 123\n        minKey = key;                                                                                         // 124\n      }                                                                                                       // 125\n    });                                                                                                       // 126\n                                                                                                              // 127\n    // This could happen if our key filter somehow filters out all the keys even                              // 128\n    // though somehow the selector matches.                                                                   // 129\n    if (minKey === null)                                                                                      // 130\n      throw Error(\"sort selector found no keys in doc?\");                                                     // 131\n    return minKey;                                                                                            // 132\n  },                                                                                                          // 133\n                                                                                                              // 134\n  _keyCompatibleWithSelector: function (key) {                                                                // 135\n    var self = this;                                                                                          // 136\n    return !self._keyFilter || self._keyFilter(key);                                                          // 137\n  },                                                                                                          // 138\n                                                                                                              // 139\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling                               // 140\n  // 'cb' with the key.                                                                                       // 141\n  _generateKeysFromDoc: function (doc, cb) {                                                                  // 142\n    var self = this;                                                                                          // 143\n                                                                                                              // 144\n    if (self._sortSpecParts.length === 0)                                                                     // 145\n      throw new Error(\"can't generate keys without a spec\");                                                  // 146\n                                                                                                              // 147\n    // maps index -> ({'' -> value} or {path -> value})                                                       // 148\n    var valuesByIndexAndPath = [];                                                                            // 149\n                                                                                                              // 150\n    var pathFromIndices = function (indices) {                                                                // 151\n      return indices.join(',') + ',';                                                                         // 152\n    };                                                                                                        // 153\n                                                                                                              // 154\n    var knownPaths = null;                                                                                    // 155\n                                                                                                              // 156\n    _.each(self._sortSpecParts, function (spec, whichField) {                                                 // 157\n      // Expand any leaf arrays that we find, and ignore those arrays                                         // 158\n      // themselves.  (We never sort based on an array itself.)                                               // 159\n      var branches = expandArraysInBranches(spec.lookup(doc), true);                                          // 160\n                                                                                                              // 161\n      // If there are no values for a key (eg, key goes to an empty array),                                   // 162\n      // pretend we found one null value.                                                                     // 163\n      if (!branches.length)                                                                                   // 164\n        branches = [{value: null}];                                                                           // 165\n                                                                                                              // 166\n      var usedPaths = false;                                                                                  // 167\n      valuesByIndexAndPath[whichField] = {};                                                                  // 168\n      _.each(branches, function (branch) {                                                                    // 169\n        if (!branch.arrayIndices) {                                                                           // 170\n          // If there are no array indices for a branch, then it must be the                                  // 171\n          // only branch, because the only thing that produces multiple branches                              // 172\n          // is the use of arrays.                                                                            // 173\n          if (branches.length > 1)                                                                            // 174\n            throw Error(\"multiple branches but no array used?\");                                              // 175\n          valuesByIndexAndPath[whichField][''] = branch.value;                                                // 176\n          return;                                                                                             // 177\n        }                                                                                                     // 178\n                                                                                                              // 179\n        usedPaths = true;                                                                                     // 180\n        var path = pathFromIndices(branch.arrayIndices);                                                      // 181\n        if (_.has(valuesByIndexAndPath[whichField], path))                                                    // 182\n          throw Error(\"duplicate path: \" + path);                                                             // 183\n        valuesByIndexAndPath[whichField][path] = branch.value;                                                // 184\n                                                                                                              // 185\n        // If two sort fields both go into arrays, they have to go into the                                   // 186\n        // exact same arrays and we have to find the same paths.  This is                                     // 187\n        // roughly the same condition that makes MongoDB throw this strange                                   // 188\n        // error message.  eg, the main thing is that if sort spec is {a: 1,                                  // 189\n        // b:1} then a and b cannot both be arrays.                                                           // 190\n        //                                                                                                    // 191\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'                                 // 192\n        // and 'a.x.y' are both arrays, but we don't allow this for now.                                      // 193\n        // #NestedArraySort                                                                                   // 194\n        // XXX achieve full compatibility here                                                                // 195\n        if (knownPaths && !_.has(knownPaths, path)) {                                                         // 196\n          throw Error(\"cannot index parallel arrays\");                                                        // 197\n        }                                                                                                     // 198\n      });                                                                                                     // 199\n                                                                                                              // 200\n      if (knownPaths) {                                                                                       // 201\n        // Similarly to above, paths must match everywhere, unless this is a                                  // 202\n        // non-array field.                                                                                   // 203\n        if (!_.has(valuesByIndexAndPath[whichField], '') &&                                                   // 204\n            _.size(knownPaths) !== _.size(valuesByIndexAndPath[whichField])) {                                // 205\n          throw Error(\"cannot index parallel arrays!\");                                                       // 206\n        }                                                                                                     // 207\n      } else if (usedPaths) {                                                                                 // 208\n        knownPaths = {};                                                                                      // 209\n        _.each(valuesByIndexAndPath[whichField], function (x, path) {                                         // 210\n          knownPaths[path] = true;                                                                            // 211\n        });                                                                                                   // 212\n      }                                                                                                       // 213\n    });                                                                                                       // 214\n                                                                                                              // 215\n    if (!knownPaths) {                                                                                        // 216\n      // Easy case: no use of arrays.                                                                         // 217\n      var soleKey = _.map(valuesByIndexAndPath, function (values) {                                           // 218\n        if (!_.has(values, ''))                                                                               // 219\n          throw Error(\"no value in sole key case?\");                                                          // 220\n        return values[''];                                                                                    // 221\n      });                                                                                                     // 222\n      cb(soleKey);                                                                                            // 223\n      return;                                                                                                 // 224\n    }                                                                                                         // 225\n                                                                                                              // 226\n    _.each(knownPaths, function (x, path) {                                                                   // 227\n      var key = _.map(valuesByIndexAndPath, function (values) {                                               // 228\n        if (_.has(values, ''))                                                                                // 229\n          return values[''];                                                                                  // 230\n        if (!_.has(values, path))                                                                             // 231\n          throw Error(\"missing path?\");                                                                       // 232\n        return values[path];                                                                                  // 233\n      });                                                                                                     // 234\n      cb(key);                                                                                                // 235\n    });                                                                                                       // 236\n  },                                                                                                          // 237\n                                                                                                              // 238\n  // Takes in two keys: arrays whose lengths match the number of spec                                         // 239\n  // parts. Returns negative, 0, or positive based on using the sort spec to                                  // 240\n  // compare fields.                                                                                          // 241\n  _compareKeys: function (key1, key2) {                                                                       // 242\n    var self = this;                                                                                          // 243\n    if (key1.length !== self._sortSpecParts.length ||                                                         // 244\n        key2.length !== self._sortSpecParts.length) {                                                         // 245\n      throw Error(\"Key has wrong length\");                                                                    // 246\n    }                                                                                                         // 247\n                                                                                                              // 248\n    return self._keyComparator(key1, key2);                                                                   // 249\n  },                                                                                                          // 250\n                                                                                                              // 251\n  // Given an index 'i', returns a comparator that compares two key arrays based                              // 252\n  // on field 'i'.                                                                                            // 253\n  _keyFieldComparator: function (i) {                                                                         // 254\n    var self = this;                                                                                          // 255\n    var invert = !self._sortSpecParts[i].ascending;                                                           // 256\n    return function (key1, key2) {                                                                            // 257\n      var compare = LocalCollection._f._cmp(key1[i], key2[i]);                                                // 258\n      if (invert)                                                                                             // 259\n        compare = -compare;                                                                                   // 260\n      return compare;                                                                                         // 261\n    };                                                                                                        // 262\n  },                                                                                                          // 263\n                                                                                                              // 264\n  // Returns a comparator that represents the sort specification (but not                                     // 265\n  // including a possible geoquery distance tie-breaker).                                                     // 266\n  _getBaseComparator: function () {                                                                           // 267\n    var self = this;                                                                                          // 268\n                                                                                                              // 269\n    // If we're only sorting on geoquery distance and no specs, just say                                      // 270\n    // everything is equal.                                                                                   // 271\n    if (!self._sortSpecParts.length) {                                                                        // 272\n      return function (doc1, doc2) {                                                                          // 273\n        return 0;                                                                                             // 274\n      };                                                                                                      // 275\n    }                                                                                                         // 276\n                                                                                                              // 277\n    return function (doc1, doc2) {                                                                            // 278\n      var key1 = self._getMinKeyFromDoc(doc1);                                                                // 279\n      var key2 = self._getMinKeyFromDoc(doc2);                                                                // 280\n      return self._compareKeys(key1, key2);                                                                   // 281\n    };                                                                                                        // 282\n  },                                                                                                          // 283\n                                                                                                              // 284\n  // In MongoDB, if you have documents                                                                        // 285\n  //    {_id: 'x', a: [1, 10]} and                                                                            // 286\n  //    {_id: 'y', a: [5, 15]},                                                                               // 287\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).                                      // 288\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not                                   // 289\n  // match the selector, and 5 comes before 10).                                                              // 290\n  //                                                                                                          // 291\n  // The way this works is pretty subtle!  For example, if the documents                                      // 292\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and                                                        // 293\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),                                                           // 294\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and                                                   // 295\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})                                        // 296\n  // both follow this rule (y before x).  (ie, you do have to apply this                                      // 297\n  // through $elemMatch.)                                                                                     // 298\n  //                                                                                                          // 299\n  // So if you pass a matcher to this sorter's constructor, we will attempt to                                // 300\n  // skip sort keys that don't match the selector. The logic here is pretty                                   // 301\n  // subtle and undocumented; we've gotten as close as we can figure out based                                // 302\n  // on our understanding of Mongo's behavior.                                                                // 303\n  _useWithMatcher: function (matcher) {                                                                       // 304\n    var self = this;                                                                                          // 305\n                                                                                                              // 306\n    if (self._keyFilter)                                                                                      // 307\n      throw Error(\"called _useWithMatcher twice?\");                                                           // 308\n                                                                                                              // 309\n    // If we are only sorting by distance, then we're not going to bother to                                  // 310\n    // build a key filter.                                                                                    // 311\n    // XXX figure out how geoqueries interact with this stuff                                                 // 312\n    if (_.isEmpty(self._sortSpecParts))                                                                       // 313\n      return;                                                                                                 // 314\n                                                                                                              // 315\n    var selector = matcher._selector;                                                                         // 316\n                                                                                                              // 317\n    // If the user just passed a literal function to find(), then we can't get a                              // 318\n    // key filter from it.                                                                                    // 319\n    if (selector instanceof Function)                                                                         // 320\n      return;                                                                                                 // 321\n                                                                                                              // 322\n    var constraintsByPath = {};                                                                               // 323\n    _.each(self._sortSpecParts, function (spec, i) {                                                          // 324\n      constraintsByPath[spec.path] = [];                                                                      // 325\n    });                                                                                                       // 326\n                                                                                                              // 327\n    _.each(selector, function (subSelector, key) {                                                            // 328\n      // XXX support $and and $or                                                                             // 329\n                                                                                                              // 330\n      var constraints = constraintsByPath[key];                                                               // 331\n      if (!constraints)                                                                                       // 332\n        return;                                                                                               // 333\n                                                                                                              // 334\n      // XXX it looks like the real MongoDB implementation isn't \"does the                                    // 335\n      // regexp match\" but \"does the value fall into a range named by the                                     // 336\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But                                     // 337\n      // \"does the regexp match\" is a good approximation.                                                     // 338\n      if (subSelector instanceof RegExp) {                                                                    // 339\n        // As far as we can tell, using either of the options that both we and                                // 340\n        // MongoDB support ('i' and 'm') disables use of the key filter. This                                 // 341\n        // makes sense: MongoDB mostly appears to be calculating ranges of an                                 // 342\n        // index to use, which means it only cares about regexps that match                                   // 343\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the                                // 344\n        // literal prefix of the regexp from actually meaning one range.                                      // 345\n        if (subSelector.ignoreCase || subSelector.multiline)                                                  // 346\n          return;                                                                                             // 347\n        constraints.push(regexpElementMatcher(subSelector));                                                  // 348\n        return;                                                                                               // 349\n      }                                                                                                       // 350\n                                                                                                              // 351\n      if (isOperatorObject(subSelector)) {                                                                    // 352\n        _.each(subSelector, function (operand, operator) {                                                    // 353\n          if (_.contains(['$lt', '$lte', '$gt', '$gte'], operator)) {                                         // 354\n            // XXX this depends on us knowing that these operators don't use any                              // 355\n            // of the arguments to compileElementSelector other than operand.                                 // 356\n            constraints.push(                                                                                 // 357\n              ELEMENT_OPERATORS[operator].compileElementSelector(operand));                                   // 358\n          }                                                                                                   // 359\n                                                                                                              // 360\n          // See comments in the RegExp block above.                                                          // 361\n          if (operator === '$regex' && !subSelector.$options) {                                               // 362\n            constraints.push(                                                                                 // 363\n              ELEMENT_OPERATORS.$regex.compileElementSelector(                                                // 364\n                operand, subSelector));                                                                       // 365\n          }                                                                                                   // 366\n                                                                                                              // 367\n          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch                                        // 368\n        });                                                                                                   // 369\n        return;                                                                                               // 370\n      }                                                                                                       // 371\n                                                                                                              // 372\n      // OK, it's an equality thing.                                                                          // 373\n      constraints.push(equalityElementMatcher(subSelector));                                                  // 374\n    });                                                                                                       // 375\n                                                                                                              // 376\n    // It appears that the first sort field is treated differently from the                                   // 377\n    // others; we shouldn't create a key filter unless the first sort field is                                // 378\n    // restricted, though after that point we can restrict the other sort fields                              // 379\n    // or not as we wish.                                                                                     // 380\n    if (_.isEmpty(constraintsByPath[self._sortSpecParts[0].path]))                                            // 381\n      return;                                                                                                 // 382\n                                                                                                              // 383\n    self._keyFilter = function (key) {                                                                        // 384\n      return _.all(self._sortSpecParts, function (specPart, index) {                                          // 385\n        return _.all(constraintsByPath[specPart.path], function (f) {                                         // 386\n          return f(key[index]);                                                                               // 387\n        });                                                                                                   // 388\n      });                                                                                                     // 389\n    };                                                                                                        // 390\n  }                                                                                                           // 391\n});                                                                                                           // 392\n                                                                                                              // 393\n// Given an array of comparators                                                                              // 394\n// (functions (a,b)->(negative or positive or zero)), returns a single                                        // 395\n// comparator which uses each comparator in order and returns the first                                       // 396\n// non-zero value.                                                                                            // 397\nvar composeComparators = function (comparatorArray) {                                                         // 398\n  return function (a, b) {                                                                                    // 399\n    for (var i = 0; i < comparatorArray.length; ++i) {                                                        // 400\n      var compare = comparatorArray[i](a, b);                                                                 // 401\n      if (compare !== 0)                                                                                      // 402\n        return compare;                                                                                       // 403\n    }                                                                                                         // 404\n    return 0;                                                                                                 // 405\n  };                                                                                                          // 406\n};                                                                                                            // 407\n                                                                                                              // 408\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/projection.js                                                                           //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Knows how to compile a fields projection to a predicate function.                                          // 1\n// @returns - Function: a closure that filters out an object according to the                                 // 2\n//            fields projection rules:                                                                        // 3\n//            @param obj - Object: MongoDB-styled document                                                    // 4\n//            @returns - Object: a document with the fields filtered out                                      // 5\n//                       according to projection rules. Doesn't retain subfields                              // 6\n//                       of passed argument.                                                                  // 7\nLocalCollection._compileProjection = function (fields) {                                                      // 8\n  LocalCollection._checkSupportedProjection(fields);                                                          // 9\n                                                                                                              // 10\n  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;                                          // 11\n  var details = projectionDetails(fields);                                                                    // 12\n                                                                                                              // 13\n  // returns transformed doc according to ruleTree                                                            // 14\n  var transform = function (doc, ruleTree) {                                                                  // 15\n    // Special case for \"sets\"                                                                                // 16\n    if (_.isArray(doc))                                                                                       // 17\n      return _.map(doc, function (subdoc) { return transform(subdoc, ruleTree); });                           // 18\n                                                                                                              // 19\n    var res = details.including ? {} : EJSON.clone(doc);                                                      // 20\n    _.each(ruleTree, function (rule, key) {                                                                   // 21\n      if (!_.has(doc, key))                                                                                   // 22\n        return;                                                                                               // 23\n      if (_.isObject(rule)) {                                                                                 // 24\n        // For sub-objects/subsets we branch                                                                  // 25\n        if (_.isObject(doc[key]))                                                                             // 26\n          res[key] = transform(doc[key], rule);                                                               // 27\n        // Otherwise we don't even touch this subfield                                                        // 28\n      } else if (details.including)                                                                           // 29\n        res[key] = EJSON.clone(doc[key]);                                                                     // 30\n      else                                                                                                    // 31\n        delete res[key];                                                                                      // 32\n    });                                                                                                       // 33\n                                                                                                              // 34\n    return res;                                                                                               // 35\n  };                                                                                                          // 36\n                                                                                                              // 37\n  return function (obj) {                                                                                     // 38\n    var res = transform(obj, details.tree);                                                                   // 39\n                                                                                                              // 40\n    if (_idProjection && _.has(obj, '_id'))                                                                   // 41\n      res._id = obj._id;                                                                                      // 42\n    if (!_idProjection && _.has(res, '_id'))                                                                  // 43\n      delete res._id;                                                                                         // 44\n    return res;                                                                                               // 45\n  };                                                                                                          // 46\n};                                                                                                            // 47\n                                                                                                              // 48\n// Traverses the keys of passed projection and constructs a tree where all                                    // 49\n// leaves are either all True or all False                                                                    // 50\n// @returns Object:                                                                                           // 51\n//  - tree - Object - tree representation of keys involved in projection                                      // 52\n//  (exception for '_id' as it is a special case handled separately)                                          // 53\n//  - including - Boolean - \"take only certain fields\" type of projection                                     // 54\nprojectionDetails = function (fields) {                                                                       // 55\n  // Find the non-_id keys (_id is handled specially because it is included unless                            // 56\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps                                 // 57\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.                                              // 58\n  var fieldsKeys = _.keys(fields).sort();                                                                     // 59\n                                                                                                              // 60\n  // If _id is the only field in the projection, do not remove it, since it is                                // 61\n  // required to determine if this is an exclusion or exclusion. Also keep an                                 // 62\n  // inclusive _id, since inclusive _id follows the normal rules about mixing                                 // 63\n  // inclusive and exclusive fields. If _id is not the only field in the                                      // 64\n  // projection and is exclusive, remove it so it can be handled later by a                                   // 65\n  // special case, since exclusive _id is always allowed.                                                     // 66\n  if (fieldsKeys.length > 0 &&                                                                                // 67\n      !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&                                                // 68\n      !(_.contains(fieldsKeys, '_id') && fields['_id']))                                                      // 69\n    fieldsKeys = _.reject(fieldsKeys, function (key) { return key === '_id'; });                              // 70\n                                                                                                              // 71\n  var including = null; // Unknown                                                                            // 72\n                                                                                                              // 73\n  _.each(fieldsKeys, function (keyPath) {                                                                     // 74\n    var rule = !!fields[keyPath];                                                                             // 75\n    if (including === null)                                                                                   // 76\n      including = rule;                                                                                       // 77\n    if (including !== rule)                                                                                   // 78\n      // This error message is copied from MongoDB shell                                                      // 79\n      throw MinimongoError(\"You cannot currently mix including and excluding fields.\");                       // 80\n  });                                                                                                         // 81\n                                                                                                              // 82\n                                                                                                              // 83\n  var projectionRulesTree = pathsToTree(                                                                      // 84\n    fieldsKeys,                                                                                               // 85\n    function (path) { return including; },                                                                    // 86\n    function (node, path, fullPath) {                                                                         // 87\n      // Check passed projection fields' keys: If you have two rules such as                                  // 88\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If                                   // 89\n      // that happens, there is a probability you are doing something wrong,                                  // 90\n      // framework should notify you about such mistake earlier on cursor                                     // 91\n      // compilation step than later during runtime.  Note, that real mongo                                   // 92\n      // doesn't do anything about it and the later rule appears in projection                                // 93\n      // project, more priority it takes.                                                                     // 94\n      //                                                                                                      // 95\n      // Example, assume following in mongo shell:                                                            // 96\n      // > db.coll.insert({ a: { b: 23, c: 44 } })                                                            // 97\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })                                                             // 98\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23 } }                                 // 99\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })                                                             // 100\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23, \"c\" : 44 } }                       // 101\n      //                                                                                                      // 102\n      // Note, how second time the return set of keys is different.                                           // 103\n                                                                                                              // 104\n      var currentPath = fullPath;                                                                             // 105\n      var anotherPath = path;                                                                                 // 106\n      throw MinimongoError(\"both \" + currentPath + \" and \" + anotherPath +                                    // 107\n                           \" found in fields option, using both of them may trigger \" +                       // 108\n                           \"unexpected behavior. Did you mean to use only one of them?\");                     // 109\n    });                                                                                                       // 110\n                                                                                                              // 111\n  return {                                                                                                    // 112\n    tree: projectionRulesTree,                                                                                // 113\n    including: including                                                                                      // 114\n  };                                                                                                          // 115\n};                                                                                                            // 116\n                                                                                                              // 117\n// paths - Array: list of mongo style paths                                                                   // 118\n// newLeafFn - Function: of form function(path) should return a scalar value to                               // 119\n//                       put into list created for that path                                                  // 120\n// conflictFn - Function: of form function(node, path, fullPath) is called                                    // 121\n//                        when building a tree path for 'fullPath' node on                                    // 122\n//                        'path' was already a leaf with a value. Must return a                               // 123\n//                        conflict resolution.                                                                // 124\n// initial tree - Optional Object: starting tree.                                                             // 125\n// @returns - Object: tree represented as a set of nested objects                                             // 126\npathsToTree = function (paths, newLeafFn, conflictFn, tree) {                                                 // 127\n  tree = tree || {};                                                                                          // 128\n  _.each(paths, function (keyPath) {                                                                          // 129\n    var treePos = tree;                                                                                       // 130\n    var pathArr = keyPath.split('.');                                                                         // 131\n                                                                                                              // 132\n    // use _.all just for iteration with break                                                                // 133\n    var success = _.all(pathArr.slice(0, -1), function (key, idx) {                                           // 134\n      if (!_.has(treePos, key))                                                                               // 135\n        treePos[key] = {};                                                                                    // 136\n      else if (!_.isObject(treePos[key])) {                                                                   // 137\n        treePos[key] = conflictFn(treePos[key],                                                               // 138\n                                  pathArr.slice(0, idx + 1).join('.'),                                        // 139\n                                  keyPath);                                                                   // 140\n        // break out of loop if we are failing for this path                                                  // 141\n        if (!_.isObject(treePos[key]))                                                                        // 142\n          return false;                                                                                       // 143\n      }                                                                                                       // 144\n                                                                                                              // 145\n      treePos = treePos[key];                                                                                 // 146\n      return true;                                                                                            // 147\n    });                                                                                                       // 148\n                                                                                                              // 149\n    if (success) {                                                                                            // 150\n      var lastKey = _.last(pathArr);                                                                          // 151\n      if (!_.has(treePos, lastKey))                                                                           // 152\n        treePos[lastKey] = newLeafFn(keyPath);                                                                // 153\n      else                                                                                                    // 154\n        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);                                    // 155\n    }                                                                                                         // 156\n  });                                                                                                         // 157\n                                                                                                              // 158\n  return tree;                                                                                                // 159\n};                                                                                                            // 160\n                                                                                                              // 161\nLocalCollection._checkSupportedProjection = function (fields) {                                               // 162\n  if (!_.isObject(fields) || _.isArray(fields))                                                               // 163\n    throw MinimongoError(\"fields option must be an object\");                                                  // 164\n                                                                                                              // 165\n  _.each(fields, function (val, keyPath) {                                                                    // 166\n    if (_.contains(keyPath.split('.'), '$'))                                                                  // 167\n      throw MinimongoError(\"Minimongo doesn't support $ operator in projections yet.\");                       // 168\n    if (typeof val === 'object' && _.intersection(['$elemMatch', '$meta', '$slice'], _.keys(val)).length > 0)\n      throw MinimongoError(\"Minimongo doesn't support operators in projections yet.\");                        // 170\n    if (_.indexOf([1, 0, true, false], val) === -1)                                                           // 171\n      throw MinimongoError(\"Projection values should be one of 1, 0, true, or false\");                        // 172\n  });                                                                                                         // 173\n};                                                                                                            // 174\n                                                                                                              // 175\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/modify.js                                                                               //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// XXX need a strategy for passing the binding of $ into this                                                 // 1\n// function, from the compiled selector                                                                       // 2\n//                                                                                                            // 3\n// maybe just {key.up.to.just.before.dollarsign: array_index}                                                 // 4\n//                                                                                                            // 5\n// XXX atomicity: if one modification fails, do we roll back the whole                                        // 6\n// change?                                                                                                    // 7\n//                                                                                                            // 8\n// options:                                                                                                   // 9\n//   - isInsert is set when _modify is being called to compute the document to                                // 10\n//     insert as part of an upsert operation. We use this primarily to figure                                 // 11\n//     out when to set the fields in $setOnInsert, if present.                                                // 12\nLocalCollection._modify = function (doc, mod, options) {                                                      // 13\n  options = options || {};                                                                                    // 14\n  if (!isPlainObject(mod))                                                                                    // 15\n    throw MinimongoError(\"Modifier must be an object\");                                                       // 16\n                                                                                                              // 17\n  // Make sure the caller can't mutate our data structures.                                                   // 18\n  mod = EJSON.clone(mod);                                                                                     // 19\n                                                                                                              // 20\n  var isModifier = isOperatorObject(mod);                                                                     // 21\n                                                                                                              // 22\n  var newDoc;                                                                                                 // 23\n                                                                                                              // 24\n  if (!isModifier) {                                                                                          // 25\n    if (mod._id && !EJSON.equals(doc._id, mod._id))                                                           // 26\n      throw MinimongoError(\"Cannot change the _id of a document\");                                            // 27\n                                                                                                              // 28\n    // replace the whole document                                                                             // 29\n    for (var k in mod) {                                                                                      // 30\n      if (/\\./.test(k))                                                                                       // 31\n        throw MinimongoError(                                                                                 // 32\n          \"When replacing document, field name may not contain '.'\");                                         // 33\n    }                                                                                                         // 34\n    newDoc = mod;                                                                                             // 35\n  } else {                                                                                                    // 36\n    // apply modifiers to the doc.                                                                            // 37\n    newDoc = EJSON.clone(doc);                                                                                // 38\n                                                                                                              // 39\n    _.each(mod, function (operand, op) {                                                                      // 40\n      var modFunc = MODIFIERS[op];                                                                            // 41\n      // Treat $setOnInsert as $set if this is an insert.                                                     // 42\n      if (options.isInsert && op === '$setOnInsert')                                                          // 43\n        modFunc = MODIFIERS['$set'];                                                                          // 44\n      if (!modFunc)                                                                                           // 45\n        throw MinimongoError(\"Invalid modifier specified \" + op);                                             // 46\n      _.each(operand, function (arg, keypath) {                                                               // 47\n        if (keypath === '') {                                                                                 // 48\n          throw MinimongoError(\"An empty update path is not valid.\");                                         // 49\n        }                                                                                                     // 50\n                                                                                                              // 51\n        if (keypath === '_id') {                                                                              // 52\n          throw MinimongoError(\"Mod on _id not allowed\");                                                     // 53\n        }                                                                                                     // 54\n                                                                                                              // 55\n        var keyparts = keypath.split('.');                                                                    // 56\n                                                                                                              // 57\n        if (! _.all(keyparts, _.identity)) {                                                                  // 58\n          throw MinimongoError(                                                                               // 59\n            \"The update path '\" + keypath +                                                                   // 60\n              \"' contains an empty field name, which is not allowed.\");                                       // 61\n        }                                                                                                     // 62\n                                                                                                              // 63\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);                                                        // 64\n        var forbidArray = (op === \"$rename\");                                                                 // 65\n        var target = findModTarget(newDoc, keyparts, {                                                        // 66\n          noCreate: NO_CREATE_MODIFIERS[op],                                                                  // 67\n          forbidArray: (op === \"$rename\"),                                                                    // 68\n          arrayIndices: options.arrayIndices                                                                  // 69\n        });                                                                                                   // 70\n        var field = keyparts.pop();                                                                           // 71\n        modFunc(target, field, arg, keypath, newDoc);                                                         // 72\n      });                                                                                                     // 73\n    });                                                                                                       // 74\n  }                                                                                                           // 75\n                                                                                                              // 76\n  // move new document into place.                                                                            // 77\n  _.each(_.keys(doc), function (k) {                                                                          // 78\n    // Note: this used to be for (var k in doc) however, this does not                                        // 79\n    // work right in Opera. Deleting from a doc while iterating over it                                       // 80\n    // would sometimes cause opera to skip some keys.                                                         // 81\n    if (k !== '_id')                                                                                          // 82\n      delete doc[k];                                                                                          // 83\n  });                                                                                                         // 84\n  _.each(newDoc, function (v, k) {                                                                            // 85\n    doc[k] = v;                                                                                               // 86\n  });                                                                                                         // 87\n};                                                                                                            // 88\n                                                                                                              // 89\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],                                        // 90\n// and then you would operate on the 'e' property of the returned                                             // 91\n// object.                                                                                                    // 92\n//                                                                                                            // 93\n// if options.noCreate is falsey, creates intermediate levels of                                              // 94\n// structure as necessary, like mkdir -p (and raises an exception if                                          // 95\n// that would mean giving a non-numeric property to an array.) if                                             // 96\n// options.noCreate is true, return undefined instead.                                                        // 97\n//                                                                                                            // 98\n// may modify the last element of keyparts to signal to the caller that it needs                              // 99\n// to use a different value to index into the returned object (for example,                                   // 100\n// ['a', '01'] -> ['a', 1]).                                                                                  // 101\n//                                                                                                            // 102\n// if forbidArray is true, return null if the keypath goes through an array.                                  // 103\n//                                                                                                            // 104\n// if options.arrayIndices is set, use its first element for the (first) '$' in                               // 105\n// the path.                                                                                                  // 106\nvar findModTarget = function (doc, keyparts, options) {                                                       // 107\n  options = options || {};                                                                                    // 108\n  var usedArrayIndex = false;                                                                                 // 109\n  for (var i = 0; i < keyparts.length; i++) {                                                                 // 110\n    var last = (i === keyparts.length - 1);                                                                   // 111\n    var keypart = keyparts[i];                                                                                // 112\n    var indexable = isIndexable(doc);                                                                         // 113\n    if (!indexable) {                                                                                         // 114\n      if (options.noCreate)                                                                                   // 115\n        return undefined;                                                                                     // 116\n      var e = MinimongoError(                                                                                 // 117\n        \"cannot use the part '\" + keypart + \"' to traverse \" + doc);                                          // 118\n      e.setPropertyError = true;                                                                              // 119\n      throw e;                                                                                                // 120\n    }                                                                                                         // 121\n    if (doc instanceof Array) {                                                                               // 122\n      if (options.forbidArray)                                                                                // 123\n        return null;                                                                                          // 124\n      if (keypart === '$') {                                                                                  // 125\n        if (usedArrayIndex)                                                                                   // 126\n          throw MinimongoError(\"Too many positional (i.e. '$') elements\");                                    // 127\n        if (!options.arrayIndices || !options.arrayIndices.length) {                                          // 128\n          throw MinimongoError(\"The positional operator did not find the \" +                                  // 129\n                               \"match needed from the query\");                                                // 130\n        }                                                                                                     // 131\n        keypart = options.arrayIndices[0];                                                                    // 132\n        usedArrayIndex = true;                                                                                // 133\n      } else if (isNumericKey(keypart)) {                                                                     // 134\n        keypart = parseInt(keypart);                                                                          // 135\n      } else {                                                                                                // 136\n        if (options.noCreate)                                                                                 // 137\n          return undefined;                                                                                   // 138\n        throw MinimongoError(                                                                                 // 139\n          \"can't append to array using string field name [\"                                                   // 140\n                    + keypart + \"]\");                                                                         // 141\n      }                                                                                                       // 142\n      if (last)                                                                                               // 143\n        // handle 'a.01'                                                                                      // 144\n        keyparts[i] = keypart;                                                                                // 145\n      if (options.noCreate && keypart >= doc.length)                                                          // 146\n        return undefined;                                                                                     // 147\n      while (doc.length < keypart)                                                                            // 148\n        doc.push(null);                                                                                       // 149\n      if (!last) {                                                                                            // 150\n        if (doc.length === keypart)                                                                           // 151\n          doc.push({});                                                                                       // 152\n        else if (typeof doc[keypart] !== \"object\")                                                            // 153\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] +                                     // 154\n                      \"' of list value \" + JSON.stringify(doc[keypart]));                                     // 155\n      }                                                                                                       // 156\n    } else {                                                                                                  // 157\n      if (keypart.length && keypart.substr(0, 1) === '$')                                                     // 158\n        throw MinimongoError(\"can't set field named \" + keypart);                                             // 159\n      if (!(keypart in doc)) {                                                                                // 160\n        if (options.noCreate)                                                                                 // 161\n          return undefined;                                                                                   // 162\n        if (!last)                                                                                            // 163\n          doc[keypart] = {};                                                                                  // 164\n      }                                                                                                       // 165\n    }                                                                                                         // 166\n                                                                                                              // 167\n    if (last)                                                                                                 // 168\n      return doc;                                                                                             // 169\n    doc = doc[keypart];                                                                                       // 170\n  }                                                                                                           // 171\n                                                                                                              // 172\n  // notreached                                                                                               // 173\n};                                                                                                            // 174\n                                                                                                              // 175\nvar NO_CREATE_MODIFIERS = {                                                                                   // 176\n  $unset: true,                                                                                               // 177\n  $pop: true,                                                                                                 // 178\n  $rename: true,                                                                                              // 179\n  $pull: true,                                                                                                // 180\n  $pullAll: true                                                                                              // 181\n};                                                                                                            // 182\n                                                                                                              // 183\nvar MODIFIERS = {                                                                                             // 184\n  $inc: function (target, field, arg) {                                                                       // 185\n    if (typeof arg !== \"number\")                                                                              // 186\n      throw MinimongoError(\"Modifier $inc allowed for numbers only\");                                         // 187\n    if (field in target) {                                                                                    // 188\n      if (typeof target[field] !== \"number\")                                                                  // 189\n        throw MinimongoError(\"Cannot apply $inc modifier to non-number\");                                     // 190\n      target[field] += arg;                                                                                   // 191\n    } else {                                                                                                  // 192\n      target[field] = arg;                                                                                    // 193\n    }                                                                                                         // 194\n  },                                                                                                          // 195\n  $set: function (target, field, arg) {                                                                       // 196\n    if (!_.isObject(target)) { // not an array or an object                                                   // 197\n      var e = MinimongoError(\"Cannot set property on non-object field\");                                      // 198\n      e.setPropertyError = true;                                                                              // 199\n      throw e;                                                                                                // 200\n    }                                                                                                         // 201\n    if (target === null) {                                                                                    // 202\n      var e = MinimongoError(\"Cannot set property on null\");                                                  // 203\n      e.setPropertyError = true;                                                                              // 204\n      throw e;                                                                                                // 205\n    }                                                                                                         // 206\n    target[field] = arg;                                                                                      // 207\n  },                                                                                                          // 208\n  $setOnInsert: function (target, field, arg) {                                                               // 209\n    // converted to `$set` in `_modify`                                                                       // 210\n  },                                                                                                          // 211\n  $unset: function (target, field, arg) {                                                                     // 212\n    if (target !== undefined) {                                                                               // 213\n      if (target instanceof Array) {                                                                          // 214\n        if (field in target)                                                                                  // 215\n          target[field] = null;                                                                               // 216\n      } else                                                                                                  // 217\n        delete target[field];                                                                                 // 218\n    }                                                                                                         // 219\n  },                                                                                                          // 220\n  $push: function (target, field, arg) {                                                                      // 221\n    if (target[field] === undefined)                                                                          // 222\n      target[field] = [];                                                                                     // 223\n    if (!(target[field] instanceof Array))                                                                    // 224\n      throw MinimongoError(\"Cannot apply $push modifier to non-array\");                                       // 225\n                                                                                                              // 226\n    if (!(arg && arg.$each)) {                                                                                // 227\n      // Simple mode: not $each                                                                               // 228\n      target[field].push(arg);                                                                                // 229\n      return;                                                                                                 // 230\n    }                                                                                                         // 231\n                                                                                                              // 232\n    // Fancy mode: $each (and maybe $slice and $sort and $position)                                           // 233\n    var toPush = arg.$each;                                                                                   // 234\n    if (!(toPush instanceof Array))                                                                           // 235\n      throw MinimongoError(\"$each must be an array\");                                                         // 236\n                                                                                                              // 237\n    // Parse $position                                                                                        // 238\n    var position = undefined;                                                                                 // 239\n    if ('$position' in arg) {                                                                                 // 240\n      if (typeof arg.$position !== \"number\")                                                                  // 241\n        throw MinimongoError(\"$position must be a numeric value\");                                            // 242\n      // XXX should check to make sure integer                                                                // 243\n      if (arg.$position < 0)                                                                                  // 244\n        throw MinimongoError(\"$position in $push must be zero or positive\");                                  // 245\n      position = arg.$position;                                                                               // 246\n    }                                                                                                         // 247\n                                                                                                              // 248\n    // Parse $slice.                                                                                          // 249\n    var slice = undefined;                                                                                    // 250\n    if ('$slice' in arg) {                                                                                    // 251\n      if (typeof arg.$slice !== \"number\")                                                                     // 252\n        throw MinimongoError(\"$slice must be a numeric value\");                                               // 253\n      // XXX should check to make sure integer                                                                // 254\n      if (arg.$slice > 0)                                                                                     // 255\n        throw MinimongoError(\"$slice in $push must be zero or negative\");                                     // 256\n      slice = arg.$slice;                                                                                     // 257\n    }                                                                                                         // 258\n                                                                                                              // 259\n    // Parse $sort.                                                                                           // 260\n    var sortFunction = undefined;                                                                             // 261\n    if (arg.$sort) {                                                                                          // 262\n      if (slice === undefined)                                                                                // 263\n        throw MinimongoError(\"$sort requires $slice to be present\");                                          // 264\n      // XXX this allows us to use a $sort whose value is an array, but that's                                // 265\n      // actually an extension of the Node driver, so it won't work                                           // 266\n      // server-side. Could be confusing!                                                                     // 267\n      // XXX is it correct that we don't do geo-stuff here?                                                   // 268\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();                                         // 269\n      for (var i = 0; i < toPush.length; i++) {                                                               // 270\n        if (LocalCollection._f._type(toPush[i]) !== 3) {                                                      // 271\n          throw MinimongoError(\"$push like modifiers using $sort \" +                                          // 272\n                      \"require all elements to be objects\");                                                  // 273\n        }                                                                                                     // 274\n      }                                                                                                       // 275\n    }                                                                                                         // 276\n                                                                                                              // 277\n    // Actually push.                                                                                         // 278\n    if (position === undefined) {                                                                             // 279\n      for (var j = 0; j < toPush.length; j++)                                                                 // 280\n        target[field].push(toPush[j]);                                                                        // 281\n    } else {                                                                                                  // 282\n      var spliceArguments = [position, 0];                                                                    // 283\n      for (var j = 0; j < toPush.length; j++)                                                                 // 284\n        spliceArguments.push(toPush[j]);                                                                      // 285\n      Array.prototype.splice.apply(target[field], spliceArguments);                                           // 286\n    }                                                                                                         // 287\n                                                                                                              // 288\n    // Actually sort.                                                                                         // 289\n    if (sortFunction)                                                                                         // 290\n      target[field].sort(sortFunction);                                                                       // 291\n                                                                                                              // 292\n    // Actually slice.                                                                                        // 293\n    if (slice !== undefined) {                                                                                // 294\n      if (slice === 0)                                                                                        // 295\n        target[field] = [];  // differs from Array.slice!                                                     // 296\n      else                                                                                                    // 297\n        target[field] = target[field].slice(slice);                                                           // 298\n    }                                                                                                         // 299\n  },                                                                                                          // 300\n  $pushAll: function (target, field, arg) {                                                                   // 301\n    if (!(typeof arg === \"object\" && arg instanceof Array))                                                   // 302\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");                              // 303\n    var x = target[field];                                                                                    // 304\n    if (x === undefined)                                                                                      // 305\n      target[field] = arg;                                                                                    // 306\n    else if (!(x instanceof Array))                                                                           // 307\n      throw MinimongoError(\"Cannot apply $pushAll modifier to non-array\");                                    // 308\n    else {                                                                                                    // 309\n      for (var i = 0; i < arg.length; i++)                                                                    // 310\n        x.push(arg[i]);                                                                                       // 311\n    }                                                                                                         // 312\n  },                                                                                                          // 313\n  $addToSet: function (target, field, arg) {                                                                  // 314\n    var isEach = false;                                                                                       // 315\n    if (typeof arg === \"object\") {                                                                            // 316\n      //check if first key is '$each'                                                                         // 317\n      for (var k in arg) {                                                                                    // 318\n        if (k === \"$each\")                                                                                    // 319\n          isEach = true;                                                                                      // 320\n        break;                                                                                                // 321\n      }                                                                                                       // 322\n    }                                                                                                         // 323\n    var values = isEach ? arg[\"$each\"] : [arg];                                                               // 324\n    var x = target[field];                                                                                    // 325\n    if (x === undefined)                                                                                      // 326\n      target[field] = values;                                                                                 // 327\n    else if (!(x instanceof Array))                                                                           // 328\n      throw MinimongoError(\"Cannot apply $addToSet modifier to non-array\");                                   // 329\n    else {                                                                                                    // 330\n      _.each(values, function (value) {                                                                       // 331\n        for (var i = 0; i < x.length; i++)                                                                    // 332\n          if (LocalCollection._f._equal(value, x[i]))                                                         // 333\n            return;                                                                                           // 334\n        x.push(value);                                                                                        // 335\n      });                                                                                                     // 336\n    }                                                                                                         // 337\n  },                                                                                                          // 338\n  $pop: function (target, field, arg) {                                                                       // 339\n    if (target === undefined)                                                                                 // 340\n      return;                                                                                                 // 341\n    var x = target[field];                                                                                    // 342\n    if (x === undefined)                                                                                      // 343\n      return;                                                                                                 // 344\n    else if (!(x instanceof Array))                                                                           // 345\n      throw MinimongoError(\"Cannot apply $pop modifier to non-array\");                                        // 346\n    else {                                                                                                    // 347\n      if (typeof arg === 'number' && arg < 0)                                                                 // 348\n        x.splice(0, 1);                                                                                       // 349\n      else                                                                                                    // 350\n        x.pop();                                                                                              // 351\n    }                                                                                                         // 352\n  },                                                                                                          // 353\n  $pull: function (target, field, arg) {                                                                      // 354\n    if (target === undefined)                                                                                 // 355\n      return;                                                                                                 // 356\n    var x = target[field];                                                                                    // 357\n    if (x === undefined)                                                                                      // 358\n      return;                                                                                                 // 359\n    else if (!(x instanceof Array))                                                                           // 360\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");                               // 361\n    else {                                                                                                    // 362\n      var out = [];                                                                                           // 363\n      if (typeof arg === \"object\" && !(arg instanceof Array)) {                                               // 364\n        // XXX would be much nicer to compile this once, rather than                                          // 365\n        // for each document we modify.. but usually we're not                                                // 366\n        // modifying that many documents, so we'll let it slide for                                           // 367\n        // now                                                                                                // 368\n                                                                                                              // 369\n        // XXX Minimongo.Matcher isn't up for the job, because we need                                        // 370\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something                                            // 371\n        // like {$gt: 4} is not normally a complete selector.                                                 // 372\n        // same issue as $elemMatch possibly?                                                                 // 373\n        var matcher = new Minimongo.Matcher(arg);                                                             // 374\n        for (var i = 0; i < x.length; i++)                                                                    // 375\n          if (!matcher.documentMatches(x[i]).result)                                                          // 376\n            out.push(x[i]);                                                                                   // 377\n      } else {                                                                                                // 378\n        for (var i = 0; i < x.length; i++)                                                                    // 379\n          if (!LocalCollection._f._equal(x[i], arg))                                                          // 380\n            out.push(x[i]);                                                                                   // 381\n      }                                                                                                       // 382\n      target[field] = out;                                                                                    // 383\n    }                                                                                                         // 384\n  },                                                                                                          // 385\n  $pullAll: function (target, field, arg) {                                                                   // 386\n    if (!(typeof arg === \"object\" && arg instanceof Array))                                                   // 387\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");                              // 388\n    if (target === undefined)                                                                                 // 389\n      return;                                                                                                 // 390\n    var x = target[field];                                                                                    // 391\n    if (x === undefined)                                                                                      // 392\n      return;                                                                                                 // 393\n    else if (!(x instanceof Array))                                                                           // 394\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");                               // 395\n    else {                                                                                                    // 396\n      var out = [];                                                                                           // 397\n      for (var i = 0; i < x.length; i++) {                                                                    // 398\n        var exclude = false;                                                                                  // 399\n        for (var j = 0; j < arg.length; j++) {                                                                // 400\n          if (LocalCollection._f._equal(x[i], arg[j])) {                                                      // 401\n            exclude = true;                                                                                   // 402\n            break;                                                                                            // 403\n          }                                                                                                   // 404\n        }                                                                                                     // 405\n        if (!exclude)                                                                                         // 406\n          out.push(x[i]);                                                                                     // 407\n      }                                                                                                       // 408\n      target[field] = out;                                                                                    // 409\n    }                                                                                                         // 410\n  },                                                                                                          // 411\n  $rename: function (target, field, arg, keypath, doc) {                                                      // 412\n    if (keypath === arg)                                                                                      // 413\n      // no idea why mongo has this restriction..                                                             // 414\n      throw MinimongoError(\"$rename source must differ from target\");                                         // 415\n    if (target === null)                                                                                      // 416\n      throw MinimongoError(\"$rename source field invalid\");                                                   // 417\n    if (typeof arg !== \"string\")                                                                              // 418\n      throw MinimongoError(\"$rename target must be a string\");                                                // 419\n    if (target === undefined)                                                                                 // 420\n      return;                                                                                                 // 421\n    var v = target[field];                                                                                    // 422\n    delete target[field];                                                                                     // 423\n                                                                                                              // 424\n    var keyparts = arg.split('.');                                                                            // 425\n    var target2 = findModTarget(doc, keyparts, {forbidArray: true});                                          // 426\n    if (target2 === null)                                                                                     // 427\n      throw MinimongoError(\"$rename target field invalid\");                                                   // 428\n    var field2 = keyparts.pop();                                                                              // 429\n    target2[field2] = v;                                                                                      // 430\n  },                                                                                                          // 431\n  $bit: function (target, field, arg) {                                                                       // 432\n    // XXX mongo only supports $bit on integers, and we only support                                          // 433\n    // native javascript numbers (doubles) so far, so we can't support $bit                                   // 434\n    throw MinimongoError(\"$bit is not supported\");                                                            // 435\n  }                                                                                                           // 436\n};                                                                                                            // 437\n                                                                                                              // 438\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/diff.js                                                                                 //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// ordered: bool.                                                                                             // 1\n// old_results and new_results: collections of documents.                                                     // 2\n//    if ordered, they are arrays.                                                                            // 3\n//    if unordered, they are IdMaps                                                                           // 4\nLocalCollection._diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {           // 5\n  return DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);                   // 6\n};                                                                                                            // 7\n                                                                                                              // 8\nLocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {           // 9\n  return DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);                   // 10\n};                                                                                                            // 11\n                                                                                                              // 12\n                                                                                                              // 13\nLocalCollection._diffQueryOrderedChanges =                                                                    // 14\n  function (oldResults, newResults, observer, options) {                                                      // 15\n  return DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);                     // 16\n};                                                                                                            // 17\n                                                                                                              // 18\nLocalCollection._diffObjects = function (left, right, callbacks) {                                            // 19\n  return DiffSequence.diffObjects(left, right, callbacks);                                                    // 20\n};                                                                                                            // 21\n                                                                                                              // 22\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/id_map.js                                                                               //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nLocalCollection._IdMap = function () {                                                                        // 1\n  var self = this;                                                                                            // 2\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);                                                     // 3\n};                                                                                                            // 4\n                                                                                                              // 5\nMeteor._inherits(LocalCollection._IdMap, IdMap);                                                              // 6\n                                                                                                              // 7\n                                                                                                              // 8\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/observe.js                                                                              //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// XXX maybe move these into another ObserveHelpers package or something                                      // 1\n                                                                                                              // 2\n// _CachingChangeObserver is an object which receives observeChanges callbacks                                // 3\n// and keeps a cache of the current cursor state up to date in self.docs. Users                               // 4\n// of this class should read the docs field but not modify it. You should pass                                // 5\n// the \"applyChange\" field as the callbacks to the underlying observeChanges                                  // 6\n// call. Optionally, you can specify your own observeChanges callbacks which are                              // 7\n// invoked immediately before the docs field is updated; this object is made                                  // 8\n// available as `this` to those callbacks.                                                                    // 9\nLocalCollection._CachingChangeObserver = function (options) {                                                 // 10\n  var self = this;                                                                                            // 11\n  options = options || {};                                                                                    // 12\n                                                                                                              // 13\n  var orderedFromCallbacks = options.callbacks &&                                                             // 14\n        LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);                                // 15\n  if (_.has(options, 'ordered')) {                                                                            // 16\n    self.ordered = options.ordered;                                                                           // 17\n    if (options.callbacks && options.ordered !== orderedFromCallbacks)                                        // 18\n      throw Error(\"ordered option doesn't match callbacks\");                                                  // 19\n  } else if (options.callbacks) {                                                                             // 20\n    self.ordered = orderedFromCallbacks;                                                                      // 21\n  } else {                                                                                                    // 22\n    throw Error(\"must provide ordered or callbacks\");                                                         // 23\n  }                                                                                                           // 24\n  var callbacks = options.callbacks || {};                                                                    // 25\n                                                                                                              // 26\n  if (self.ordered) {                                                                                         // 27\n    self.docs = new OrderedDict(MongoID.idStringify);                                                         // 28\n    self.applyChange = {                                                                                      // 29\n      addedBefore: function (id, fields, before) {                                                            // 30\n        var doc = EJSON.clone(fields);                                                                        // 31\n        doc._id = id;                                                                                         // 32\n        callbacks.addedBefore && callbacks.addedBefore.call(                                                  // 33\n          self, id, fields, before);                                                                          // 34\n        // This line triggers if we provide added with movedBefore.                                           // 35\n        callbacks.added && callbacks.added.call(self, id, fields);                                            // 36\n        // XXX could `before` be a falsy ID?  Technically                                                     // 37\n        // idStringify seems to allow for them -- though                                                      // 38\n        // OrderedDict won't call stringify on a falsy arg.                                                   // 39\n        self.docs.putBefore(id, doc, before || null);                                                         // 40\n      },                                                                                                      // 41\n      movedBefore: function (id, before) {                                                                    // 42\n        var doc = self.docs.get(id);                                                                          // 43\n        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);                                // 44\n        self.docs.moveBefore(id, before || null);                                                             // 45\n      }                                                                                                       // 46\n    };                                                                                                        // 47\n  } else {                                                                                                    // 48\n    self.docs = new LocalCollection._IdMap;                                                                   // 49\n    self.applyChange = {                                                                                      // 50\n      added: function (id, fields) {                                                                          // 51\n        var doc = EJSON.clone(fields);                                                                        // 52\n        callbacks.added && callbacks.added.call(self, id, fields);                                            // 53\n        doc._id = id;                                                                                         // 54\n        self.docs.set(id,  doc);                                                                              // 55\n      }                                                                                                       // 56\n    };                                                                                                        // 57\n  }                                                                                                           // 58\n                                                                                                              // 59\n  // The methods in _IdMap and OrderedDict used by these callbacks are                                        // 60\n  // identical.                                                                                               // 61\n  self.applyChange.changed = function (id, fields) {                                                          // 62\n    var doc = self.docs.get(id);                                                                              // 63\n    if (!doc)                                                                                                 // 64\n      throw new Error(\"Unknown id for changed: \" + id);                                                       // 65\n    callbacks.changed && callbacks.changed.call(                                                              // 66\n      self, id, EJSON.clone(fields));                                                                         // 67\n    DiffSequence.applyChanges(doc, fields);                                                                   // 68\n  };                                                                                                          // 69\n  self.applyChange.removed = function (id) {                                                                  // 70\n    callbacks.removed && callbacks.removed.call(self, id);                                                    // 71\n    self.docs.remove(id);                                                                                     // 72\n  };                                                                                                          // 73\n};                                                                                                            // 74\n                                                                                                              // 75\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {                            // 76\n  var transform = cursor.getTransform() || function (doc) {return doc;};                                      // 77\n  var suppressed = !!observeCallbacks._suppress_initial;                                                      // 78\n                                                                                                              // 79\n  var observeChangesCallbacks;                                                                                // 80\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {                                        // 81\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the                                  // 82\n    // linear scans required to generate them.  This lets observers that don't                                // 83\n    // need absolute indices benefit from the other features of this API --                                   // 84\n    // relative order, transforms, and applyChanges -- without the speed hit.                                 // 85\n    var indices = !observeCallbacks._no_indices;                                                              // 86\n    observeChangesCallbacks = {                                                                               // 87\n      addedBefore: function (id, fields, before) {                                                            // 88\n        var self = this;                                                                                      // 89\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added))                              // 90\n          return;                                                                                             // 91\n        var doc = transform(_.extend(fields, {_id: id}));                                                     // 92\n        if (observeCallbacks.addedAt) {                                                                       // 93\n          var index = indices                                                                                 // 94\n                ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                               // 95\n          observeCallbacks.addedAt(doc, index, before);                                                       // 96\n        } else {                                                                                              // 97\n          observeCallbacks.added(doc);                                                                        // 98\n        }                                                                                                     // 99\n      },                                                                                                      // 100\n      changed: function (id, fields) {                                                                        // 101\n        var self = this;                                                                                      // 102\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed))                                        // 103\n          return;                                                                                             // 104\n        var doc = EJSON.clone(self.docs.get(id));                                                             // 105\n        if (!doc)                                                                                             // 106\n          throw new Error(\"Unknown id for changed: \" + id);                                                   // 107\n        var oldDoc = transform(EJSON.clone(doc));                                                             // 108\n        DiffSequence.applyChanges(doc, fields);                                                               // 109\n        doc = transform(doc);                                                                                 // 110\n        if (observeCallbacks.changedAt) {                                                                     // 111\n          var index = indices ? self.docs.indexOf(id) : -1;                                                   // 112\n          observeCallbacks.changedAt(doc, oldDoc, index);                                                     // 113\n        } else {                                                                                              // 114\n          observeCallbacks.changed(doc, oldDoc);                                                              // 115\n        }                                                                                                     // 116\n      },                                                                                                      // 117\n      movedBefore: function (id, before) {                                                                    // 118\n        var self = this;                                                                                      // 119\n        if (!observeCallbacks.movedTo)                                                                        // 120\n          return;                                                                                             // 121\n        var from = indices ? self.docs.indexOf(id) : -1;                                                      // 122\n                                                                                                              // 123\n        var to = indices                                                                                      // 124\n              ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                                 // 125\n        // When not moving backwards, adjust for the fact that removing the                                   // 126\n        // document slides everything back one slot.                                                          // 127\n        if (to > from)                                                                                        // 128\n          --to;                                                                                               // 129\n        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))),                                   // 130\n                                 from, to, before || null);                                                   // 131\n      },                                                                                                      // 132\n      removed: function (id) {                                                                                // 133\n        var self = this;                                                                                      // 134\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed))                                        // 135\n          return;                                                                                             // 136\n        // technically maybe there should be an EJSON.clone here, but it's about                              // 137\n        // to be removed from self.docs!                                                                      // 138\n        var doc = transform(self.docs.get(id));                                                               // 139\n        if (observeCallbacks.removedAt) {                                                                     // 140\n          var index = indices ? self.docs.indexOf(id) : -1;                                                   // 141\n          observeCallbacks.removedAt(doc, index);                                                             // 142\n        } else {                                                                                              // 143\n          observeCallbacks.removed(doc);                                                                      // 144\n        }                                                                                                     // 145\n      }                                                                                                       // 146\n    };                                                                                                        // 147\n  } else {                                                                                                    // 148\n    observeChangesCallbacks = {                                                                               // 149\n      added: function (id, fields) {                                                                          // 150\n        if (!suppressed && observeCallbacks.added) {                                                          // 151\n          var doc = _.extend(fields, {_id:  id});                                                             // 152\n          observeCallbacks.added(transform(doc));                                                             // 153\n        }                                                                                                     // 154\n      },                                                                                                      // 155\n      changed: function (id, fields) {                                                                        // 156\n        var self = this;                                                                                      // 157\n        if (observeCallbacks.changed) {                                                                       // 158\n          var oldDoc = self.docs.get(id);                                                                     // 159\n          var doc = EJSON.clone(oldDoc);                                                                      // 160\n          DiffSequence.applyChanges(doc, fields);                                                             // 161\n          observeCallbacks.changed(transform(doc),                                                            // 162\n                                   transform(EJSON.clone(oldDoc)));                                           // 163\n        }                                                                                                     // 164\n      },                                                                                                      // 165\n      removed: function (id) {                                                                                // 166\n        var self = this;                                                                                      // 167\n        if (observeCallbacks.removed) {                                                                       // 168\n          observeCallbacks.removed(transform(self.docs.get(id)));                                             // 169\n        }                                                                                                     // 170\n      }                                                                                                       // 171\n    };                                                                                                        // 172\n  }                                                                                                           // 173\n                                                                                                              // 174\n  var changeObserver = new LocalCollection._CachingChangeObserver(                                            // 175\n    {callbacks: observeChangesCallbacks});                                                                    // 176\n  var handle = cursor.observeChanges(changeObserver.applyChange);                                             // 177\n  suppressed = false;                                                                                         // 178\n                                                                                                              // 179\n  return handle;                                                                                              // 180\n};                                                                                                            // 181\n                                                                                                              // 182\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/objectid.js                                                                             //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Is this selector just shorthand for lookup by _id?                                                         // 1\nLocalCollection._selectorIsId = function (selector) {                                                         // 2\n  return (typeof selector === \"string\") ||                                                                    // 3\n    (typeof selector === \"number\") ||                                                                         // 4\n    selector instanceof MongoID.ObjectID;                                                                     // 5\n};                                                                                                            // 6\n                                                                                                              // 7\n// Is the selector just lookup by _id (shorthand or not)?                                                     // 8\nLocalCollection._selectorIsIdPerhapsAsObject = function (selector) {                                          // 9\n  return LocalCollection._selectorIsId(selector) ||                                                           // 10\n    (selector && typeof selector === \"object\" &&                                                              // 11\n     selector._id && LocalCollection._selectorIsId(selector._id) &&                                           // 12\n     _.size(selector) === 1);                                                                                 // 13\n};                                                                                                            // 14\n                                                                                                              // 15\n// If this is a selector which explicitly constrains the match by ID to a finite                              // 16\n// number of documents, returns a list of their IDs.  Otherwise returns                                       // 17\n// null. Note that the selector may have other restrictions so it may not even                                // 18\n// match those document!  We care about $in and $and since those are generated                                // 19\n// access-controlled update and remove.                                                                       // 20\nLocalCollection._idsMatchedBySelector = function (selector) {                                                 // 21\n  // Is the selector just an ID?                                                                              // 22\n  if (LocalCollection._selectorIsId(selector))                                                                // 23\n    return [selector];                                                                                        // 24\n  if (!selector)                                                                                              // 25\n    return null;                                                                                              // 26\n                                                                                                              // 27\n  // Do we have an _id clause?                                                                                // 28\n  if (_.has(selector, '_id')) {                                                                               // 29\n    // Is the _id clause just an ID?                                                                          // 30\n    if (LocalCollection._selectorIsId(selector._id))                                                          // 31\n      return [selector._id];                                                                                  // 32\n    // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?                                                       // 33\n    if (selector._id && selector._id.$in                                                                      // 34\n        && _.isArray(selector._id.$in)                                                                        // 35\n        && !_.isEmpty(selector._id.$in)                                                                       // 36\n        && _.all(selector._id.$in, LocalCollection._selectorIsId)) {                                          // 37\n      return selector._id.$in;                                                                                // 38\n    }                                                                                                         // 39\n    return null;                                                                                              // 40\n  }                                                                                                           // 41\n                                                                                                              // 42\n  // If this is a top-level $and, and any of the clauses constrain their                                      // 43\n  // documents, then the whole selector is constrained by any one clause's                                    // 44\n  // constraint. (Well, by their intersection, but that seems unlikely.)                                      // 45\n  if (selector.$and && _.isArray(selector.$and)) {                                                            // 46\n    for (var i = 0; i < selector.$and.length; ++i) {                                                          // 47\n      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);                                   // 48\n      if (subIds)                                                                                             // 49\n        return subIds;                                                                                        // 50\n    }                                                                                                         // 51\n  }                                                                                                           // 52\n                                                                                                              // 53\n  return null;                                                                                                // 54\n};                                                                                                            // 55\n                                                                                                              // 56\n                                                                                                              // 57\n                                                                                                              // 58\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/selector_projection.js                                                                  //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Knows how to combine a mongo selector and a fields projection to a new fields                              // 1\n// projection taking into account active fields from the passed selector.                                     // 2\n// @returns Object - projection object (same as fields option of mongo cursor)                                // 3\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {                                   // 4\n  var self = this;                                                                                            // 5\n  var selectorPaths = Minimongo._pathsElidingNumericKeys(self._getPaths());                                   // 6\n                                                                                                              // 7\n  // Special case for $where operator in the selector - projection should depend                              // 8\n  // on all fields of the document. getSelectorPaths returns a list of paths                                  // 9\n  // selector depends on. If one of the paths is '' (empty string) representing                               // 10\n  // the root or the whole document, complete projection should be returned.                                  // 11\n  if (_.contains(selectorPaths, ''))                                                                          // 12\n    return {};                                                                                                // 13\n                                                                                                              // 14\n  return combineImportantPathsIntoProjection(selectorPaths, projection);                                      // 15\n};                                                                                                            // 16\n                                                                                                              // 17\nMinimongo._pathsElidingNumericKeys = function (paths) {                                                       // 18\n  var self = this;                                                                                            // 19\n  return _.map(paths, function (path) {                                                                       // 20\n    return _.reject(path.split('.'), isNumericKey).join('.');                                                 // 21\n  });                                                                                                         // 22\n};                                                                                                            // 23\n                                                                                                              // 24\ncombineImportantPathsIntoProjection = function (paths, projection) {                                          // 25\n  var prjDetails = projectionDetails(projection);                                                             // 26\n  var tree = prjDetails.tree;                                                                                 // 27\n  var mergedProjection = {};                                                                                  // 28\n                                                                                                              // 29\n  // merge the paths to include                                                                               // 30\n  tree = pathsToTree(paths,                                                                                   // 31\n                     function (path) { return true; },                                                        // 32\n                     function (node, path, fullPath) { return true; },                                        // 33\n                     tree);                                                                                   // 34\n  mergedProjection = treeToPaths(tree);                                                                       // 35\n  if (prjDetails.including) {                                                                                 // 36\n    // both selector and projection are pointing on fields to include                                         // 37\n    // so we can just return the merged tree                                                                  // 38\n    return mergedProjection;                                                                                  // 39\n  } else {                                                                                                    // 40\n    // selector is pointing at fields to include                                                              // 41\n    // projection is pointing at fields to exclude                                                            // 42\n    // make sure we don't exclude important paths                                                             // 43\n    var mergedExclProjection = {};                                                                            // 44\n    _.each(mergedProjection, function (incl, path) {                                                          // 45\n      if (!incl)                                                                                              // 46\n        mergedExclProjection[path] = false;                                                                   // 47\n    });                                                                                                       // 48\n                                                                                                              // 49\n    return mergedExclProjection;                                                                              // 50\n  }                                                                                                           // 51\n};                                                                                                            // 52\n                                                                                                              // 53\n// Returns a set of key paths similar to                                                                      // 54\n// { 'foo.bar': 1, 'a.b.c': 1 }                                                                               // 55\nvar treeToPaths = function (tree, prefix) {                                                                   // 56\n  prefix = prefix || '';                                                                                      // 57\n  var result = {};                                                                                            // 58\n                                                                                                              // 59\n  _.each(tree, function (val, key) {                                                                          // 60\n    if (_.isObject(val))                                                                                      // 61\n      _.extend(result, treeToPaths(val, prefix + key + '.'));                                                 // 62\n    else                                                                                                      // 63\n      result[prefix + key] = val;                                                                             // 64\n  });                                                                                                         // 65\n                                                                                                              // 66\n  return result;                                                                                              // 67\n};                                                                                                            // 68\n                                                                                                              // 69\n                                                                                                              // 70\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/selector_modifier.js                                                                    //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Returns true if the modifier applied to some document may change the result                                // 1\n// of matching the document by selector                                                                       // 2\n// The modifier is always in a form of Object:                                                                // 3\n//  - $set                                                                                                    // 4\n//    - 'a.b.22.z': value                                                                                     // 5\n//    - 'foo.bar': 42                                                                                         // 6\n//  - $unset                                                                                                  // 7\n//    - 'abc.d': 1                                                                                            // 8\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {                                        // 9\n  var self = this;                                                                                            // 10\n  // safe check for $set/$unset being objects                                                                 // 11\n  modifier = _.extend({ $set: {}, $unset: {} }, modifier);                                                    // 12\n  var modifiedPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));                                  // 13\n  var meaningfulPaths = self._getPaths();                                                                     // 14\n                                                                                                              // 15\n  return _.any(modifiedPaths, function (path) {                                                               // 16\n    var mod = path.split('.');                                                                                // 17\n    return _.any(meaningfulPaths, function (meaningfulPath) {                                                 // 18\n      var sel = meaningfulPath.split('.');                                                                    // 19\n      var i = 0, j = 0;                                                                                       // 20\n                                                                                                              // 21\n      while (i < sel.length && j < mod.length) {                                                              // 22\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {                                                   // 23\n          // foo.4.bar selector affected by foo.4 modifier                                                    // 24\n          // foo.3.bar selector unaffected by foo.4 modifier                                                  // 25\n          if (sel[i] === mod[j])                                                                              // 26\n            i++, j++;                                                                                         // 27\n          else                                                                                                // 28\n            return false;                                                                                     // 29\n        } else if (isNumericKey(sel[i])) {                                                                    // 30\n          // foo.4.bar selector unaffected by foo.bar modifier                                                // 31\n          return false;                                                                                       // 32\n        } else if (isNumericKey(mod[j])) {                                                                    // 33\n          j++;                                                                                                // 34\n        } else if (sel[i] === mod[j])                                                                         // 35\n          i++, j++;                                                                                           // 36\n        else                                                                                                  // 37\n          return false;                                                                                       // 38\n      }                                                                                                       // 39\n                                                                                                              // 40\n      // One is a prefix of another, taking numeric fields into account                                       // 41\n      return true;                                                                                            // 42\n    });                                                                                                       // 43\n  });                                                                                                         // 44\n};                                                                                                            // 45\n                                                                                                              // 46\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made                               // 47\n// for this exact purpose.                                                                                    // 48\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {                                         // 49\n  var self = this;                                                                                            // 50\n  return self._selectorForAffectedByModifier.affectedByModifier(modifier);                                    // 51\n};                                                                                                            // 52\n                                                                                                              // 53\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`                               // 54\n//                           only. (assumed to come from oplog)                                               // 55\n// @returns - Boolean: if after applying the modifier, selector can start                                     // 56\n//                     accepting the modified value.                                                          // 57\n// NOTE: assumes that document affected by modifier didn't match this Matcher                                 // 58\n// before, so if modifier can't convince selector in a positive change it would                               // 59\n// stay 'false'.                                                                                              // 60\n// Currently doesn't support $-operators and numeric indices precisely.                                       // 61\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {                                   // 62\n  var self = this;                                                                                            // 63\n  if (!this.affectedByModifier(modifier))                                                                     // 64\n    return false;                                                                                             // 65\n                                                                                                              // 66\n  modifier = _.extend({$set:{}, $unset:{}}, modifier);                                                        // 67\n  var modifierPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));                                  // 68\n                                                                                                              // 69\n  if (!self.isSimple())                                                                                       // 70\n    return true;                                                                                              // 71\n                                                                                                              // 72\n  if (_.any(self._getPaths(), pathHasNumericKeys) ||                                                          // 73\n      _.any(modifierPaths, pathHasNumericKeys))                                                               // 74\n    return true;                                                                                              // 75\n                                                                                                              // 76\n  // check if there is a $set or $unset that indicates something is an                                        // 77\n  // object rather than a scalar in the actual object where we saw $-operator                                 // 78\n  // NOTE: it is correct since we allow only scalars in $-operators                                           // 79\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would                                   // 80\n  // definitely set the result to false as 'a.b' appears to be an object.                                     // 81\n  var expectedScalarIsObject = _.any(self._selector, function (sel, path) {                                   // 82\n    if (! isOperatorObject(sel))                                                                              // 83\n      return false;                                                                                           // 84\n    return _.any(modifierPaths, function (modifierPath) {                                                     // 85\n      return startsWith(modifierPath, path + '.');                                                            // 86\n    });                                                                                                       // 87\n  });                                                                                                         // 88\n                                                                                                              // 89\n  if (expectedScalarIsObject)                                                                                 // 90\n    return false;                                                                                             // 91\n                                                                                                              // 92\n  // See if we can apply the modifier on the ideally matching object. If it                                   // 93\n  // still matches the selector, then the modifier could have turned the real                                 // 94\n  // object in the database into something matching.                                                          // 95\n  var matchingDocument = EJSON.clone(self.matchingDocument());                                                // 96\n                                                                                                              // 97\n  // The selector is too complex, anything can happen.                                                        // 98\n  if (matchingDocument === null)                                                                              // 99\n    return true;                                                                                              // 100\n                                                                                                              // 101\n  try {                                                                                                       // 102\n    LocalCollection._modify(matchingDocument, modifier);                                                      // 103\n  } catch (e) {                                                                                               // 104\n    // Couldn't set a property on a field which is a scalar or null in the                                    // 105\n    // selector.                                                                                              // 106\n    // Example:                                                                                               // 107\n    // real document: { 'a.b': 3 }                                                                            // 108\n    // selector: { 'a': 12 }                                                                                  // 109\n    // converted selector (ideal document): { 'a': 12 }                                                       // 110\n    // modifier: { $set: { 'a.b': 4 } }                                                                       // 111\n    // We don't know what real document was like but from the error raised by                                 // 112\n    // $set on a scalar field we can reason that the structure of real document                               // 113\n    // is completely different.                                                                               // 114\n    if (e.name === \"MinimongoError\" && e.setPropertyError)                                                    // 115\n      return false;                                                                                           // 116\n    throw e;                                                                                                  // 117\n  }                                                                                                           // 118\n                                                                                                              // 119\n  return self.documentMatches(matchingDocument).result;                                                       // 120\n};                                                                                                            // 121\n                                                                                                              // 122\n// Returns an object that would match the selector if possible or null if the                                 // 123\n// selector is too complex for us to analyze                                                                  // 124\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }                                            // 125\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }                                         // 126\nMinimongo.Matcher.prototype.matchingDocument = function () {                                                  // 127\n  var self = this;                                                                                            // 128\n                                                                                                              // 129\n  // check if it was computed before                                                                          // 130\n  if (self._matchingDocument !== undefined)                                                                   // 131\n    return self._matchingDocument;                                                                            // 132\n                                                                                                              // 133\n  // If the analysis of this selector is too hard for our implementation                                      // 134\n  // fallback to \"YES\"                                                                                        // 135\n  var fallback = false;                                                                                       // 136\n  self._matchingDocument = pathsToTree(self._getPaths(),                                                      // 137\n    function (path) {                                                                                         // 138\n      var valueSelector = self._selector[path];                                                               // 139\n      if (isOperatorObject(valueSelector)) {                                                                  // 140\n        // if there is a strict equality, there is a good                                                     // 141\n        // chance we can use one of those as \"matching\"                                                       // 142\n        // dummy value                                                                                        // 143\n        if (valueSelector.$in) {                                                                              // 144\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });                                // 145\n                                                                                                              // 146\n          // Return anything from $in that matches the whole selector for this                                // 147\n          // path. If nothing matches, returns `undefined` as nothing can make                                // 148\n          // this selector into `true`.                                                                       // 149\n          return _.find(valueSelector.$in, function (x) {                                                     // 150\n            return matcher.documentMatches({ placeholder: x }).result;                                        // 151\n          });                                                                                                 // 152\n        } else if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {                         // 153\n          var lowerBound = -Infinity, upperBound = Infinity;                                                  // 154\n          _.each(['$lte', '$lt'], function (op) {                                                             // 155\n            if (_.has(valueSelector, op) && valueSelector[op] < upperBound)                                   // 156\n              upperBound = valueSelector[op];                                                                 // 157\n          });                                                                                                 // 158\n          _.each(['$gte', '$gt'], function (op) {                                                             // 159\n            if (_.has(valueSelector, op) && valueSelector[op] > lowerBound)                                   // 160\n              lowerBound = valueSelector[op];                                                                 // 161\n          });                                                                                                 // 162\n                                                                                                              // 163\n          var middle = (lowerBound + upperBound) / 2;                                                         // 164\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });                                // 165\n          if (!matcher.documentMatches({ placeholder: middle }).result &&                                     // 166\n              (middle === lowerBound || middle === upperBound))                                               // 167\n            fallback = true;                                                                                  // 168\n                                                                                                              // 169\n          return middle;                                                                                      // 170\n        } else if (onlyContainsKeys(valueSelector, ['$nin',' $ne'])) {                                        // 171\n          // Since self._isSimple makes sure $nin and $ne are not combined with                               // 172\n          // objects or arrays, we can confidently return an empty object as it                               // 173\n          // never matches any scalar.                                                                        // 174\n          return {};                                                                                          // 175\n        } else {                                                                                              // 176\n          fallback = true;                                                                                    // 177\n        }                                                                                                     // 178\n      }                                                                                                       // 179\n      return self._selector[path];                                                                            // 180\n    },                                                                                                        // 181\n    _.identity /*conflict resolution is no resolution*/);                                                     // 182\n                                                                                                              // 183\n  if (fallback)                                                                                               // 184\n    self._matchingDocument = null;                                                                            // 185\n                                                                                                              // 186\n  return self._matchingDocument;                                                                              // 187\n};                                                                                                            // 188\n                                                                                                              // 189\nvar getPaths = function (sel) {                                                                               // 190\n  return _.keys(new Minimongo.Matcher(sel)._paths);                                                           // 191\n  return _.chain(sel).map(function (v, k) {                                                                   // 192\n    // we don't know how to handle $where because it can be anything                                          // 193\n    if (k === \"$where\")                                                                                       // 194\n      return ''; // matches everything                                                                        // 195\n    // we branch from $or/$and/$nor operator                                                                  // 196\n    if (_.contains(['$or', '$and', '$nor'], k))                                                               // 197\n      return _.map(v, getPaths);                                                                              // 198\n    // the value is a literal or some comparison operator                                                     // 199\n    return k;                                                                                                 // 200\n  }).flatten().uniq().value();                                                                                // 201\n};                                                                                                            // 202\n                                                                                                              // 203\n// A helper to ensure object has only certain keys                                                            // 204\nvar onlyContainsKeys = function (obj, keys) {                                                                 // 205\n  return _.all(obj, function (v, k) {                                                                         // 206\n    return _.contains(keys, k);                                                                               // 207\n  });                                                                                                         // 208\n};                                                                                                            // 209\n                                                                                                              // 210\nvar pathHasNumericKeys = function (path) {                                                                    // 211\n  return _.any(path.split('.'), isNumericKey);                                                                // 212\n}                                                                                                             // 213\n                                                                                                              // 214\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                    // 215\nvar startsWith = function(str, starts) {                                                                      // 216\n  return str.length >= starts.length &&                                                                       // 217\n    str.substring(0, starts.length) === starts;                                                               // 218\n};                                                                                                            // 219\n                                                                                                              // 220\n                                                                                                              // 221\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/minimongo/sorter_projection.js                                                                    //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nMinimongo.Sorter.prototype.combineIntoProjection = function (projection) {                                    // 1\n  var self = this;                                                                                            // 2\n  var specPaths = Minimongo._pathsElidingNumericKeys(self._getPaths());                                       // 3\n  return combineImportantPathsIntoProjection(specPaths, projection);                                          // 4\n};                                                                                                            // 5\n                                                                                                              // 6\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]