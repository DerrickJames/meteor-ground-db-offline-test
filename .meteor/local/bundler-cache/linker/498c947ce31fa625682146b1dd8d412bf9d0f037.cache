[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar IdMap = Package['id-map'].IdMap;\n\n/* Package-scope variables */\nvar MaxHeap, MinHeap, MinMaxHeap;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                           //\n// packages/binary-heap/packages/binary-heap.js                                              //\n//                                                                                           //\n///////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                             //\n(function(){                                                                                 // 1\n                                                                                             // 2\n////////////////////////////////////////////////////////////////////////////////////////     // 3\n//                                                                                    //     // 4\n// packages/binary-heap/max-heap.js                                                   //     // 5\n//                                                                                    //     // 6\n////////////////////////////////////////////////////////////////////////////////////////     // 7\n                                                                                      //     // 8\n// Constructor of Heap                                                                // 1   // 9\n// - comparator - Function - given two items returns a number                         // 2   // 10\n// - options:                                                                         // 3   // 11\n//   - initData - Array - Optional - the initial data in a format:                    // 4   // 12\n//        Object:                                                                     // 5   // 13\n//          - id - String - unique id of the item                                     // 6   // 14\n//          - value - Any - the data value                                            // 7   // 15\n//      each value is retained                                                        // 8   // 16\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index         // 9   // 17\n//       mappings internally. Standard IdMap is used by default.                      // 10  // 18\nMaxHeap = function (comparator, options) {                                            // 11  // 19\n  if (! _.isFunction(comparator))                                                     // 12  // 20\n    throw new Error('Passed comparator is invalid, should be a comparison function');        // 21\n  var self = this;                                                                    // 14  // 22\n                                                                                      // 15  // 23\n  // a C-style comparator that is given two values and returns a number,              // 16  // 24\n  // negative if the first value is less than the second, positive if the second      // 17  // 25\n  // value is greater than the first and zero if they are equal.                      // 18  // 26\n  self._comparator = comparator;                                                      // 19  // 27\n                                                                                      // 20  // 28\n  options = _.defaults(options || {}, { IdMap: IdMap });                              // 21  // 29\n                                                                                      // 22  // 30\n  // _heapIdx maps an id to an index in the Heap array the corresponding value        // 23  // 31\n  // is located on.                                                                   // 24  // 32\n  self._heapIdx = new options.IdMap;                                                  // 25  // 33\n                                                                                      // 26  // 34\n  // The Heap data-structure implemented as a 0-based contiguous array where          // 27  // 35\n  // every item on index idx is a node in a complete binary tree. Every node can      // 28  // 36\n  // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every       // 29  // 37\n  // node has a parent on index (idx-1)/2;                                            // 30  // 38\n  self._heap = [];                                                                    // 31  // 39\n                                                                                      // 32  // 40\n  // If the initial array is passed, we can build the heap in linear time             // 33  // 41\n  // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if         // 34  // 42\n  // we push elements one by one.                                                     // 35  // 43\n  if (_.isArray(options.initData))                                                    // 36  // 44\n    self._initFromData(options.initData);                                             // 37  // 45\n};                                                                                    // 38  // 46\n                                                                                      // 39  // 47\n_.extend(MaxHeap.prototype, {                                                         // 40  // 48\n  // Builds a new heap in-place in linear time based on passed data                   // 41  // 49\n  _initFromData: function (data) {                                                    // 42  // 50\n    var self = this;                                                                  // 43  // 51\n                                                                                      // 44  // 52\n    self._heap = _.map(data, function (o) {                                           // 45  // 53\n      return { id: o.id, value: o.value };                                            // 46  // 54\n    });                                                                               // 47  // 55\n                                                                                      // 48  // 56\n    _.each(data, function (o, i) {                                                    // 49  // 57\n      self._heapIdx.set(o.id, i);                                                     // 50  // 58\n    });                                                                               // 51  // 59\n                                                                                      // 52  // 60\n    if (! data.length)                                                                // 53  // 61\n      return;                                                                         // 54  // 62\n                                                                                      // 55  // 63\n    // start from the first non-leaf - the parent of the last leaf                    // 56  // 64\n    for (var i = parentIdx(data.length - 1); i >= 0; i--)                             // 57  // 65\n      self._downHeap(i);                                                              // 58  // 66\n  },                                                                                  // 59  // 67\n                                                                                      // 60  // 68\n  _downHeap: function (idx) {                                                         // 61  // 69\n    var self = this;                                                                  // 62  // 70\n                                                                                      // 63  // 71\n    while (leftChildIdx(idx) < self.size()) {                                         // 64  // 72\n      var left = leftChildIdx(idx);                                                   // 65  // 73\n      var right = rightChildIdx(idx);                                                 // 66  // 74\n      var largest = idx;                                                              // 67  // 75\n                                                                                      // 68  // 76\n      if (left < self.size()) {                                                       // 69  // 77\n        largest = self._maxIndex(largest, left);                                      // 70  // 78\n      }                                                                               // 71  // 79\n      if (right < self.size()) {                                                      // 72  // 80\n        largest = self._maxIndex(largest, right);                                     // 73  // 81\n      }                                                                               // 74  // 82\n                                                                                      // 75  // 83\n      if (largest === idx)                                                            // 76  // 84\n        break;                                                                        // 77  // 85\n                                                                                      // 78  // 86\n      self._swap(largest, idx);                                                       // 79  // 87\n      idx = largest;                                                                  // 80  // 88\n    }                                                                                 // 81  // 89\n  },                                                                                  // 82  // 90\n                                                                                      // 83  // 91\n  _upHeap: function (idx) {                                                           // 84  // 92\n    var self = this;                                                                  // 85  // 93\n                                                                                      // 86  // 94\n    while (idx > 0) {                                                                 // 87  // 95\n      var parent = parentIdx(idx);                                                    // 88  // 96\n      if (self._maxIndex(parent, idx) === idx) {                                      // 89  // 97\n        self._swap(parent, idx)                                                       // 90  // 98\n        idx = parent;                                                                 // 91  // 99\n      } else {                                                                        // 92  // 100\n        break;                                                                        // 93  // 101\n      }                                                                               // 94  // 102\n    }                                                                                 // 95  // 103\n  },                                                                                  // 96  // 104\n                                                                                      // 97  // 105\n  _maxIndex: function (idxA, idxB) {                                                  // 98  // 106\n    var self = this;                                                                  // 99  // 107\n    var valueA = self._get(idxA);                                                     // 100\n    var valueB = self._get(idxB);                                                     // 101\n    return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;                       // 102\n  },                                                                                  // 103\n                                                                                      // 104\n  // Internal: gets raw data object placed on idxth place in heap                     // 105\n  _get: function (idx) {                                                              // 106\n    var self = this;                                                                  // 107\n    return self._heap[idx].value;                                                     // 108\n  },                                                                                  // 109\n                                                                                      // 110\n  _swap: function (idxA, idxB) {                                                      // 111\n    var self = this;                                                                  // 112\n    var recA = self._heap[idxA];                                                      // 113\n    var recB = self._heap[idxB];                                                      // 114\n                                                                                      // 115\n    self._heapIdx.set(recA.id, idxB);                                                 // 116\n    self._heapIdx.set(recB.id, idxA);                                                 // 117\n                                                                                      // 118\n    self._heap[idxA] = recB;                                                          // 119\n    self._heap[idxB] = recA;                                                          // 120\n  },                                                                                  // 121\n                                                                                      // 122\n  get: function (id) {                                                                // 123\n    var self = this;                                                                  // 124\n    if (! self.has(id))                                                               // 125\n      return null;                                                                    // 126\n    return self._get(self._heapIdx.get(id));                                          // 127\n  },                                                                                  // 128\n  set: function (id, value) {                                                         // 129\n    var self = this;                                                                  // 130\n                                                                                      // 131\n    if (self.has(id)) {                                                               // 132\n      if (self.get(id) === value)                                                     // 133\n        return;                                                                       // 134\n                                                                                      // 135\n      var idx = self._heapIdx.get(id);                                                // 136\n      self._heap[idx].value = value;                                                  // 137\n                                                                                      // 138\n      // Fix the new value's position                                                 // 139\n      // Either bubble new value up if it is greater than its parent                  // 140\n      self._upHeap(idx);                                                              // 141\n      // or bubble it down if it is smaller than one of its children                  // 142\n      self._downHeap(idx);                                                            // 143\n    } else {                                                                          // 144\n      self._heapIdx.set(id, self._heap.length);                                       // 145\n      self._heap.push({ id: id, value: value });                                      // 146\n      self._upHeap(self._heap.length - 1);                                            // 147\n    }                                                                                 // 148\n  },                                                                                  // 149\n  remove: function (id) {                                                             // 150\n    var self = this;                                                                  // 151\n                                                                                      // 152\n    if (self.has(id)) {                                                               // 153\n      var last = self._heap.length - 1;                                               // 154\n      var idx = self._heapIdx.get(id);                                                // 155\n                                                                                      // 156\n      if (idx !== last) {                                                             // 157\n        self._swap(idx, last);                                                        // 158\n        self._heap.pop();                                                             // 159\n        self._heapIdx.remove(id);                                                     // 160\n                                                                                      // 161\n        // Fix the swapped value's position                                           // 162\n        self._upHeap(idx);                                                            // 163\n        self._downHeap(idx);                                                          // 164\n      } else {                                                                        // 165\n        self._heap.pop();                                                             // 166\n        self._heapIdx.remove(id);                                                     // 167\n      }                                                                               // 168\n    }                                                                                 // 169\n  },                                                                                  // 170\n  has: function (id) {                                                                // 171\n    var self = this;                                                                  // 172\n    return self._heapIdx.has(id);                                                     // 173\n  },                                                                                  // 174\n  empty: function () {                                                                // 175\n    var self = this;                                                                  // 176\n    return !self.size();                                                              // 177\n  },                                                                                  // 178\n  clear: function () {                                                                // 179\n    var self = this;                                                                  // 180\n    self._heap = [];                                                                  // 181\n    self._heapIdx.clear();                                                            // 182\n  },                                                                                  // 183\n  // iterate over values in no particular order                                       // 184\n  forEach: function (iterator) {                                                      // 185\n    var self = this;                                                                  // 186\n    _.each(self._heap, function (obj) {                                               // 187\n      return iterator(obj.value, obj.id);                                             // 188\n    });                                                                               // 189\n  },                                                                                  // 190\n  size: function () {                                                                 // 191\n    var self = this;                                                                  // 192\n    return self._heap.length;                                                         // 193\n  },                                                                                  // 194\n  setDefault: function (id, def) {                                                    // 195\n    var self = this;                                                                  // 196\n    if (self.has(id))                                                                 // 197\n      return self.get(id);                                                            // 198\n    self.set(id, def);                                                                // 199\n    return def;                                                                       // 200\n  },                                                                                  // 201\n  clone: function () {                                                                // 202\n    var self = this;                                                                  // 203\n    var clone = new MaxHeap(self._comparator, self._heap);                            // 204\n    return clone;                                                                     // 205\n  },                                                                                  // 206\n                                                                                      // 207\n  maxElementId: function () {                                                         // 208\n    var self = this;                                                                  // 209\n    return self.size() ? self._heap[0].id : null;                                     // 210\n  },                                                                                  // 211\n                                                                                      // 212\n  _selfCheck: function () {                                                           // 213\n    var self = this;                                                                  // 214\n    for (var i = 1; i < self._heap.length; i++)                                       // 215\n      if (self._maxIndex(parentIdx(i), i) !== parentIdx(i))                           // 216\n          throw new Error(\"An item with id \" + self._heap[i].id +                     // 217\n                          \" has a parent younger than it: \" +                         // 218\n                          self._heap[parentIdx(i)].id);                               // 219\n  }                                                                                   // 220\n});                                                                                   // 221\n                                                                                      // 222\nfunction leftChildIdx (i) { return i * 2 + 1; }                                       // 223\nfunction rightChildIdx (i) { return i * 2 + 2; }                                      // 224\nfunction parentIdx (i) { return (i - 1) >> 1; }                                       // 225\n                                                                                      // 226\n                                                                                      // 227\n////////////////////////////////////////////////////////////////////////////////////////     // 236\n                                                                                             // 237\n}).call(this);                                                                               // 238\n                                                                                             // 239\n                                                                                             // 240\n                                                                                             // 241\n                                                                                             // 242\n                                                                                             // 243\n                                                                                             // 244\n(function(){                                                                                 // 245\n                                                                                             // 246\n////////////////////////////////////////////////////////////////////////////////////////     // 247\n//                                                                                    //     // 248\n// packages/binary-heap/min-heap.js                                                   //     // 249\n//                                                                                    //     // 250\n////////////////////////////////////////////////////////////////////////////////////////     // 251\n                                                                                      //     // 252\nMinHeap = function (comparator, options) {                                            // 1   // 253\n  var self = this;                                                                    // 2   // 254\n  MaxHeap.call(self, function (a, b) {                                                // 3   // 255\n    return -comparator(a, b);                                                         // 4   // 256\n  }, options);                                                                        // 5   // 257\n};                                                                                    // 6   // 258\n                                                                                      // 7   // 259\nMeteor._inherits(MinHeap, MaxHeap);                                                   // 8   // 260\n                                                                                      // 9   // 261\n_.extend(MinHeap.prototype, {                                                         // 10  // 262\n  maxElementId: function () {                                                         // 11  // 263\n    throw new Error(\"Cannot call maxElementId on MinHeap\");                           // 12  // 264\n  },                                                                                  // 13  // 265\n  minElementId: function () {                                                         // 14  // 266\n    var self = this;                                                                  // 15  // 267\n    return MaxHeap.prototype.maxElementId.call(self);                                 // 16  // 268\n  }                                                                                   // 17  // 269\n});                                                                                   // 18  // 270\n                                                                                      // 19  // 271\n                                                                                      // 20  // 272\n////////////////////////////////////////////////////////////////////////////////////////     // 273\n                                                                                             // 274\n}).call(this);                                                                               // 275\n                                                                                             // 276\n                                                                                             // 277\n                                                                                             // 278\n                                                                                             // 279\n                                                                                             // 280\n                                                                                             // 281\n(function(){                                                                                 // 282\n                                                                                             // 283\n////////////////////////////////////////////////////////////////////////////////////////     // 284\n//                                                                                    //     // 285\n// packages/binary-heap/min-max-heap.js                                               //     // 286\n//                                                                                    //     // 287\n////////////////////////////////////////////////////////////////////////////////////////     // 288\n                                                                                      //     // 289\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap                 // 1   // 290\n// with a Min-Heap as an encapsulated property.                                       // 2   // 291\n//                                                                                    // 3   // 292\n// Most of the operations are just proxy methods to call the same method on both      // 4   // 293\n// heaps.                                                                             // 5   // 294\n//                                                                                    // 6   // 295\n// This implementation takes 2*N memory but is fairly simple to write and             // 7   // 296\n// understand. And the constant factor of a simple Heap is usually smaller            // 8   // 297\n// compared to other two-way priority queues like Min/Max Heaps                       // 9   // 298\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)      // 10  // 299\n// and Interval Heaps                                                                 // 11  // 300\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)                       // 12  // 301\nMinMaxHeap = function (comparator, options) {                                         // 13  // 302\n  var self = this;                                                                    // 14  // 303\n                                                                                      // 15  // 304\n  MaxHeap.call(self, comparator, options);                                            // 16  // 305\n  self._minHeap = new MinHeap(comparator, options);                                   // 17  // 306\n};                                                                                    // 18  // 307\n                                                                                      // 19  // 308\nMeteor._inherits(MinMaxHeap, MaxHeap);                                                // 20  // 309\n                                                                                      // 21  // 310\n_.extend(MinMaxHeap.prototype, {                                                      // 22  // 311\n  set: function (id, value) {                                                         // 23  // 312\n    var self = this;                                                                  // 24  // 313\n    MaxHeap.prototype.set.apply(self, arguments);                                     // 25  // 314\n    self._minHeap.set(id, value);                                                     // 26  // 315\n  },                                                                                  // 27  // 316\n  remove: function (id) {                                                             // 28  // 317\n    var self = this;                                                                  // 29  // 318\n    MaxHeap.prototype.remove.apply(self, arguments);                                  // 30  // 319\n    self._minHeap.remove(id);                                                         // 31  // 320\n  },                                                                                  // 32  // 321\n  clear: function () {                                                                // 33  // 322\n    var self = this;                                                                  // 34  // 323\n    MaxHeap.prototype.clear.apply(self, arguments);                                   // 35  // 324\n    self._minHeap.clear();                                                            // 36  // 325\n  },                                                                                  // 37  // 326\n  setDefault: function (id, def) {                                                    // 38  // 327\n    var self = this;                                                                  // 39  // 328\n    MaxHeap.prototype.setDefault.apply(self, arguments);                              // 40  // 329\n    return self._minHeap.setDefault(id, def);                                         // 41  // 330\n  },                                                                                  // 42  // 331\n  clone: function () {                                                                // 43  // 332\n    var self = this;                                                                  // 44  // 333\n    var clone = new MinMaxHeap(self._comparator, self._heap);                         // 45  // 334\n    return clone;                                                                     // 46  // 335\n  },                                                                                  // 47  // 336\n  minElementId: function () {                                                         // 48  // 337\n    var self = this;                                                                  // 49  // 338\n    return self._minHeap.minElementId();                                              // 50  // 339\n  }                                                                                   // 51  // 340\n});                                                                                   // 52  // 341\n                                                                                      // 53  // 342\n                                                                                      // 54  // 343\n////////////////////////////////////////////////////////////////////////////////////////     // 344\n                                                                                             // 345\n}).call(this);                                                                               // 346\n                                                                                             // 347\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['binary-heap'] = {\n  MaxHeap: MaxHeap,\n  MinHeap: MinHeap,\n  MinMaxHeap: MinMaxHeap\n};\n\n})();\n","servePath":"/packages/binary-heap.js","sourceMap":{"version":3,"sources":["/packages/binary-heap/packages/binary-heap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mG","file":"/packages/binary-heap.js","sourcesContent":["(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/max-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// Constructor of Heap                                                                // 1\n// - comparator - Function - given two items returns a number                         // 2\n// - options:                                                                         // 3\n//   - initData - Array - Optional - the initial data in a format:                    // 4\n//        Object:                                                                     // 5\n//          - id - String - unique id of the item                                     // 6\n//          - value - Any - the data value                                            // 7\n//      each value is retained                                                        // 8\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index         // 9\n//       mappings internally. Standard IdMap is used by default.                      // 10\nMaxHeap = function (comparator, options) {                                            // 11\n  if (! _.isFunction(comparator))                                                     // 12\n    throw new Error('Passed comparator is invalid, should be a comparison function');\n  var self = this;                                                                    // 14\n                                                                                      // 15\n  // a C-style comparator that is given two values and returns a number,              // 16\n  // negative if the first value is less than the second, positive if the second      // 17\n  // value is greater than the first and zero if they are equal.                      // 18\n  self._comparator = comparator;                                                      // 19\n                                                                                      // 20\n  options = _.defaults(options || {}, { IdMap: IdMap });                              // 21\n                                                                                      // 22\n  // _heapIdx maps an id to an index in the Heap array the corresponding value        // 23\n  // is located on.                                                                   // 24\n  self._heapIdx = new options.IdMap;                                                  // 25\n                                                                                      // 26\n  // The Heap data-structure implemented as a 0-based contiguous array where          // 27\n  // every item on index idx is a node in a complete binary tree. Every node can      // 28\n  // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every       // 29\n  // node has a parent on index (idx-1)/2;                                            // 30\n  self._heap = [];                                                                    // 31\n                                                                                      // 32\n  // If the initial array is passed, we can build the heap in linear time             // 33\n  // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if         // 34\n  // we push elements one by one.                                                     // 35\n  if (_.isArray(options.initData))                                                    // 36\n    self._initFromData(options.initData);                                             // 37\n};                                                                                    // 38\n                                                                                      // 39\n_.extend(MaxHeap.prototype, {                                                         // 40\n  // Builds a new heap in-place in linear time based on passed data                   // 41\n  _initFromData: function (data) {                                                    // 42\n    var self = this;                                                                  // 43\n                                                                                      // 44\n    self._heap = _.map(data, function (o) {                                           // 45\n      return { id: o.id, value: o.value };                                            // 46\n    });                                                                               // 47\n                                                                                      // 48\n    _.each(data, function (o, i) {                                                    // 49\n      self._heapIdx.set(o.id, i);                                                     // 50\n    });                                                                               // 51\n                                                                                      // 52\n    if (! data.length)                                                                // 53\n      return;                                                                         // 54\n                                                                                      // 55\n    // start from the first non-leaf - the parent of the last leaf                    // 56\n    for (var i = parentIdx(data.length - 1); i >= 0; i--)                             // 57\n      self._downHeap(i);                                                              // 58\n  },                                                                                  // 59\n                                                                                      // 60\n  _downHeap: function (idx) {                                                         // 61\n    var self = this;                                                                  // 62\n                                                                                      // 63\n    while (leftChildIdx(idx) < self.size()) {                                         // 64\n      var left = leftChildIdx(idx);                                                   // 65\n      var right = rightChildIdx(idx);                                                 // 66\n      var largest = idx;                                                              // 67\n                                                                                      // 68\n      if (left < self.size()) {                                                       // 69\n        largest = self._maxIndex(largest, left);                                      // 70\n      }                                                                               // 71\n      if (right < self.size()) {                                                      // 72\n        largest = self._maxIndex(largest, right);                                     // 73\n      }                                                                               // 74\n                                                                                      // 75\n      if (largest === idx)                                                            // 76\n        break;                                                                        // 77\n                                                                                      // 78\n      self._swap(largest, idx);                                                       // 79\n      idx = largest;                                                                  // 80\n    }                                                                                 // 81\n  },                                                                                  // 82\n                                                                                      // 83\n  _upHeap: function (idx) {                                                           // 84\n    var self = this;                                                                  // 85\n                                                                                      // 86\n    while (idx > 0) {                                                                 // 87\n      var parent = parentIdx(idx);                                                    // 88\n      if (self._maxIndex(parent, idx) === idx) {                                      // 89\n        self._swap(parent, idx)                                                       // 90\n        idx = parent;                                                                 // 91\n      } else {                                                                        // 92\n        break;                                                                        // 93\n      }                                                                               // 94\n    }                                                                                 // 95\n  },                                                                                  // 96\n                                                                                      // 97\n  _maxIndex: function (idxA, idxB) {                                                  // 98\n    var self = this;                                                                  // 99\n    var valueA = self._get(idxA);                                                     // 100\n    var valueB = self._get(idxB);                                                     // 101\n    return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;                       // 102\n  },                                                                                  // 103\n                                                                                      // 104\n  // Internal: gets raw data object placed on idxth place in heap                     // 105\n  _get: function (idx) {                                                              // 106\n    var self = this;                                                                  // 107\n    return self._heap[idx].value;                                                     // 108\n  },                                                                                  // 109\n                                                                                      // 110\n  _swap: function (idxA, idxB) {                                                      // 111\n    var self = this;                                                                  // 112\n    var recA = self._heap[idxA];                                                      // 113\n    var recB = self._heap[idxB];                                                      // 114\n                                                                                      // 115\n    self._heapIdx.set(recA.id, idxB);                                                 // 116\n    self._heapIdx.set(recB.id, idxA);                                                 // 117\n                                                                                      // 118\n    self._heap[idxA] = recB;                                                          // 119\n    self._heap[idxB] = recA;                                                          // 120\n  },                                                                                  // 121\n                                                                                      // 122\n  get: function (id) {                                                                // 123\n    var self = this;                                                                  // 124\n    if (! self.has(id))                                                               // 125\n      return null;                                                                    // 126\n    return self._get(self._heapIdx.get(id));                                          // 127\n  },                                                                                  // 128\n  set: function (id, value) {                                                         // 129\n    var self = this;                                                                  // 130\n                                                                                      // 131\n    if (self.has(id)) {                                                               // 132\n      if (self.get(id) === value)                                                     // 133\n        return;                                                                       // 134\n                                                                                      // 135\n      var idx = self._heapIdx.get(id);                                                // 136\n      self._heap[idx].value = value;                                                  // 137\n                                                                                      // 138\n      // Fix the new value's position                                                 // 139\n      // Either bubble new value up if it is greater than its parent                  // 140\n      self._upHeap(idx);                                                              // 141\n      // or bubble it down if it is smaller than one of its children                  // 142\n      self._downHeap(idx);                                                            // 143\n    } else {                                                                          // 144\n      self._heapIdx.set(id, self._heap.length);                                       // 145\n      self._heap.push({ id: id, value: value });                                      // 146\n      self._upHeap(self._heap.length - 1);                                            // 147\n    }                                                                                 // 148\n  },                                                                                  // 149\n  remove: function (id) {                                                             // 150\n    var self = this;                                                                  // 151\n                                                                                      // 152\n    if (self.has(id)) {                                                               // 153\n      var last = self._heap.length - 1;                                               // 154\n      var idx = self._heapIdx.get(id);                                                // 155\n                                                                                      // 156\n      if (idx !== last) {                                                             // 157\n        self._swap(idx, last);                                                        // 158\n        self._heap.pop();                                                             // 159\n        self._heapIdx.remove(id);                                                     // 160\n                                                                                      // 161\n        // Fix the swapped value's position                                           // 162\n        self._upHeap(idx);                                                            // 163\n        self._downHeap(idx);                                                          // 164\n      } else {                                                                        // 165\n        self._heap.pop();                                                             // 166\n        self._heapIdx.remove(id);                                                     // 167\n      }                                                                               // 168\n    }                                                                                 // 169\n  },                                                                                  // 170\n  has: function (id) {                                                                // 171\n    var self = this;                                                                  // 172\n    return self._heapIdx.has(id);                                                     // 173\n  },                                                                                  // 174\n  empty: function () {                                                                // 175\n    var self = this;                                                                  // 176\n    return !self.size();                                                              // 177\n  },                                                                                  // 178\n  clear: function () {                                                                // 179\n    var self = this;                                                                  // 180\n    self._heap = [];                                                                  // 181\n    self._heapIdx.clear();                                                            // 182\n  },                                                                                  // 183\n  // iterate over values in no particular order                                       // 184\n  forEach: function (iterator) {                                                      // 185\n    var self = this;                                                                  // 186\n    _.each(self._heap, function (obj) {                                               // 187\n      return iterator(obj.value, obj.id);                                             // 188\n    });                                                                               // 189\n  },                                                                                  // 190\n  size: function () {                                                                 // 191\n    var self = this;                                                                  // 192\n    return self._heap.length;                                                         // 193\n  },                                                                                  // 194\n  setDefault: function (id, def) {                                                    // 195\n    var self = this;                                                                  // 196\n    if (self.has(id))                                                                 // 197\n      return self.get(id);                                                            // 198\n    self.set(id, def);                                                                // 199\n    return def;                                                                       // 200\n  },                                                                                  // 201\n  clone: function () {                                                                // 202\n    var self = this;                                                                  // 203\n    var clone = new MaxHeap(self._comparator, self._heap);                            // 204\n    return clone;                                                                     // 205\n  },                                                                                  // 206\n                                                                                      // 207\n  maxElementId: function () {                                                         // 208\n    var self = this;                                                                  // 209\n    return self.size() ? self._heap[0].id : null;                                     // 210\n  },                                                                                  // 211\n                                                                                      // 212\n  _selfCheck: function () {                                                           // 213\n    var self = this;                                                                  // 214\n    for (var i = 1; i < self._heap.length; i++)                                       // 215\n      if (self._maxIndex(parentIdx(i), i) !== parentIdx(i))                           // 216\n          throw new Error(\"An item with id \" + self._heap[i].id +                     // 217\n                          \" has a parent younger than it: \" +                         // 218\n                          self._heap[parentIdx(i)].id);                               // 219\n  }                                                                                   // 220\n});                                                                                   // 221\n                                                                                      // 222\nfunction leftChildIdx (i) { return i * 2 + 1; }                                       // 223\nfunction rightChildIdx (i) { return i * 2 + 2; }                                      // 224\nfunction parentIdx (i) { return (i - 1) >> 1; }                                       // 225\n                                                                                      // 226\n                                                                                      // 227\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\nMinHeap = function (comparator, options) {                                            // 1\n  var self = this;                                                                    // 2\n  MaxHeap.call(self, function (a, b) {                                                // 3\n    return -comparator(a, b);                                                         // 4\n  }, options);                                                                        // 5\n};                                                                                    // 6\n                                                                                      // 7\nMeteor._inherits(MinHeap, MaxHeap);                                                   // 8\n                                                                                      // 9\n_.extend(MinHeap.prototype, {                                                         // 10\n  maxElementId: function () {                                                         // 11\n    throw new Error(\"Cannot call maxElementId on MinHeap\");                           // 12\n  },                                                                                  // 13\n  minElementId: function () {                                                         // 14\n    var self = this;                                                                  // 15\n    return MaxHeap.prototype.maxElementId.call(self);                                 // 16\n  }                                                                                   // 17\n});                                                                                   // 18\n                                                                                      // 19\n                                                                                      // 20\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-max-heap.js                                               //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap                 // 1\n// with a Min-Heap as an encapsulated property.                                       // 2\n//                                                                                    // 3\n// Most of the operations are just proxy methods to call the same method on both      // 4\n// heaps.                                                                             // 5\n//                                                                                    // 6\n// This implementation takes 2*N memory but is fairly simple to write and             // 7\n// understand. And the constant factor of a simple Heap is usually smaller            // 8\n// compared to other two-way priority queues like Min/Max Heaps                       // 9\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)      // 10\n// and Interval Heaps                                                                 // 11\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)                       // 12\nMinMaxHeap = function (comparator, options) {                                         // 13\n  var self = this;                                                                    // 14\n                                                                                      // 15\n  MaxHeap.call(self, comparator, options);                                            // 16\n  self._minHeap = new MinHeap(comparator, options);                                   // 17\n};                                                                                    // 18\n                                                                                      // 19\nMeteor._inherits(MinMaxHeap, MaxHeap);                                                // 20\n                                                                                      // 21\n_.extend(MinMaxHeap.prototype, {                                                      // 22\n  set: function (id, value) {                                                         // 23\n    var self = this;                                                                  // 24\n    MaxHeap.prototype.set.apply(self, arguments);                                     // 25\n    self._minHeap.set(id, value);                                                     // 26\n  },                                                                                  // 27\n  remove: function (id) {                                                             // 28\n    var self = this;                                                                  // 29\n    MaxHeap.prototype.remove.apply(self, arguments);                                  // 30\n    self._minHeap.remove(id);                                                         // 31\n  },                                                                                  // 32\n  clear: function () {                                                                // 33\n    var self = this;                                                                  // 34\n    MaxHeap.prototype.clear.apply(self, arguments);                                   // 35\n    self._minHeap.clear();                                                            // 36\n  },                                                                                  // 37\n  setDefault: function (id, def) {                                                    // 38\n    var self = this;                                                                  // 39\n    MaxHeap.prototype.setDefault.apply(self, arguments);                              // 40\n    return self._minHeap.setDefault(id, def);                                         // 41\n  },                                                                                  // 42\n  clone: function () {                                                                // 43\n    var self = this;                                                                  // 44\n    var clone = new MinMaxHeap(self._comparator, self._heap);                         // 45\n    return clone;                                                                     // 46\n  },                                                                                  // 47\n  minElementId: function () {                                                         // 48\n    var self = this;                                                                  // 49\n    return self._minHeap.minElementId();                                              // 50\n  }                                                                                   // 51\n});                                                                                   // 52\n                                                                                      // 53\n                                                                                      // 54\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]