[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar RoutePolicyTest, RoutePolicy;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/routepolicy/packages/routepolicy.js                                                                       //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n(function(){                                                                                                          // 1\n                                                                                                                      // 2\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////     // 3\n//                                                                                                             //     // 4\n// packages/routepolicy/routepolicy.js                                                                         //     // 5\n//                                                                                                             //     // 6\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////     // 7\n                                                                                                               //     // 8\n// In addition to listing specific files to be cached, the browser                                             // 1   // 9\n// application cache manifest allows URLs to be designated as NETWORK                                          // 2   // 10\n// (always fetched from the Internet) and FALLBACK (which we use to                                            // 3   // 11\n// serve app HTML on arbitrary URLs).                                                                          // 4   // 12\n//                                                                                                             // 5   // 13\n// The limitation of the manifest file format is that the designations                                         // 6   // 14\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"                                            // 7   // 15\n// will also be treated as a network route.                                                                    // 8   // 16\n//                                                                                                             // 9   // 17\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:                                // 10  // 18\n//                                                                                                             // 11  // 19\n// \"network\": for network routes that should not conflict with static                                          // 12  // 20\n// resources.  (For example, if \"/sockjs/\" is a network route, we                                              // 13  // 21\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).                                                // 14  // 22\n//                                                                                                             // 15  // 23\n// \"static-online\": for static resources which should not be cached in                                         // 16  // 24\n// the app cache.  This is implemented by also adding them to the                                              // 17  // 25\n// NETWORK section (as otherwise the browser would receive app HTML                                            // 18  // 26\n// for them because of the FALLBACK section), but static-online routes                                         // 19  // 27\n// don't need to be checked for conflict with static resources.                                                // 20  // 28\n                                                                                                               // 21  // 29\n// The route policy is a singleton in a running application, but we                                            // 22  // 30\n// can't unit test the real singleton because messing with the real                                            // 23  // 31\n// routes would break tinytest... so allow policy instances to be                                              // 24  // 32\n// constructed for testing.                                                                                    // 25  // 33\n                                                                                                               // 26  // 34\nRoutePolicyTest = {};                                                                                          // 27  // 35\n                                                                                                               // 28  // 36\nvar RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {                                       // 29  // 37\n  var self = this;                                                                                             // 30  // 38\n  self.urlPrefixTypes = {};                                                                                    // 31  // 39\n};                                                                                                             // 32  // 40\n                                                                                                               // 33  // 41\n_.extend(RoutePolicyConstructor.prototype, {                                                                   // 34  // 42\n                                                                                                               // 35  // 43\n  urlPrefixMatches: function (urlPrefix, url) {                                                                // 36  // 44\n    return url.substr(0, urlPrefix.length) === urlPrefix;                                                      // 37  // 45\n  },                                                                                                           // 38  // 46\n                                                                                                               // 39  // 47\n  checkType: function (type) {                                                                                 // 40  // 48\n    if (! _.contains(['network', 'static-online'], type))                                                      // 41  // 49\n      return 'the route type must be \"network\" or \"static-online\"';                                            // 42  // 50\n    return null;                                                                                               // 43  // 51\n  },                                                                                                           // 44  // 52\n                                                                                                               // 45  // 53\n  checkUrlPrefix: function (urlPrefix, type) {                                                                 // 46  // 54\n    var self = this;                                                                                           // 47  // 55\n                                                                                                               // 48  // 56\n    if (urlPrefix.charAt(0) !== '/')                                                                           // 49  // 57\n      return 'a route URL prefix must begin with a slash';                                                     // 50  // 58\n                                                                                                               // 51  // 59\n    if (urlPrefix === '/')                                                                                     // 52  // 60\n      return 'a route URL prefix cannot be /';                                                                 // 53  // 61\n                                                                                                               // 54  // 62\n    var existingType = self.urlPrefixTypes[urlPrefix];                                                         // 55  // 63\n    if (existingType && existingType !== type)                                                                 // 56  // 64\n      return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;        // 65\n                                                                                                               // 58  // 66\n    return null;                                                                                               // 59  // 67\n  },                                                                                                           // 60  // 68\n                                                                                                               // 61  // 69\n  checkForConflictWithStatic: function (urlPrefix, type, _testManifest) {                                      // 62  // 70\n    var self = this;                                                                                           // 63  // 71\n    if (type === 'static-online')                                                                              // 64  // 72\n      return null;                                                                                             // 65  // 73\n    if (!Package.webapp || !Package.webapp.WebApp                                                              // 66  // 74\n        || !Package.webapp.WebApp.clientPrograms                                                               // 67  // 75\n        || !Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest) {                // 68  // 76\n      // Hack: If we don't have a manifest, deal with it                                                       // 69  // 77\n      // gracefully. This lets us load livedata into a nodejs                                                  // 70  // 78\n      // environment that doesn't have a HTTP server (eg, a                                                    // 71  // 79\n      // command-line tool).                                                                                   // 72  // 80\n      return null;                                                                                             // 73  // 81\n    }                                                                                                          // 74  // 82\n    var manifest = _testManifest ||                                                                            // 75  // 83\n      Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest;                        // 76  // 84\n    var conflict = _.find(manifest, function (resource) {                                                      // 77  // 85\n      return (resource.type === 'static' &&                                                                    // 78  // 86\n              resource.where === 'client' &&                                                                   // 79  // 87\n              self.urlPrefixMatches(urlPrefix, resource.url));                                                 // 80  // 88\n    });                                                                                                        // 81  // 89\n    if (conflict)                                                                                              // 82  // 90\n      return ('static resource ' + conflict.url + ' conflicts with ' +                                         // 83  // 91\n              type + ' route ' + urlPrefix);                                                                   // 84  // 92\n    else                                                                                                       // 85  // 93\n      return null;                                                                                             // 86  // 94\n  },                                                                                                           // 87  // 95\n                                                                                                               // 88  // 96\n  declare: function (urlPrefix, type) {                                                                        // 89  // 97\n    var self = this;                                                                                           // 90  // 98\n    var problem = self.checkType(type) ||                                                                      // 91  // 99\n                  self.checkUrlPrefix(urlPrefix, type) ||                                                      // 92  // 100\n                  self.checkForConflictWithStatic(urlPrefix, type);                                            // 93  // 101\n    if (problem)                                                                                               // 94  // 102\n      throw new Error(problem);                                                                                // 95  // 103\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/                                                     // 96  // 104\n    self.urlPrefixTypes[urlPrefix] = type;                                                                     // 97  // 105\n  },                                                                                                           // 98  // 106\n                                                                                                               // 99  // 107\n  isValidUrl: function (url) {                                                                                 // 100\n    return url.charAt(0) === '/';                                                                              // 101\n  },                                                                                                           // 102\n                                                                                                               // 103\n  classify: function (url) {                                                                                   // 104\n    var self = this;                                                                                           // 105\n    if (url.charAt(0) !== '/')                                                                                 // 106\n      throw new Error('url must be a relative URL: ' + url);                                                   // 107\n    var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {                                      // 108\n      return self.urlPrefixMatches(_prefix, url);                                                              // 109\n    });                                                                                                        // 110\n    if (prefix)                                                                                                // 111\n      return self.urlPrefixTypes[prefix];                                                                      // 112\n    else                                                                                                       // 113\n      return null;                                                                                             // 114\n  },                                                                                                           // 115\n                                                                                                               // 116\n  urlPrefixesFor: function (type) {                                                                            // 117\n    var self = this;                                                                                           // 118\n    var prefixes = [];                                                                                         // 119\n    _.each(self.urlPrefixTypes, function (_type, _prefix) {                                                    // 120\n      if (_type === type)                                                                                      // 121\n        prefixes.push(_prefix);                                                                                // 122\n    });                                                                                                        // 123\n    return prefixes.sort();                                                                                    // 124\n  }                                                                                                            // 125\n});                                                                                                            // 126\n                                                                                                               // 127\nRoutePolicy = new RoutePolicyConstructor();                                                                    // 128\n                                                                                                               // 129\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////     // 138\n                                                                                                                      // 139\n}).call(this);                                                                                                        // 140\n                                                                                                                      // 141\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.routepolicy = {\n  RoutePolicy: RoutePolicy,\n  RoutePolicyTest: RoutePolicyTest\n};\n\n})();\n","servePath":"/packages/routepolicy.js","sourceMap":{"version":3,"sources":["/packages/routepolicy/packages/routepolicy.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H","file":"/packages/routepolicy.js","sourcesContent":["(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/routepolicy/routepolicy.js                                                                         //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\n// In addition to listing specific files to be cached, the browser                                             // 1\n// application cache manifest allows URLs to be designated as NETWORK                                          // 2\n// (always fetched from the Internet) and FALLBACK (which we use to                                            // 3\n// serve app HTML on arbitrary URLs).                                                                          // 4\n//                                                                                                             // 5\n// The limitation of the manifest file format is that the designations                                         // 6\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"                                            // 7\n// will also be treated as a network route.                                                                    // 8\n//                                                                                                             // 9\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:                                // 10\n//                                                                                                             // 11\n// \"network\": for network routes that should not conflict with static                                          // 12\n// resources.  (For example, if \"/sockjs/\" is a network route, we                                              // 13\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).                                                // 14\n//                                                                                                             // 15\n// \"static-online\": for static resources which should not be cached in                                         // 16\n// the app cache.  This is implemented by also adding them to the                                              // 17\n// NETWORK section (as otherwise the browser would receive app HTML                                            // 18\n// for them because of the FALLBACK section), but static-online routes                                         // 19\n// don't need to be checked for conflict with static resources.                                                // 20\n                                                                                                               // 21\n// The route policy is a singleton in a running application, but we                                            // 22\n// can't unit test the real singleton because messing with the real                                            // 23\n// routes would break tinytest... so allow policy instances to be                                              // 24\n// constructed for testing.                                                                                    // 25\n                                                                                                               // 26\nRoutePolicyTest = {};                                                                                          // 27\n                                                                                                               // 28\nvar RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {                                       // 29\n  var self = this;                                                                                             // 30\n  self.urlPrefixTypes = {};                                                                                    // 31\n};                                                                                                             // 32\n                                                                                                               // 33\n_.extend(RoutePolicyConstructor.prototype, {                                                                   // 34\n                                                                                                               // 35\n  urlPrefixMatches: function (urlPrefix, url) {                                                                // 36\n    return url.substr(0, urlPrefix.length) === urlPrefix;                                                      // 37\n  },                                                                                                           // 38\n                                                                                                               // 39\n  checkType: function (type) {                                                                                 // 40\n    if (! _.contains(['network', 'static-online'], type))                                                      // 41\n      return 'the route type must be \"network\" or \"static-online\"';                                            // 42\n    return null;                                                                                               // 43\n  },                                                                                                           // 44\n                                                                                                               // 45\n  checkUrlPrefix: function (urlPrefix, type) {                                                                 // 46\n    var self = this;                                                                                           // 47\n                                                                                                               // 48\n    if (urlPrefix.charAt(0) !== '/')                                                                           // 49\n      return 'a route URL prefix must begin with a slash';                                                     // 50\n                                                                                                               // 51\n    if (urlPrefix === '/')                                                                                     // 52\n      return 'a route URL prefix cannot be /';                                                                 // 53\n                                                                                                               // 54\n    var existingType = self.urlPrefixTypes[urlPrefix];                                                         // 55\n    if (existingType && existingType !== type)                                                                 // 56\n      return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;\n                                                                                                               // 58\n    return null;                                                                                               // 59\n  },                                                                                                           // 60\n                                                                                                               // 61\n  checkForConflictWithStatic: function (urlPrefix, type, _testManifest) {                                      // 62\n    var self = this;                                                                                           // 63\n    if (type === 'static-online')                                                                              // 64\n      return null;                                                                                             // 65\n    if (!Package.webapp || !Package.webapp.WebApp                                                              // 66\n        || !Package.webapp.WebApp.clientPrograms                                                               // 67\n        || !Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest) {                // 68\n      // Hack: If we don't have a manifest, deal with it                                                       // 69\n      // gracefully. This lets us load livedata into a nodejs                                                  // 70\n      // environment that doesn't have a HTTP server (eg, a                                                    // 71\n      // command-line tool).                                                                                   // 72\n      return null;                                                                                             // 73\n    }                                                                                                          // 74\n    var manifest = _testManifest ||                                                                            // 75\n      Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest;                        // 76\n    var conflict = _.find(manifest, function (resource) {                                                      // 77\n      return (resource.type === 'static' &&                                                                    // 78\n              resource.where === 'client' &&                                                                   // 79\n              self.urlPrefixMatches(urlPrefix, resource.url));                                                 // 80\n    });                                                                                                        // 81\n    if (conflict)                                                                                              // 82\n      return ('static resource ' + conflict.url + ' conflicts with ' +                                         // 83\n              type + ' route ' + urlPrefix);                                                                   // 84\n    else                                                                                                       // 85\n      return null;                                                                                             // 86\n  },                                                                                                           // 87\n                                                                                                               // 88\n  declare: function (urlPrefix, type) {                                                                        // 89\n    var self = this;                                                                                           // 90\n    var problem = self.checkType(type) ||                                                                      // 91\n                  self.checkUrlPrefix(urlPrefix, type) ||                                                      // 92\n                  self.checkForConflictWithStatic(urlPrefix, type);                                            // 93\n    if (problem)                                                                                               // 94\n      throw new Error(problem);                                                                                // 95\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/                                                     // 96\n    self.urlPrefixTypes[urlPrefix] = type;                                                                     // 97\n  },                                                                                                           // 98\n                                                                                                               // 99\n  isValidUrl: function (url) {                                                                                 // 100\n    return url.charAt(0) === '/';                                                                              // 101\n  },                                                                                                           // 102\n                                                                                                               // 103\n  classify: function (url) {                                                                                   // 104\n    var self = this;                                                                                           // 105\n    if (url.charAt(0) !== '/')                                                                                 // 106\n      throw new Error('url must be a relative URL: ' + url);                                                   // 107\n    var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {                                      // 108\n      return self.urlPrefixMatches(_prefix, url);                                                              // 109\n    });                                                                                                        // 110\n    if (prefix)                                                                                                // 111\n      return self.urlPrefixTypes[prefix];                                                                      // 112\n    else                                                                                                       // 113\n      return null;                                                                                             // 114\n  },                                                                                                           // 115\n                                                                                                               // 116\n  urlPrefixesFor: function (type) {                                                                            // 117\n    var self = this;                                                                                           // 118\n    var prefixes = [];                                                                                         // 119\n    _.each(self.urlPrefixTypes, function (_type, _prefix) {                                                    // 120\n      if (_type === type)                                                                                      // 121\n        prefixes.push(_prefix);                                                                                // 122\n    });                                                                                                        // 123\n    return prefixes.sort();                                                                                    // 124\n  }                                                                                                            // 125\n});                                                                                                            // 126\n                                                                                                               // 127\nRoutePolicy = new RoutePolicyConstructor();                                                                    // 128\n                                                                                                               // 129\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]