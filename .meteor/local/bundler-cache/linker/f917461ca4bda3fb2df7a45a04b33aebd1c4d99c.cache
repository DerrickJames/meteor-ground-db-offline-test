[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar DiffSequence;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                        //\n// packages/diff-sequence/packages/diff-sequence.js                                       //\n//                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                          //\n(function(){                                                                              // 1\n                                                                                          // 2\n/////////////////////////////////////////////////////////////////////////////////////     // 3\n//                                                                                 //     // 4\n// packages/diff-sequence/diff.js                                                  //     // 5\n//                                                                                 //     // 6\n/////////////////////////////////////////////////////////////////////////////////////     // 7\n                                                                                   //     // 8\nDiffSequence = {};                                                                 // 1   // 9\n                                                                                   // 2   // 10\n// ordered: bool.                                                                  // 3   // 11\n// old_results and new_results: collections of documents.                          // 4   // 12\n//    if ordered, they are arrays.                                                 // 5   // 13\n//    if unordered, they are IdMaps                                                // 6   // 14\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,         // 7   // 15\n                                              observer, options) {                 // 8   // 16\n  if (ordered)                                                                     // 9   // 17\n    DiffSequence.diffQueryOrderedChanges(                                          // 10  // 18\n      oldResults, newResults, observer, options);                                  // 11  // 19\n  else                                                                             // 12  // 20\n    DiffSequence.diffQueryUnorderedChanges(                                        // 13  // 21\n      oldResults, newResults, observer, options);                                  // 14  // 22\n};                                                                                 // 15  // 23\n                                                                                   // 16  // 24\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,         // 17  // 25\n                                                       observer, options) {        // 18  // 26\n  options = options || {};                                                         // 19  // 27\n  var projectionFn = options.projectionFn || EJSON.clone;                          // 20  // 28\n                                                                                   // 21  // 29\n  if (observer.movedBefore) {                                                      // 22  // 30\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");    // 23  // 31\n  }                                                                                // 24  // 32\n                                                                                   // 25  // 33\n  newResults.forEach(function (newDoc, id) {                                       // 26  // 34\n    var oldDoc = oldResults.get(id);                                               // 27  // 35\n    if (oldDoc) {                                                                  // 28  // 36\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                     // 29  // 37\n        var projectedNew = projectionFn(newDoc);                                   // 30  // 38\n        var projectedOld = projectionFn(oldDoc);                                   // 31  // 39\n        var changedFields =                                                        // 32  // 40\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);          // 33  // 41\n        if (! _.isEmpty(changedFields)) {                                          // 34  // 42\n          observer.changed(id, changedFields);                                     // 35  // 43\n        }                                                                          // 36  // 44\n      }                                                                            // 37  // 45\n    } else if (observer.added) {                                                   // 38  // 46\n      var fields = projectionFn(newDoc);                                           // 39  // 47\n      delete fields._id;                                                           // 40  // 48\n      observer.added(newDoc._id, fields);                                          // 41  // 49\n    }                                                                              // 42  // 50\n  });                                                                              // 43  // 51\n                                                                                   // 44  // 52\n  if (observer.removed) {                                                          // 45  // 53\n    oldResults.forEach(function (oldDoc, id) {                                     // 46  // 54\n      if (!newResults.has(id))                                                     // 47  // 55\n        observer.removed(id);                                                      // 48  // 56\n    });                                                                            // 49  // 57\n  }                                                                                // 50  // 58\n};                                                                                 // 51  // 59\n                                                                                   // 52  // 60\n                                                                                   // 53  // 61\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,         // 54  // 62\n                                                     observer, options) {          // 55  // 63\n  options = options || {};                                                         // 56  // 64\n  var projectionFn = options.projectionFn || EJSON.clone;                          // 57  // 65\n                                                                                   // 58  // 66\n  var new_presence_of_id = {};                                                     // 59  // 67\n  _.each(new_results, function (doc) {                                             // 60  // 68\n    if (new_presence_of_id[doc._id])                                               // 61  // 69\n      Meteor._debug(\"Duplicate _id in new_results\");                               // 62  // 70\n    new_presence_of_id[doc._id] = true;                                            // 63  // 71\n  });                                                                              // 64  // 72\n                                                                                   // 65  // 73\n  var old_index_of_id = {};                                                        // 66  // 74\n  _.each(old_results, function (doc, i) {                                          // 67  // 75\n    if (doc._id in old_index_of_id)                                                // 68  // 76\n      Meteor._debug(\"Duplicate _id in old_results\");                               // 69  // 77\n    old_index_of_id[doc._id] = i;                                                  // 70  // 78\n  });                                                                              // 71  // 79\n                                                                                   // 72  // 80\n  // ALGORITHM:                                                                    // 73  // 81\n  //                                                                               // 74  // 82\n  // To determine which docs should be considered \"moved\" (and which               // 75  // 83\n  // merely change position because of other docs moving) we run                   // 76  // 84\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the               // 77  // 85\n  // old doc IDs and the new doc IDs gives the docs that should NOT be             // 78  // 86\n  // considered moved.                                                             // 79  // 87\n                                                                                   // 80  // 88\n  // To actually call the appropriate callbacks to get from the old state to the   // 81  // 89\n  // new state:                                                                    // 82  // 90\n                                                                                   // 83  // 91\n  // First, we call removed() on all the items that only appear in the old         // 84  // 92\n  // state.                                                                        // 85  // 93\n                                                                                   // 86  // 94\n  // Then, once we have the items that should not move, we walk through the new    // 87  // 95\n  // results array group-by-group, where a \"group\" is a set of items that have     // 88  // 96\n  // moved, anchored on the end by an item that should not move.  One by one, we   // 89  // 97\n  // move each of those elements into place \"before\" the anchoring end-of-group    // 90  // 98\n  // item, and fire changed events on them if necessary.  Then we fire a changed   // 91  // 99\n  // event on the anchor, and move on to the next group.  There is always at       // 92  // 100\n  // least one group; the last group is anchored by a virtual \"null\" id at the     // 93  // 101\n  // end.                                                                          // 94  // 102\n                                                                                   // 95  // 103\n  // Asymptotically: O(N k) where k is number of ops, or potentially               // 96  // 104\n  // O(N log N) if inner loop of LCS were made to be binary search.                // 97  // 105\n                                                                                   // 98  // 106\n                                                                                   // 99  // 107\n  //////// LCS (longest common sequence, with respect to _id)                      // 100\n  // (see Wikipedia article on Longest Increasing Subsequence,                     // 101\n  // where the LIS is taken of the sequence of old indices of the                  // 102\n  // docs in new_results)                                                          // 103\n  //                                                                               // 104\n  // unmoved: the output of the algorithm; members of the LCS,                     // 105\n  // in the form of indices into new_results                                       // 106\n  var unmoved = [];                                                                // 107\n  // max_seq_len: length of LCS found so far                                       // 108\n  var max_seq_len = 0;                                                             // 109\n  // seq_ends[i]: the index into new_results of the last doc in a                  // 110\n  // common subsequence of length of i+1 <= max_seq_len                            // 111\n  var N = new_results.length;                                                      // 112\n  var seq_ends = new Array(N);                                                     // 113\n  // ptrs:  the common subsequence ending with new_results[n] extends              // 114\n  // a common subsequence ending with new_results[ptr[n]], unless                  // 115\n  // ptr[n] is -1.                                                                 // 116\n  var ptrs = new Array(N);                                                         // 117\n  // virtual sequence of old indices of new results                                // 118\n  var old_idx_seq = function(i_new) {                                              // 119\n    return old_index_of_id[new_results[i_new]._id];                                // 120\n  };                                                                               // 121\n  // for each item in new_results, use it to extend a common subsequence           // 122\n  // of length j <= max_seq_len                                                    // 123\n  for(var i=0; i<N; i++) {                                                         // 124\n    if (old_index_of_id[new_results[i]._id] !== undefined) {                       // 125\n      var j = max_seq_len;                                                         // 126\n      // this inner loop would traditionally be a binary search,                   // 127\n      // but scanning backwards we will likely find a subseq to extend             // 128\n      // pretty soon, bounded for example by the total number of ops.              // 129\n      // If this were to be changed to a binary search, we'd still want            // 130\n      // to scan backwards a bit as an optimization.                               // 131\n      while (j > 0) {                                                              // 132\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                           // 133\n          break;                                                                   // 134\n        j--;                                                                       // 135\n      }                                                                            // 136\n                                                                                   // 137\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                    // 138\n      seq_ends[j] = i;                                                             // 139\n      if (j+1 > max_seq_len)                                                       // 140\n        max_seq_len = j+1;                                                         // 141\n    }                                                                              // 142\n  }                                                                                // 143\n                                                                                   // 144\n  // pull out the LCS/LIS into unmoved                                             // 145\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                    // 146\n  while (idx >= 0) {                                                               // 147\n    unmoved.push(idx);                                                             // 148\n    idx = ptrs[idx];                                                               // 149\n  }                                                                                // 150\n  // the unmoved item list is built backwards, so fix that                         // 151\n  unmoved.reverse();                                                               // 152\n                                                                                   // 153\n  // the last group is always anchored by the end of the result list, which is     // 154\n  // an id of \"null\"                                                               // 155\n  unmoved.push(new_results.length);                                                // 156\n                                                                                   // 157\n  _.each(old_results, function (doc) {                                             // 158\n    if (!new_presence_of_id[doc._id])                                              // 159\n      observer.removed && observer.removed(doc._id);                               // 160\n  });                                                                              // 161\n  // for each group of things in the new_results that is anchored by an unmoved    // 162\n  // element, iterate through the things before it.                                // 163\n  var startOfGroup = 0;                                                            // 164\n  _.each(unmoved, function (endOfGroup) {                                          // 165\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;    // 166\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;                        // 167\n    for (var i = startOfGroup; i < endOfGroup; i++) {                              // 168\n      newDoc = new_results[i];                                                     // 169\n      if (!_.has(old_index_of_id, newDoc._id)) {                                   // 170\n        fields = projectionFn(newDoc);                                             // 171\n        delete fields._id;                                                         // 172\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);        // 181\n        observer.added && observer.added(newDoc._id, fields);                      // 174\n      } else {                                                                     // 175\n        // moved                                                                   // 176\n        oldDoc = old_results[old_index_of_id[newDoc._id]];                         // 177\n        projectedNew = projectionFn(newDoc);                                       // 178\n        projectedOld = projectionFn(oldDoc);                                       // 179\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);       // 180\n        if (!_.isEmpty(fields)) {                                                  // 181\n          observer.changed && observer.changed(newDoc._id, fields);                // 182\n        }                                                                          // 183\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);         // 184\n      }                                                                            // 185\n    }                                                                              // 186\n    if (groupId) {                                                                 // 187\n      newDoc = new_results[endOfGroup];                                            // 188\n      oldDoc = old_results[old_index_of_id[newDoc._id]];                           // 189\n      projectedNew = projectionFn(newDoc);                                         // 190\n      projectedOld = projectionFn(oldDoc);                                         // 191\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);         // 192\n      if (!_.isEmpty(fields)) {                                                    // 193\n        observer.changed && observer.changed(newDoc._id, fields);                  // 194\n      }                                                                            // 195\n    }                                                                              // 196\n    startOfGroup = endOfGroup+1;                                                   // 197\n  });                                                                              // 198\n                                                                                   // 199\n                                                                                   // 200\n};                                                                                 // 201\n                                                                                   // 202\n                                                                                   // 203\n// General helper for diff-ing two objects.                                        // 204\n// callbacks is an object like so:                                                 // 205\n// { leftOnly: function (key, leftValue) {...},                                    // 206\n//   rightOnly: function (key, rightValue) {...},                                  // 207\n//   both: function (key, leftValue, rightValue) {...},                            // 208\n// }                                                                               // 209\nDiffSequence.diffObjects = function (left, right, callbacks) {                     // 210\n  _.each(left, function (leftValue, key) {                                         // 211\n    if (_.has(right, key))                                                         // 212\n      callbacks.both && callbacks.both(key, leftValue, right[key]);                // 213\n    else                                                                           // 214\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                    // 215\n  });                                                                              // 216\n  if (callbacks.rightOnly) {                                                       // 217\n    _.each(right, function(rightValue, key) {                                      // 218\n      if (!_.has(left, key))                                                       // 219\n        callbacks.rightOnly(key, rightValue);                                      // 220\n    });                                                                            // 221\n  }                                                                                // 222\n};                                                                                 // 223\n                                                                                   // 224\n                                                                                   // 225\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {                       // 226\n  var fields = {};                                                                 // 227\n  DiffSequence.diffObjects(oldDoc, newDoc, {                                       // 228\n    leftOnly: function (key, value) {                                              // 229\n      fields[key] = undefined;                                                     // 230\n    },                                                                             // 231\n    rightOnly: function (key, value) {                                             // 232\n      fields[key] = value;                                                         // 233\n    },                                                                             // 234\n    both: function (key, leftValue, rightValue) {                                  // 235\n      if (!EJSON.equals(leftValue, rightValue))                                    // 236\n        fields[key] = rightValue;                                                  // 237\n    }                                                                              // 238\n  });                                                                              // 239\n  return fields;                                                                   // 240\n};                                                                                 // 241\n                                                                                   // 242\nDiffSequence.applyChanges = function (doc, changeFields) {                         // 243\n  _.each(changeFields, function (value, key) {                                     // 244\n    if (value === undefined)                                                       // 245\n      delete doc[key];                                                             // 246\n    else                                                                           // 247\n      doc[key] = value;                                                            // 248\n  });                                                                              // 249\n};                                                                                 // 250\n                                                                                   // 251\n                                                                                   // 252\n/////////////////////////////////////////////////////////////////////////////////////     // 261\n                                                                                          // 262\n}).call(this);                                                                            // 263\n                                                                                          // 264\n////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['diff-sequence'] = {\n  DiffSequence: DiffSequence\n};\n\n})();\n","servePath":"/packages/diff-sequence.js","sourceMap":{"version":3,"sources":["/packages/diff-sequence/packages/diff-sequence.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/diff-sequence.js","sourcesContent":["(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/diff-sequence/diff.js                                                  //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\nDiffSequence = {};                                                                 // 1\n                                                                                   // 2\n// ordered: bool.                                                                  // 3\n// old_results and new_results: collections of documents.                          // 4\n//    if ordered, they are arrays.                                                 // 5\n//    if unordered, they are IdMaps                                                // 6\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,         // 7\n                                              observer, options) {                 // 8\n  if (ordered)                                                                     // 9\n    DiffSequence.diffQueryOrderedChanges(                                          // 10\n      oldResults, newResults, observer, options);                                  // 11\n  else                                                                             // 12\n    DiffSequence.diffQueryUnorderedChanges(                                        // 13\n      oldResults, newResults, observer, options);                                  // 14\n};                                                                                 // 15\n                                                                                   // 16\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,         // 17\n                                                       observer, options) {        // 18\n  options = options || {};                                                         // 19\n  var projectionFn = options.projectionFn || EJSON.clone;                          // 20\n                                                                                   // 21\n  if (observer.movedBefore) {                                                      // 22\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");    // 23\n  }                                                                                // 24\n                                                                                   // 25\n  newResults.forEach(function (newDoc, id) {                                       // 26\n    var oldDoc = oldResults.get(id);                                               // 27\n    if (oldDoc) {                                                                  // 28\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                     // 29\n        var projectedNew = projectionFn(newDoc);                                   // 30\n        var projectedOld = projectionFn(oldDoc);                                   // 31\n        var changedFields =                                                        // 32\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);          // 33\n        if (! _.isEmpty(changedFields)) {                                          // 34\n          observer.changed(id, changedFields);                                     // 35\n        }                                                                          // 36\n      }                                                                            // 37\n    } else if (observer.added) {                                                   // 38\n      var fields = projectionFn(newDoc);                                           // 39\n      delete fields._id;                                                           // 40\n      observer.added(newDoc._id, fields);                                          // 41\n    }                                                                              // 42\n  });                                                                              // 43\n                                                                                   // 44\n  if (observer.removed) {                                                          // 45\n    oldResults.forEach(function (oldDoc, id) {                                     // 46\n      if (!newResults.has(id))                                                     // 47\n        observer.removed(id);                                                      // 48\n    });                                                                            // 49\n  }                                                                                // 50\n};                                                                                 // 51\n                                                                                   // 52\n                                                                                   // 53\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,         // 54\n                                                     observer, options) {          // 55\n  options = options || {};                                                         // 56\n  var projectionFn = options.projectionFn || EJSON.clone;                          // 57\n                                                                                   // 58\n  var new_presence_of_id = {};                                                     // 59\n  _.each(new_results, function (doc) {                                             // 60\n    if (new_presence_of_id[doc._id])                                               // 61\n      Meteor._debug(\"Duplicate _id in new_results\");                               // 62\n    new_presence_of_id[doc._id] = true;                                            // 63\n  });                                                                              // 64\n                                                                                   // 65\n  var old_index_of_id = {};                                                        // 66\n  _.each(old_results, function (doc, i) {                                          // 67\n    if (doc._id in old_index_of_id)                                                // 68\n      Meteor._debug(\"Duplicate _id in old_results\");                               // 69\n    old_index_of_id[doc._id] = i;                                                  // 70\n  });                                                                              // 71\n                                                                                   // 72\n  // ALGORITHM:                                                                    // 73\n  //                                                                               // 74\n  // To determine which docs should be considered \"moved\" (and which               // 75\n  // merely change position because of other docs moving) we run                   // 76\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the               // 77\n  // old doc IDs and the new doc IDs gives the docs that should NOT be             // 78\n  // considered moved.                                                             // 79\n                                                                                   // 80\n  // To actually call the appropriate callbacks to get from the old state to the   // 81\n  // new state:                                                                    // 82\n                                                                                   // 83\n  // First, we call removed() on all the items that only appear in the old         // 84\n  // state.                                                                        // 85\n                                                                                   // 86\n  // Then, once we have the items that should not move, we walk through the new    // 87\n  // results array group-by-group, where a \"group\" is a set of items that have     // 88\n  // moved, anchored on the end by an item that should not move.  One by one, we   // 89\n  // move each of those elements into place \"before\" the anchoring end-of-group    // 90\n  // item, and fire changed events on them if necessary.  Then we fire a changed   // 91\n  // event on the anchor, and move on to the next group.  There is always at       // 92\n  // least one group; the last group is anchored by a virtual \"null\" id at the     // 93\n  // end.                                                                          // 94\n                                                                                   // 95\n  // Asymptotically: O(N k) where k is number of ops, or potentially               // 96\n  // O(N log N) if inner loop of LCS were made to be binary search.                // 97\n                                                                                   // 98\n                                                                                   // 99\n  //////// LCS (longest common sequence, with respect to _id)                      // 100\n  // (see Wikipedia article on Longest Increasing Subsequence,                     // 101\n  // where the LIS is taken of the sequence of old indices of the                  // 102\n  // docs in new_results)                                                          // 103\n  //                                                                               // 104\n  // unmoved: the output of the algorithm; members of the LCS,                     // 105\n  // in the form of indices into new_results                                       // 106\n  var unmoved = [];                                                                // 107\n  // max_seq_len: length of LCS found so far                                       // 108\n  var max_seq_len = 0;                                                             // 109\n  // seq_ends[i]: the index into new_results of the last doc in a                  // 110\n  // common subsequence of length of i+1 <= max_seq_len                            // 111\n  var N = new_results.length;                                                      // 112\n  var seq_ends = new Array(N);                                                     // 113\n  // ptrs:  the common subsequence ending with new_results[n] extends              // 114\n  // a common subsequence ending with new_results[ptr[n]], unless                  // 115\n  // ptr[n] is -1.                                                                 // 116\n  var ptrs = new Array(N);                                                         // 117\n  // virtual sequence of old indices of new results                                // 118\n  var old_idx_seq = function(i_new) {                                              // 119\n    return old_index_of_id[new_results[i_new]._id];                                // 120\n  };                                                                               // 121\n  // for each item in new_results, use it to extend a common subsequence           // 122\n  // of length j <= max_seq_len                                                    // 123\n  for(var i=0; i<N; i++) {                                                         // 124\n    if (old_index_of_id[new_results[i]._id] !== undefined) {                       // 125\n      var j = max_seq_len;                                                         // 126\n      // this inner loop would traditionally be a binary search,                   // 127\n      // but scanning backwards we will likely find a subseq to extend             // 128\n      // pretty soon, bounded for example by the total number of ops.              // 129\n      // If this were to be changed to a binary search, we'd still want            // 130\n      // to scan backwards a bit as an optimization.                               // 131\n      while (j > 0) {                                                              // 132\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                           // 133\n          break;                                                                   // 134\n        j--;                                                                       // 135\n      }                                                                            // 136\n                                                                                   // 137\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                    // 138\n      seq_ends[j] = i;                                                             // 139\n      if (j+1 > max_seq_len)                                                       // 140\n        max_seq_len = j+1;                                                         // 141\n    }                                                                              // 142\n  }                                                                                // 143\n                                                                                   // 144\n  // pull out the LCS/LIS into unmoved                                             // 145\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                    // 146\n  while (idx >= 0) {                                                               // 147\n    unmoved.push(idx);                                                             // 148\n    idx = ptrs[idx];                                                               // 149\n  }                                                                                // 150\n  // the unmoved item list is built backwards, so fix that                         // 151\n  unmoved.reverse();                                                               // 152\n                                                                                   // 153\n  // the last group is always anchored by the end of the result list, which is     // 154\n  // an id of \"null\"                                                               // 155\n  unmoved.push(new_results.length);                                                // 156\n                                                                                   // 157\n  _.each(old_results, function (doc) {                                             // 158\n    if (!new_presence_of_id[doc._id])                                              // 159\n      observer.removed && observer.removed(doc._id);                               // 160\n  });                                                                              // 161\n  // for each group of things in the new_results that is anchored by an unmoved    // 162\n  // element, iterate through the things before it.                                // 163\n  var startOfGroup = 0;                                                            // 164\n  _.each(unmoved, function (endOfGroup) {                                          // 165\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;    // 166\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;                        // 167\n    for (var i = startOfGroup; i < endOfGroup; i++) {                              // 168\n      newDoc = new_results[i];                                                     // 169\n      if (!_.has(old_index_of_id, newDoc._id)) {                                   // 170\n        fields = projectionFn(newDoc);                                             // 171\n        delete fields._id;                                                         // 172\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n        observer.added && observer.added(newDoc._id, fields);                      // 174\n      } else {                                                                     // 175\n        // moved                                                                   // 176\n        oldDoc = old_results[old_index_of_id[newDoc._id]];                         // 177\n        projectedNew = projectionFn(newDoc);                                       // 178\n        projectedOld = projectionFn(oldDoc);                                       // 179\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);       // 180\n        if (!_.isEmpty(fields)) {                                                  // 181\n          observer.changed && observer.changed(newDoc._id, fields);                // 182\n        }                                                                          // 183\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);         // 184\n      }                                                                            // 185\n    }                                                                              // 186\n    if (groupId) {                                                                 // 187\n      newDoc = new_results[endOfGroup];                                            // 188\n      oldDoc = old_results[old_index_of_id[newDoc._id]];                           // 189\n      projectedNew = projectionFn(newDoc);                                         // 190\n      projectedOld = projectionFn(oldDoc);                                         // 191\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);         // 192\n      if (!_.isEmpty(fields)) {                                                    // 193\n        observer.changed && observer.changed(newDoc._id, fields);                  // 194\n      }                                                                            // 195\n    }                                                                              // 196\n    startOfGroup = endOfGroup+1;                                                   // 197\n  });                                                                              // 198\n                                                                                   // 199\n                                                                                   // 200\n};                                                                                 // 201\n                                                                                   // 202\n                                                                                   // 203\n// General helper for diff-ing two objects.                                        // 204\n// callbacks is an object like so:                                                 // 205\n// { leftOnly: function (key, leftValue) {...},                                    // 206\n//   rightOnly: function (key, rightValue) {...},                                  // 207\n//   both: function (key, leftValue, rightValue) {...},                            // 208\n// }                                                                               // 209\nDiffSequence.diffObjects = function (left, right, callbacks) {                     // 210\n  _.each(left, function (leftValue, key) {                                         // 211\n    if (_.has(right, key))                                                         // 212\n      callbacks.both && callbacks.both(key, leftValue, right[key]);                // 213\n    else                                                                           // 214\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                    // 215\n  });                                                                              // 216\n  if (callbacks.rightOnly) {                                                       // 217\n    _.each(right, function(rightValue, key) {                                      // 218\n      if (!_.has(left, key))                                                       // 219\n        callbacks.rightOnly(key, rightValue);                                      // 220\n    });                                                                            // 221\n  }                                                                                // 222\n};                                                                                 // 223\n                                                                                   // 224\n                                                                                   // 225\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {                       // 226\n  var fields = {};                                                                 // 227\n  DiffSequence.diffObjects(oldDoc, newDoc, {                                       // 228\n    leftOnly: function (key, value) {                                              // 229\n      fields[key] = undefined;                                                     // 230\n    },                                                                             // 231\n    rightOnly: function (key, value) {                                             // 232\n      fields[key] = value;                                                         // 233\n    },                                                                             // 234\n    both: function (key, leftValue, rightValue) {                                  // 235\n      if (!EJSON.equals(leftValue, rightValue))                                    // 236\n        fields[key] = rightValue;                                                  // 237\n    }                                                                              // 238\n  });                                                                              // 239\n  return fields;                                                                   // 240\n};                                                                                 // 241\n                                                                                   // 242\nDiffSequence.applyChanges = function (doc, changeFields) {                         // 243\n  _.each(changeFields, function (value, key) {                                     // 244\n    if (value === undefined)                                                       // 245\n      delete doc[key];                                                             // 246\n    else                                                                           // 247\n      doc[key] = value;                                                            // 248\n  });                                                                              // 249\n};                                                                                 // 250\n                                                                                   // 251\n                                                                                   // 252\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]